<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[自言自语]]></title>
  <link href="http://liubin.org/atom.xml" rel="self"/>
  <link href="http://liubin.org/"/>
  <updated>2021-01-28T15:03:08+08:00</updated>
  <id>http://liubin.org/</id>
  <author>
    <name><![CDATA[bin liu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[安装老版本的 Kubernetes]]></title>
    <link href="http://liubin.org/blog/2021/01/28/install-old-version-k8s/"/>
    <updated>2021-01-28T14:56:13+08:00</updated>
    <id>http://liubin.org/blog/2021/01/28/install-old-version-k8s</id>
    <content type="html"><![CDATA[<p>记得前些日子看过一个报告，说是私有部署中公司内部用的 Kubernetes ，要比社区版延迟有 17 个月。所以，在很多公司，安装一个老版本的 Kubernetes ，可能还真是一个日常操作。</p>

<p>不过不光 Kubernetes 有版本问题，连它的安装工具 kubeadm 也是有版本要求的，要想安装指定版本的 Kubernetes ，还得安装指定版本的 kubeadm 。</p>

<p>这里以在 Ubuntu 下为例，记录一下如何安装一个 1.16 版本的 Kubernetes。</p>

<p>可以使用 <code>apt-cache</code> 命令查看支持的 Kubernetes 版本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># apt-cache madison kubectl | grep 1.16
</span><span class='line'>   kubectl | 1.16.15-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl | 1.16.14-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl | 1.16.13-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl | 1.16.12-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl | 1.16.11-01 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl | 1.16.11-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl | 1.16.10-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.9-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.8-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.7-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.6-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.5-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.4-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.3-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.2-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.1-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages
</span><span class='line'>   kubectl |  1.16.0-00 | https://apt.kubernetes.io kubernetes-xenial/main amd64 Packages</span></code></pre></td></tr></table></div></figure>


<p>所以我们可以选择一个最大的数字来作为版本号安装。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># apt install -y kubelet=1.16.15-00 kubeadm=1.16.15-00 kubectl=1.16.15-00
</span><span class='line'>
</span><span class='line'>... ...
</span><span class='line'>
</span><span class='line'>Setting up kubelet (1.16.15-00) ...
</span><span class='line'>Setting up kubectl (1.16.15-00) ...
</span><span class='line'>Setting up kubeadm (1.16.15-00) ...</span></code></pre></td></tr></table></div></figure>


<p>最后再使用 kubeadm 安装指定版本的 Kubernetes：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># kubeadm init --cri-socket /run/containerd/containerd.sock \
</span><span class='line'>    --pod-network-cidr=10.244.0.0/16 \
</span><span class='line'>    --apiserver-advertise-address 192.168.2.147 \
</span><span class='line'>    --kubernetes-version v1.16.0</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust 学习笔记：package/crate/module]]></title>
    <link href="http://liubin.org/blog/2021/01/19/packages-slash-crate-slash-modules-in-rust/"/>
    <updated>2021-01-19T20:45:37+08:00</updated>
    <id>http://liubin.org/blog/2021/01/19/packages-slash-crate-slash-modules-in-rust</id>
    <content type="html"><![CDATA[<p>cargo new 会生成项目的雏形，提供了src/main.rs和src/lib.rs文件，但是随着项目的增长，代码的量也会变大，靠一个文件维护一大堆代码，肯定是不合适的。这时候一般都会按“模块”来拆分文件，rust也不例外。</p>

<p>这里学习一下rust中代码的组织方式，主要涉及到以下几个概念：</p>

<ul>
<li>package：Cargo中的概念，管理crate</li>
<li>crate：模块的集合，编译单位，有lib和bin两种，即供别人调用，或者是一个可执行文件</li>
<li>module：用于在crate内组织代码</li>
<li>workspace：项目复杂时，管理多个package</li>
</ul>


<h2>package</h2>

<p>cargo new 命令会创建一个新项目，也是一个package，里面有一个Cargo.toml文件，用于定义package、所需外部依赖，以及如何编译crate等。</p>

<h2>crate</h2>

<p>rust里有两种crate，lib类型和bin类型，并且默认以文件名为标准按以下规则处理crate：</p>

<ul>
<li>src/main.rs：表示该crate是一个bin类型的crate</li>
<li>src/lib.rs：表示该crate是一个lib类型的crate</li>
</ul>


<p>src/main.rs和src/lib.rs都是crate的根，也就是crate引用、rustc编译的入口。</p>

<p>此外，一个package中的crate还有如下约束：</p>

<ol>
<li>多个bin类型的crate</li>
<li>0个或1个lib类型的crate</li>
</ol>


<p>其中，1和2并不互斥，也就是说一个项目下可以有1个lib和多个bin类型的crate，即一个package还以编译出多个可执行文件。</p>

<p>只是如果有多个bin类型的crate，一个src/main.rs就不行了，就得放到 src/bin 下面，每个crate一个文件，换句话说，每个文件都是一个不同的crate。</p>

<h2>mod</h2>

<p>代码多了可以对代码以mod（文件/文件夹）为单位进行拆分，而不必把所有代码都写在src/lib.rs或者src/main.rs里。</p>

<p>以lib类型的crate为例，该crate的入口在src/lib.rs，也是crate的根。在 src/lib.rs 里定义模块很简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">mymod</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而实际项目中，我们都不可能只有一个lib.rs文件，而是会将代码按功能等拆分为多个模块。</p>

<h3>模块拆分</h3>

<p>一般来说，一个文件都会被视为一个mod，而且mod可以嵌套定义。嵌套定义的mod既可以写在同一个文件里，也可以通过文件夹的形式来实现。</p>

<p>具体我们来看几个例子。</p>

<p>假设当前项目文件结构如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="n">src</span>
</span><span class='line'><span class="err">├──</span> <span class="n">lib</span><span class="p">.</span><span class="n">rs</span>
</span><span class='line'><span class="err">├──</span> <span class="n">mod_a</span>
</span><span class='line'><span class="err">│</span>   <span class="err">├──</span> <span class="kn">mod</span><span class="p">.</span><span class="n">rs</span>
</span><span class='line'><span class="err">│</span>   <span class="err">└──</span> <span class="n">mod_b</span><span class="p">.</span><span class="n">rs</span>
</span><span class='line'><span class="err">└──</span> <span class="n">mod_c</span><span class="p">.</span><span class="n">rs</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里显示定义了3个mod：mod_a、mod_b和mod_c，其中mod_a为文件夹形式，而mod b 和mod c都有对应的文件。其中mod_b是mod_a的子模块。</p>

<p>我们来看一下各个模块是怎么声明的，以及应该如何引用。</p>

<p>首先来看一下crate的根，也就是入口lib.rs：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">pub</span> <span class="kn">mod</span> <span class="n">mod_a</span><span class="p">;</span>
</span><span class='line'><span class="kn">mod</span> <span class="n">mod_c</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里声明了两个mod，如果需要在crate外部访问，可以在mod前面加上pub关键字。注意这里不需要声明mod_a的子模块mod_c，这个需要由mod_a来声明。</p>

<p>再来看一下这两个mod。先看mod_a，这是一个文件夹形式存在的mod，按cargo规定，这时候需要在该文件夹下有一个名为mod.rs的文件定义该mod下的内容。该文件内容如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// src/mod_a/mod.rs</span>
</span><span class='line'><span class="k">pub</span> <span class="kn">mod</span> <span class="n">mod_b</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，这个文件和lib.rs类似，都可以声明mod。该文件声明的mod_b的代码则保存为mod_b.rs：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// src/mod_a/mod_b.rs</span>
</span><span class='line'><span class="kn">use</span> <span class="n">super</span><span class="o">::</span><span class="n">super</span><span class="o">::</span><span class="n">mod_c</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;i&#39;m mod_b&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">call_mod_c</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">mod_c</span><span class="o">::</span><span class="n">test</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>再来看一下mod_c的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// src/mod_c.rs</span>
</span><span class='line'><span class="kn">use</span> <span class="n">crate</span><span class="o">::</span><span class="n">mod_a</span><span class="o">::</span><span class="n">mod_b</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">mod_b</span><span class="o">::</span><span class="n">test</span><span class="p">();</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;i&#39;, mod_c&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了如何定义mod，还需要注意的是如何引用其他mod的定义。这里在mod_c中，要想使用mod_b，可以使用 <strong>use crate::mod_a::mod_b</strong> 这种绝对路径形式。</p>

<p>而在mod_b中使用mod_c的时候，使用了 <strong>use super::super::mod_c</strong> 这种先对路径的形式。</p>

<h3>添加main.rs</h3>

<p>最后在上面代码的基础上添加一下main.rs，看看如何作为外部crate使用上面的mod_a。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// src/main.rs</span>
</span><span class='line'><span class="kn">use</span> <span class="n">testlib</span><span class="o">::</span><span class="n">mod_a</span><span class="o">::</span><span class="n">mod_b</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">mod_b</span><span class="o">::</span><span class="n">test</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里唯一想要提醒的就是lib的引用方法，不能使用crate开头的绝对路径或者相对路径引用方式，必须使用该crate的名称（也就是Cargo.toml里的名称，本例为testlib）来引用。因为main和lib分别属于不同的crate。</p>

<p>假如将上面的testlib改为crate，编译器会报如下错误：</p>

<p><img class="center-image" src="http://liubin.org/images/2021/01/rust-compile-error.png" title="'编译错误'" ></p>

<p>很多时候编译器都是我们最好的老师。</p>

<h3>pub修饰符</h3>

<h4>结构体和枚举</h4>

<p>要想访问其他mod里的结构体，需要将结构体声明为pub，但是这也只能访问到结构体而已，如果要想操作里面的字段，可以有两种方式：</p>

<ul>
<li>提供pub的方法修改字段</li>
<li>将需要操作的字段直接修改为pub类型</li>
</ul>


<p>可能前者更“面向对象”一些。</p>

<p>而枚举类型的话只需要在枚举名前面加上pub即可，不需要对其中的variant进行设置。</p>

<h2>use语句</h2>

<p>讲了这么多基础概念，下面看一下如何使用。</p>

<p>在crate和模块了可能定义了函数、结构体等，要想在其他模块或crate使用，需要将其引入到当前scope中，类似java的import的功能，rust里需要使用use。</p>

<p>如何表示要被引用的对象（rust中称为item），rust里称之为path，可以理解为我们在操作系统里使用文件一下。</p>

<p>rust中path有两种形式，也跟文件系统一样，绝对路径和相对路径：</p>

<ul>
<li>绝对路径始于crate的根（src/main.rs或src/lib.rs），可以使用crate名或者crate这个字面值表示</li>
<li>相对路径可以使用当前模块名、当前模块中可以使用的对象，super和self等。</li>
</ul>


<p>path中的层级使用两个冒号，类似文件系统中的斜线。</p>

<p>假设有如下代码（来自trpl）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">mod</span> <span class="n">front_of_house</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">pub</span> <span class="kn">mod</span> <span class="n">hosting</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">pub</span> <span class="k">fn</span> <span class="n">add_to_waitlist</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="k">fn</span> <span class="n">eat_at_restaurant</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Absolute path</span>
</span><span class='line'>    <span class="n">crate</span><span class="o">::</span><span class="n">front_of_house</span><span class="o">::</span><span class="n">hosting</span><span class="o">::</span><span class="n">add_to_waitlist</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Relative path</span>
</span><span class='line'>    <span class="n">front_of_house</span><span class="o">::</span><span class="n">hosting</span><span class="o">::</span><span class="n">add_to_waitlist</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的第9行就是绝对路径形式的引用，而第12行就是相对路径的引用，这里，front_of_house处于crate的根之下，而不是位于其他子模块之下。</p>

<p>有一些限制需要知道：</p>

<ul>
<li>在父模块中不能使用子模块中的private项目</li>
<li>子模块可以使用父模块中的所有item</li>
</ul>


<p>注意 front_of_house 模块虽然不是pub的，但是eat_at_restaurant却可以使用，因为他们在同一模块下，这不需要pub就可以使用，否则所有item都只能变成pub才能使用了。但是hosting模块和add_to_waitlist方法必须为pub类型的，否则就不能从他们的父模块中的项目中使用了。</p>

<p>下面是一个使用了super的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">serve_order</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="kn">mod</span> <span class="n">back_of_house</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">fix_incorrect_order</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">cook_order</span><span class="p">();</span>
</span><span class='line'>        <span class="n">super</span><span class="o">::</span><span class="n">serve_order</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">fn</span> <span class="n">cook_order</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>fix_incorrect_order方法属于back_of_house模块，要调用的serve_order和back_of_house同级，因此在back_of_house模块中的函数里，可以使用super::serve_order，访问到该模块同级的serve_order方法。</p>

<p>如果use后面的路径具有具有共同的父路径，可以使用简化的模式。比如 ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="p">;</span>
</span><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">cmp</span><span class="o">::</span><span class="nb">Ordering</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以简化为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="p">{</span><span class="n">cmp</span><span class="o">::</span><span class="nb">Ordering</span><span class="p">,</span> <span class="n">io</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果同时use的mod之间有父子关系，也可以像上面那样简化，使用self代表父mod。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="p">;</span>
</span><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">Write</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以简化为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="p">{</span><span class="bp">self</span><span class="p">,</span> <span class="n">Write</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想将某一路径下的所有public的item都引入到当前scope中，可以使用<code>*</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">collections</span><span class="o">::*</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般业务代码文件内的单元测试中常用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="cp">#[cfg(test)]</span>
</span><span class='line'><span class="kn">mod</span> <span class="n">tests</span> <span class="p">{</span>
</span><span class='line'>    <span class="kn">use</span> <span class="n">super</span><span class="o">::*</span><span class="p">;</span>
</span><span class='line'>    <span class="cp">#[test]</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">it_works</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样在单测mod中，可以使用父mod中的所有item。</p>

<h3>引用层级</h3>

<p>对比两段代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="err">#</span> <span class="n">case</span> <span class="mi">1</span>
</span><span class='line'><span class="kn">use</span> <span class="n">crate</span><span class="o">::</span><span class="n">front_of_house</span><span class="o">::</span><span class="n">hosting</span><span class="p">;</span>
</span><span class='line'><span class="n">hosting</span><span class="o">::</span><span class="n">add_to_waitlist</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="err">#</span> <span class="n">case</span> <span class="mi">2</span>
</span><span class='line'><span class="kn">use</span> <span class="n">crate</span><span class="o">::</span><span class="n">front_of_house</span><span class="o">::</span><span class="n">hosting</span><span class="o">::</span><span class="n">add_to_waitlist</span><span class="p">;</span>
</span><span class='line'><span class="n">add_to_waitlist</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两种方法结果一样，但是阅读起来给人的感觉是不一样的。一般来说推荐前者，因为这样可以明确的知道使用的方法是外部的hosting模块的方法，后者的话则不知道该方法是use进来的，还是本模块定义的。</p>

<h3>名称冲突</h3>

<p>有的时候可能从不同的crate或者mod引入了同名的item，这时候最简单的方式是使用 as 关键字进行重命名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">fmt</span><span class="p">;</span>
</span><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">function1</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">fmt</span><span class="o">::</span><span class="nb">Result</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">function2</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">io</span><span class="o">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">fmt</span><span class="o">::</span><span class="nb">Result</span><span class="p">;</span>
</span><span class='line'><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="nb">Result</span> <span class="k">as</span> <span class="n">IoResult</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">function1</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">function2</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">IoResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>re-exporting 再导出</h3>

<p>当使用use关键字将外部item导入到当前scope之后，这个item在当前scope是private的，如果使用 pub use 的话，还能让使用当前mod的第三者，使用在该mod中引入的item。</p>

<p>该机制称为 re-exporting 。</p>

<h2>workspace</h2>

<p>workspace用于管理多个相关的package，不同的package有各自的Cargo.toml，但是整个workspace共享一个Cargo.lock，也只有一个target目录（编译输出）。</p>

<p>虽然workspace内的项目共享一个Cargo.lock，但是他们之间默认不互相依赖，需要显示添加它们之间的依赖关系。而且在一个项目中添加的依赖，在其他项目中如果想使用，还需要再次声明依赖才行。</p>

<p>不过据我观察workspace功能没有什么特别强大之处，不使用该功能也可以同时管理几个Cargo项目，因此这里就不再深入介绍了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于 K8s Mutating Webhook 的几点摘记]]></title>
    <link href="http://liubin.org/blog/2021/01/18/something-about-k8s-mutatingwebhook/"/>
    <updated>2021-01-18T17:03:56+08:00</updated>
    <id>http://liubin.org/blog/2021/01/18/something-about-k8s-mutatingwebhook</id>
    <content type="html"><![CDATA[<p>最近又写了一个 K8s 的 Mutating Webhook ，阅读了一下 <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">官方文档</a>，有些特殊需要记住的地摘记如下。虽然主要是针对 Mutating 类型的 webhook 的，但是应该对 Validating 类型的 webhook 一样有效。</p>

<h2>版本说明</h2>

<p>在 K8s 里编程最麻烦的一件事就是版本的问题，以及由此引起的 go mod 的依赖问题。所以在写代码之前，参考别人的代码之前，第一件事就是要确认需要支持和使用的各 API 版本。</p>

<p>对于 Mutating Webhook 来说，在 K8s 1.9 之前，API 版本需要使用 <code>admissionregistration.k8s.io/v1beta1</code> ，如果是 1.16 之后的 K8s ，则使用 <code>admissionregistration.k8s.io/v1</code>。</p>

<h2>默认超时时间</h2>

<p>对于 <code>admissionregistration.k8s.io/v1</code> 来说，默认超时时间是 10s，对于 <code>admissionregistration.k8s.io/v1beta1</code> 来说默认的超时时间是 30s。</p>

<p>但是从 K8s 1.14 开始支持自定义超时时间。一般来说推荐使用一个较小的 timeout 值，这有两个原因，一是 webhook 一般都跑在 K8s 同一个集群中，所以不会有太大延迟。二是这个值如果太大了，会增加资源创建的延迟，降低响应时间。Webhook 耗时太长，应该说程序有问题或者设计有问题，本着 fast fail 的原则，应该设置较小的 timeout 时间。</p>

<h2>关于资源过滤器</h2>

<p>可以使用资源过滤器来过滤需要进行修改的资源。</p>

<h3>objectSelector</h3>

<p>比如下面的例子只选择带有 <code>foo: bar</code> label 的资源。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">admissionregistration.k8s.io/v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">MutatingWebhookConfiguration</span>
</span><span class='line'><span class="l-Scalar-Plain">webhooks</span><span class="p-Indicator">:</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-webhook.example.com</span>
</span><span class='line'>  <span class="l-Scalar-Plain">objectSelector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">matchLabels</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">foo</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">bar</span>
</span><span class='line'>  <span class="l-Scalar-Plain">rules</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">operations</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;CREATE&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">apiGroups</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;*&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">apiVersions</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;*&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">resources</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;*&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">scope</span><span class="p-Indicator">:</span> <span class="s">&quot;*&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>namespaceSelector</h3>

<p><code>namespaceSelector</code> 通过判断资源所在 namespace 的 labels 中是否包含指定的 laable 来对 namespaced 资源或者 Namespace 类型的资源进行筛选。如果要检查的对象类型就是 Namespace ，则会对其 <code>object.metadata.labels</code> 进行判断。</p>

<p><code>namespaceSelector</code> 对集群级别的资源无效。</p>

<p>这个例子显示的是一个 validating 类型的 webhook ，将会匹配到 namespaced 资源的 CREATR 请求中，<code>environment</code> 被设置为 &ldquo;prod&rdquo; 或 &ldquo;staging&rdquo; 的资源：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">admissionregistration.k8s.io/v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ValidatingWebhookConfiguration</span>
</span><span class='line'><span class="nn">...</span>
</span><span class='line'><span class="l-Scalar-Plain">webhooks</span><span class="p-Indicator">:</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-webhook.example.com</span>
</span><span class='line'>  <span class="l-Scalar-Plain">namespaceSelector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">matchExpressions</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">key</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">environment</span>
</span><span class='line'>      <span class="l-Scalar-Plain">operator</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">In</span>
</span><span class='line'>      <span class="l-Scalar-Plain">values</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;prod&quot;</span><span class="p-Indicator">,</span><span class="s">&quot;staging&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>  <span class="l-Scalar-Plain">rules</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">operations</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;CREATE&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">apiGroups</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;*&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">apiVersions</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;*&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">resources</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;*&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">scope</span><span class="p-Indicator">:</span> <span class="s">&quot;Namespaced&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>指定 webhook 连接方式。</h2>

<p>有两种连接设置方式，告诉 API server 如何找到 webhook 的地址，一种是直接使用 URL 指定，另一种方式是使用 K8s 的 service 资源。</p>

<h3>URL 方式</h3>

<p>这种方式只需要指定一个 <code>scheme://host:port/path</code> 格式的网址，比较简单直接，比如可以用于指定一个 K8s 之外的服务地址。</p>

<p>有一个限制，就是 <code>scheme</code> 必须是 <code>https</code> ，也就是说你可能在部署的时候会遇到证书认证的问题，关于如何创建证书，特别是自签名的证书，这里就不作说明了。</p>

<p>同时这种方式有一个限制，就是不支持 <code>user@pass</code> 这样的 basic 认证，也不支持在 URL 中使用 <code>?</code> 或 <code>#</code> 这两个 href 中具特殊意义的分隔符。</p>

<p>示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">admissionregistration.k8s.io/v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">MutatingWebhookConfiguration</span>
</span><span class='line'><span class="l-Scalar-Plain">webhooks</span><span class="p-Indicator">:</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-webhook.example.com</span>
</span><span class='line'>  <span class="l-Scalar-Plain">clientConfig</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">url</span><span class="p-Indicator">:</span> <span class="s">&quot;https://my-webhook.example.com:9443/my-webhook-path&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>service 引用</h3>

<p>如果 webhook 运行在集群中，则通过 service 来指定 webhook 的地址会比较方便。Service 的 <code>namespace</code> 和 <code>name</code> 都是必须的， <code>port</code> 不是必须的，有一个默认值 443 ，因为要走 <code>https</code> 协议。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">admissionregistration.k8s.io/v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">MutatingWebhookConfiguration</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">webhooks</span><span class="p-Indicator">:</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-webhook.example.com</span>
</span><span class='line'>  <span class="l-Scalar-Plain">clientConfig</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">caBundle</span><span class="p-Indicator">:</span> <span class="s">&quot;Ci0tLS0tQk...&lt;base64-encoded</span><span class="nv"> </span><span class="s">PEM</span><span class="nv"> </span><span class="s">bundle</span><span class="nv"> </span><span class="s">containing</span><span class="nv"> </span><span class="s">the</span><span class="nv"> </span><span class="s">CA</span><span class="nv"> </span><span class="s">that</span><span class="nv"> </span><span class="s">signed</span><span class="nv"> </span><span class="s">the</span><span class="nv"> </span><span class="s">webhook&#39;s</span><span class="nv"> </span><span class="s">serving</span><span class="nv"> </span><span class="s">certificate&gt;...tLS0K&quot;</span>
</span><span class='line'>    <span class="l-Scalar-Plain">service</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">namespace</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-service-namespace</span>
</span><span class='line'>      <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-service-name</span>
</span><span class='line'>      <span class="l-Scalar-Plain">path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/my-path</span>
</span><span class='line'>      <span class="l-Scalar-Plain">port</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1234</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：这时候 ca 证书签署时 server 名必须为 <code>&lt;svc_name&gt;.&lt;svc_namespace&gt;.svc</code> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash 常用 if 判断条件]]></title>
    <link href="http://liubin.org/blog/2021/01/05/shell-test-command/"/>
    <updated>2021-01-05T11:47:07+08:00</updated>
    <id>http://liubin.org/blog/2021/01/05/shell-test-command</id>
    <content type="html"><![CDATA[<p>作为一个运维，Shell 技能是必不可少的，只是 Shell 语法确实有些古怪，经常要查文档或者参考之前的代码。</p>

<h2>数值比较</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if [ ${foo} -eq 0 ]; then</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq </td>
<td> 相等     </td>
<td> equal                </td>
</tr>
<tr>
<td>-ne </td>
<td> 不相等 </td>
<td> not equal            </td>
</tr>
<tr>
<td>-lt </td>
<td> 小于     </td>
<td> less than            </td>
</tr>
<tr>
<td>-le </td>
<td> 小于等于       </td>
<td> less than or equal   </td>
</tr>
<tr>
<td>-gt </td>
<td> 大于     </td>
<td> greater than         </td>
</tr>
<tr>
<td>-ge </td>
<td> 大于等于       </td>
<td> greater than or equal</td>
</tr>
</tbody>
</table>


<h2>字符串比较</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if [ "${foo}" = "bar" ]; then</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=  </td>
<td> 相等 </td>
</tr>
<tr>
<td>!= </td>
<td> 不相等 </td>
</tr>
</tbody>
</table>


<h2>字符串长度的比较</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  if [ -z ${foor} ]; then</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-z </td>
<td> 长度为 0    </td>
</tr>
<tr>
<td>-n </td>
<td> 长度大于 0 </td>
</tr>
</tbody>
</table>


<h2>文件、文件夹判断</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if [ -d ${foo} ]; then</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d </td>
<td> 如果是文件夹则返回true        </td>
</tr>
<tr>
<td>-f </td>
<td> 是否为普通文件        </td>
</tr>
<tr>
<td>-s </td>
<td> 文件大小是否大于 0  </td>
</tr>
<tr>
<td>-e </td>
<td> 存在           </td>
</tr>
<tr>
<td>-r </td>
<td> 文件可读         </td>
</tr>
<tr>
<td>-w </td>
<td> 文件可写        </td>
</tr>
<tr>
<td>-x </td>
<td> 可执行文件        </td>
</tr>
</tbody>
</table>


<p>最后更新： 2020-1-5</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I'm back]]></title>
    <link href="http://liubin.org/blog/2020/12/17/im-back/"/>
    <updated>2020-12-17T12:32:17+08:00</updated>
    <id>http://liubin.org/blog/2020/12/17/im-back</id>
    <content type="html"><![CDATA[<p>在 2020 年底，终于又想起了还有这么个页面，上次更新还是在 2018 年，2019 一年空白，不知道 2021 能记录多少。</p>

<p>主页用的是 Octopress ，但是最近换了台机器，重新 clone blog 的 repo，结果并不能像原来那样直接就发布了。关键问题在 <code>_deploy</code> 文件夹，这里面是 repo 的 master 分支，所以必须要和 repo 同步才行。</p>

<h2>Clone 代码并安装需要的软件</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git clone git@github.com:liubin/liubin.github.io.git blog
</span><span class='line'><span class="nv">$ </span><span class="nb">cd </span>blog/
</span><span class='line'><span class="nv">$ </span>git co <span class="nb">source</span>
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>sudo gem install octopress
</span><span class='line'><span class="nv">$ </span>bundle
</span></code></pre></td></tr></table></div></figure>


<h2>初始化 <code>_deploy</code> 目录</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git clone git@github.com:liubin/liubin.github.io.git _deploy
</span></code></pre></td></tr></table></div></figure>


<h2>创建新页面</h2>

<p>创建新页面并编辑：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>bundle <span class="nb">exec </span>rake new_post<span class="o">[</span><span class="s2">&quot;I&#39;m back&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>编辑并预览：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>bundle <span class="nb">exec </span>rake preview
</span></code></pre></td></tr></table></div></figure>


<p>发布：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>bundle <span class="nb">exec </span>rake generate
</span><span class='line'><span class="nv">$ </span>bundle <span class="nb">exec </span>rake deploy
</span></code></pre></td></tr></table></div></figure>


<p>最后别忘了提交到 <code>source</code> 分支：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git status
</span><span class='line'><span class="nv">$ </span>git add .
</span><span class='line'><span class="nv">$ </span>git commit -m <span class="s2">&quot;some message&quot;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[世界是 container 的，也是 microservice 的，但最终还是 serverless 的]]></title>
    <link href="http://liubin.org/blog/2018/05/04/the-world-is-full-managed/"/>
    <updated>2018-05-04T07:53:41+08:00</updated>
    <id>http://liubin.org/blog/2018/05/04/the-world-is-full-managed</id>
    <content type="html"><![CDATA[<p>副标题是这样的： “Hyper，Fargate，以及 Serverless infrastructure”。</p>

<p>世界上有两种基础设施，一种是拿来主义，另一种是自主可控。</p>

<p>原谅我也蹭个已经被浇灭的、没怎么火起来的热点。不过我们喜欢的是拿来主义，<strong>够用就行，不想也不需要过多的控制，也不想惹过多的麻烦</strong>，也就是 fully managed。</p>

<p>之所以想到写这篇文章，源于前几天看到的这篇来自微软 Azure 的博客内容： <a href="https://thenewstack.io/the-future-of-Kubernetes-is-serverless/">The Future of Kubernetes Is Serverless</a> ，然后又顺手温习了一遍 AWS CTO 所撰写的 <a href="https://www.allthingsdistributed.com/2018/04/changing-calculus-containers-cloud.html">Changing the calculus of containers in the cloud</a> 这篇文章。这两篇文章你觉得有可能有广告的嫌疑，都是在推销自家的共有云服务，但是仔细品味每一句话，我却觉得几乎没有几句废话，都很说到点子上，你可以点击进去看下原文。</p>

<p>有个前提需要说明的是，这里的 Serverless 指的是 Serverless infrastructure，而不是我们常听到的 AWS Lambda，Microsoft Azure Functions 或 Google Cloud Functions 等函数（功能）即服务（FaaS）技术，为了便于区分，我们将这些 FaaS 称为无服务器计算，和我们本文要介绍的无服务器基础设施还是不一样的。</p>

<h2>IaaS：变革的开始</h2>

<p>说到基础设施，首先来介绍下最先出现的 IaaS，即基础设施即服务。IaaS 免除了大部分硬件的 provision 工作，没人再关心机架、电源和服务器问题，使得运维工作更快捷，更轻松，感觉解放了很多人，让大家走上了富裕之路。</p>

<p>当然这一代的云计算服务，可不只是可以几分钟启动一台虚拟机那么简单。</p>

<p>除了 VM 之外， IaaS 厂商还提供了很多其他基础设施和中间件服务，这些组件被称为 building block ，比如网络和防火墙、数据库、缓存等老三样，最近还出现了非常多非常多的业务场景服务，大数据、机器学习和算法，以及IoT等，看起来就像个百货商店，使用云计算就像购物，架构设计就是购物清单，架构里的组件都可以在商店里买到。</p>

<p>基础设施则使用 IaaS 服务商所提供的各种服务，编写应用程序可以更专注于业务。这能带来很多好处：</p>

<ul>
<li>将精力集中投入到核心业务</li>
<li>加快上线速度</li>
<li>提高可用性</li>
<li>快速扩缩容</li>
<li>不必关心中间件的底层基础设施</li>
<li>免去繁杂的安装、配置、备份和安全管理等运维工作</li>
</ul>


<p>在 AWS 成为业界标准之后，各大软件公司，不管是新兴的还是老牌的，都开始着手打造自己的云，国外有微软、谷歌、IBM等，国内的 BAT 也都有自己的云，以及京东和美团这样的电商类公司也有自己的云产品，独立的厂商类似 UCloud 和青云等公司也发展的不错，甚至有开饭馆的也要出来凑热闹。而开源软件 OpenStack 和基于 OS 的创业公司和产品也层出不穷。</p>

<p>全民皆云。</p>

<h2>容器：云计算的深入人心</h2>

<p>之后在 2013 年，容器技术开始面向大众普及了。在 LXC 之前，容器对普通开发人员甚至 IT 业者来说几乎不是同一个维度的术语，那是些专业人员才能掌控的晦涩的术语和繁杂的命令集，大部分人都没有用过容器技术；但是随着 Docker 的出现，容器技术的门槛降低，也在软件行业变得普及。随着几年的发展，基本可以说容器技术已经非常成熟，已成为了开发的标配。</p>

<p>随着容器技术的成熟和普及，应用程序架构也出现了新的变化，可以说软件和基础设施的进化相辅相成。人们越来越多的认识到对技术栈的分层和解耦更加重要，不同层之间的技术和责任、所有权等界限清晰明了，这也和软件设计中的模块松耦合原则很相像。</p>

<p>在有了责权明晰的分层结构之后，每个人可以更容易集中在自己所关注的重点上。开发人员更关注应用程序本身了，在 Docker 火了的同时，也出现了 app-centric 的概念。甚至 CoreOS 还将自己对抗 OCI/runc 的标准称为 appc 。当然现在的 Docker 也不是原来的 Docker ，也是一个组件化的东西，很多组件，尤其是 runtime ，都可以替换为其他运行时。</p>

<p>和以应用程序为重心相对应的是传统的以基础设施为中心，即先有基础设施，围绕基础设施做架构设计和开发、部署，受基础设施的限制较多。而随着 IaaS 等服务的兴起，基础设施越来越简单，越来越多容易入手，而且还提供了编程化的接口，开发人员也可以非常方便的对基础设施进行管理，可以说云计算的出现也使得开发人员抢了一部分运维人员的饭碗（遗憾的是这种趋势太 high 了停不下来。。。）。</p>

<p>当然，现在以应用为中心这一概念也已经深入人心。特别是进化到极致的 FaaS ，自己只需要写几行代码，其他平台全给搞定了。</p>

<h2>编排：兵家必争之地</h2>

<p>容器解决了代码的可移植性的问题，也使得在云计算中出现新的基础设施应用模式成为可能。使用一个一致的、不可变的部署制品，比如镜像，可以让我们从复杂的服务器部署中解脱出来，也可以非常方便的部署到不同的运行环境中（可移植性）。</p>

<p>但是容器的出现也增加了新的工作内容，要想使用容器运行我们的代码，就需要一套容器管理系统，在我们编写完代码，打包到容器之后，需要选择合适的运行环境，设置好正确的扩容配置，相关的网络连接，安全策略和访问控制，以及监控、日志和分布式追踪系统。</p>

<p>之所以出现编排系统，就是因为一台机器已经不够用了，我们要准备很多机器，在上面跑容器，而且我不关心容器跑在哪台机器上，这个交给调度系统就行了。可以说，从一定层面上，编排系统逐渐淡化了主机这一概念，我们面对的是一个资源池，是一组机器，有多少个 CPU 和多少的内存等计算资源可用。</p>

<p>rkt vs Docker 的战争从开始其实就可以预料到结局，但在编排系统/集群管理上，这场“战争”则有着更多的不确定性。</p>

<p>Mesos（DC/OS）出来的最早，还有 Twitter 等公司做案例，也是早期容器调度系统的标配；Swarm 借助其根正苗红以及简单性、和 Docker 的亲和性，也要争一分地盘；不过现在看来赢家应该是 K8s，K8s 有 Google 做靠山，有 Google 多年调度的经验，加上 RedHat/CoreOS 这些反 Docker 公司的站队，社区又做得红红火火，总之是赢了。</p>

<p>据说今年在哥本哈根举办的 Kubecon 有 4300 人参加。不过当初 Dockercon 也是这声势，而现在影响力已经没那么大了，有种昨日黄花、人老色衰的感觉，不知道几年之后的 Kubernetes 将来会如何，是否会出现新的产品或服务来撼动 Kubernetes 现在的地位？虽然不一定，但是我们期待啊。</p>

<h2>Serverless infrastructure：进化的结果</h2>

<p>但是呢，淡化主机的存在性也只是淡化而已，并没有完全消除主机的概念，只是我们直接面向主机的机会降低了，不再直接面向主机进行部署，也不会为某些部门分配独占的主机等。主机出了问题还得重启，资源不够了还得添加新的主机，管理工作并没有完全消失。</p>

<p>但是管理一套集群带来了很大的复杂性，这也和使用云计算的初衷相反，更称不上云原生。</p>

<p>从用户的角度再次审视一下，可以发现一个长时间被我们忽略的问题：为什么只是想运行容器，非得先买一台 VM 装好 Docker，或者自己搭建一套 Kubernetes 集群，或者使用类似 EKS 这样的服务，乐此不疲的进行各种配置和调试，不仅花费固定的资产费，还增加了很多并没有任何价值的运维管理工作。</p>

<p>既然我们嫌弃手动在多台主机中部署容器过于麻烦，将其交给集群管理和调度系统去做，那么维护调度系统同样繁杂的工作，是不是也可以交给别人来做，外包出去呢？</p>

<p>按照精益思想，这些和核心业务目标无关，不能带来任何用户价值的过程，都属于浪费行为，都需要提出。</p>

<p>这时候，出现了 Serverless infrastructure 服务，最早的比如国内的 <a href="https://hyper.sh/">hyper.sh</a> （2016.8 GA），以及去年发布的 AWS 的 Fargate（2017.12），微软的 ACI（Azure Container Instance，2017.7） 等。</p>

<p>以 hyper.sh 为例，使用起来和 Docker 非常类似，可以将本地的 Docker 体验原封不动的搬到云端：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install hyper 
</span><span class='line'>$ hyper pull mysql 
</span><span class='line'>$ hyper run mysql 
</span><span class='line'>MySQL is running... 
</span><span class='line'>$ hyper run --link mysql wordpress 
</span><span class='line'>WordPress is running... 
</span><span class='line'>$ hyper fip attach 22.33.44.55 wordpress 
</span><span class='line'>22.33.44.55
</span><span class='line'>$ open 22.33.44.55</span></code></pre></td></tr></table></div></figure>


<p>大部分命令从 <code>docker</code> 换成 <code>hyper</code> 就可以了，体验如同使用 Docker 一模一样，第一次看到这样的应用给人的新奇感，并不亚于当初的 Docker 。</p>

<p>使用 Serverless infrastructure，我们可以再不必为如下事情烦恼：</p>

<ul>
<li>不必再去费心选择 VM 实例的类型，需要多少 CPU 和内存</li>
<li>不必再担心使用什么版本的 Docker 和集群管理软件</li>
<li>不必担心 VM 内中间件的安全漏洞</li>
<li>不必担心集群资源利用率太低</li>
<li>从为资源池付费变为为运行中的容器付费</li>
<li>完全不可变基础设施</li>
<li>不用因为 ps 时看到各种无聊的 agent 而心理膈应</li>
</ul>


<p>我们需要做的就是安心写自己的业务应用，构建自己的镜像，选择合适的容器大小，付钱给 cloud 厂商，让他们把系统做好，股票涨高高。</p>

<h2>Fargate（此处也可以换做 ACI ）：大厂表态</h2>

<p>尽管 AWS 不像 GCP 那样“热衷”于容器，但是 AWS 也还是早就提供了 ECS（Elastic Container Service）服务。</p>

<p>去年发布的 AWS Fargate 则是个无服务器的容器服务，Fargate 是为了实现 AWS 的容器服务，比如 ECS（Elastic Container Service） 和 EKS（Elastic Kubernetes Service） 等，将容器运行所需要的基础设施进行抽象化的技术，并且现在 ECS 已经可以直接使用 Fargate。</p>

<p>和提供虚拟机的 EC2 不同，Fargate 提供的是容器运行实例，用户以容器作为基本的运算单位，而不必担心底层主机实例的管理，用户只需建立容器镜像，指定所需要的 CPU 和内存大小，设置相应的网络和IAM（身分管理）策略即可。</p>

<p>对于前面我们的疑问，AWS 的答案是基础设施的坑我们来填，你们只需要专心写好自己的应用程序就行了，你不必担心启动多少资源，我们来帮你进行容量管理，你只需要为你的使用付费就行了。</p>

<p>可以说 Fargate 和 Lambda 等产品都诞生于此哲学之下。</p>

<p>终于可以专心编写自己最擅长的 CRUD 了，happy，happy。</p>

<h2>Serverless infrastructure vs Serverless compute</h2>

<p>再多说几句，主要是为了帮助大家辨别两种不同的无服务器架构：无服务器计算和无服务器基础设施。</p>

<p>说实话一下子从 EC2 迁移到 Lambda ，这步子确实有点大。</p>

<p>Lambda 等 FaaS 产品虽然更加简单，但是存在有如下很多缺点：</p>

<ul>
<li>使用场景：Lambda 更适合用户操作或事件驱动，不适合做守护服务、批处理等业务</li>
<li>灵活性：固定的内核、AMI等，无法定制</li>
<li>资源限制：文件系统、内存、进程线程数、请求 body 大小以及执行时间等很多限制</li>
<li>编程语言限制</li>
<li>很难做服务治理</li>
<li>不方便调试和测试</li>
</ul>


<p>Lambda 和容器相比最大的优势就是运维工作更少，基本没有，而且计费更精确，不需要为浪费的计算资源买单，而且 Lambda 响应更快，扩容效率会高一些。</p>

<p>可以认为 Fargate 等容器实例，就是结合了 EC2 实例和 Lambda 优点的产品，既像 Lambda 一样轻量，更关注核心的应用程序，还能像 EC2 一样带来很大的灵活性和可控性。</p>

<p>云原生会给用户更多的控制，但是需要用户更少的投入和负担。</p>

<p>Serverless infrastructure 可以让容器更加 cloud native。</p>

<h2>fully managed：大势所趋</h2>

<p>所谓的 fully managed，可以理解为用户花费很少的成本，就可以获得想要的产品、服务并可以进行相应的控制。</p>

<p>这两天，阿里云发布了 Serverless Kubernetes ，Serverless Kubernetes 与原生的 Kubernetes 完全兼容，可以采用标准的 API、CLI 来部署和管理应用，还可以继续使用各种传统资产，并且还能获得企业级的高可用和安全性保障。难道以后我们连 Kubernetes 也不用自己装了，大部分人只需要掌握 kubectl 命令就好了。</p>

<p>IaaS 的出现，让我们丢弃了各种 provision 工具，同时，各种 configuration management 工具如雨后春笋般的出现和普及；容器的出现，又让我们扔掉了刚买还没看几页的各种 Chef/Puppet 入门/圣经，匆忙学起 Kubernetes；有了 Serverless infrastructure，也差不多可以和各种编排工具说拜拜了。</p>

<p>不管你们是在单体转微服务，还是在传统上云、转容器，估计大家都会喜欢上 fully managed 的服务，人人都做 Ops，很多运维工作都可以共同分担。当然，也会有一部分运维工程师掩面而逃。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google 发布 gVisor - 容器沙箱运行时（sandboxed container runtime）]]></title>
    <link href="http://liubin.org/blog/2018/05/02/gvisor/"/>
    <updated>2018-05-02T07:53:41+08:00</updated>
    <id>http://liubin.org/blog/2018/05/02/gvisor</id>
    <content type="html"><![CDATA[<p>这是来自官方博客 <a href="https://cloudplatform.googleblog.com/2018/05/Open-sourcing-gVisor-a-sandboxed-container-runtime.html">Open-sourcing gVisor, a sandboxed container runtime</a> 的摘要及翻译。</p>

<p>自 Docker 的普及开始，我们开发、打包和部署应用的方式发生了根本性的变化，但是由于容器的隔离技术所限，并不是所有的人都推崇使用容器技术，因为其共享内核机制，系统还存在很大的攻击面，这就会存在恶意应用程序侵入系统的威胁。</p>

<p>为了运行那些不可信以及存在潜在威胁的容器，人们开始更加重视沙箱容器：一种能在宿主机和应用程序之间提供更安全的隔离机制。</p>

<p>Google 发布的 gVisor ，就是这样一种新型的沙箱容器技术，它能为容器提供更安全的隔离，同时比虚拟机（VM）更轻量。 而且，gVisor 还能和 Docker 以及 Kubernetes 集成在一起，使得在生产环境中运行沙箱容器更简单。</p>

<h2>传统的 Linux 容器并非沙箱</h2>

<p>传统 Linux 容器中运行的应用程序与常规（非容器化）应用程序以相同的方式访问系统资源：直接对主机内核进行系统调用。内核以特权模式运行，允许它与必要的硬件交互并将结果返回给应用程序。</p>

<p><img src="http://ourcolorfuldays.com/wp-content/uploads/2018/04/traditional-linux-containers-gvisor.png" alt="" /></p>

<p>在传统的容器技术中，内核会对应用程序需要访问的资源施加一些限制。这些限制通过使用 Linux 的 cgroups 和命名空间技术来实现，然而并非所有的资源都可以通过这些机制来进行控制。此外，即使使用这些限制，内核仍然面向恶意程序暴露出过多的攻击面。</p>

<p>像 seccomp 这样的技术可以在应用程序和主机内核之间提供更好的隔离，但是它们要求用户创建预定义的系统调用白名单。在实际中，很难事先罗列出应用程序所需要的所有系统调用。如果你需要调用的系统调用存在漏洞，那么这类过滤器也很难发挥作用。</p>

<h2>已有基于 VM 的容器技术</h2>

<p>提高容器隔离性的一种方法是将容器运行在其自己的虚拟机（VM）之内。也就是为每个容器提供自己专用的“机器”，包括内核和虚拟化设备，并与主机完全分离。即使 guest 虚拟机存在漏洞，管理程序（ hypervisor ）仍会隔离主机以及主机上运行的其他应用程序/容器。</p>

<p><img src="http://ourcolorfuldays.com/wp-content/uploads/2018/04/vm-based-container-technology-gvisor-300x272.png" alt="" /></p>

<p>在不同的 VM 中运行容器提供了很好的隔离性、兼容性和性能，但也可能需要更大的资源占用。</p>

<p>Kata containers 是一个开源项目，它使用精简的虚拟机来尽量减少资源的占用，并最大限度地提高隔离容器的性能。与 gVisor 一样，Kata 也包含与 Docker 和 Kubernetes 兼容的 OCI （Open Container Initiative ）运行时。</p>

<h2>基于 gVisor 的沙箱容器（ Sandboxed containers ）</h2>

<p>gVisor 比 VM 更轻量，同时具备相同的隔离级别。 gVisor 的核心是一个以普通非特权进程方式运行的内核，它支持大多数 Linux 系统调用。这个内核是用 Go 编写的，选择 Go 语言是由于其较小的内存占用以及类型安全等特性。和虚拟机一样，在 gVisor 沙箱中运行的应用程序也可以拥有独立于主机和其他沙箱、自己独自的内核和一组虚拟设备。</p>

<p><img src="http://ourcolorfuldays.com/wp-content/uploads/2018/04/gvisor-sandbox-containers-300x184.png" alt="" /></p>

<p>gVisor 通过拦截应用程序的系统调用，并充当 guest 内核，提供了非常强的隔离性，而所有的这些都运行在用户空间。和虚拟机在创建时需要一定的资源不同，gVisor 可以像普通 Linux 进程一样，随时调整自己的资源使用。可以将 gVisor 看做是一个完全虚拟化的操作系统，但是与完整的虚拟机相比，它具有灵活的资源占用和更低的固定成本。</p>

<p>但是，这种灵活性的代价是单个系统调用的消耗、应用程序的兼容性（和系统调用相关）以及其他问题。</p>

<p>“安全工作负载（workloads）是业界的首要任务，我们很高兴看到像 gVisor 这样的创新，并期待在规范方面进行合作，并对相关技术组件进行改进，从而为生态系统带来更大的安全性。”</p>

<ul>
<li>Samuel Ortiz，Kata 技术指导委员会成员，英特尔公司首席工程师</li>
</ul>


<p>“Hyper 非常高兴看到 gVisor 这样全新的提高容器隔离性的方法。行业需要一个强大的安全容器技术生态系统，我们期待通过与 gVisor 的合作让安全容器成为主流。“</p>

<ul>
<li>Xu Wang，Kata 技术指导委员会成员，Hyper.sh CTO</li>
</ul>


<h2>和 Docker、Kubernetes 集成</h2>

<p>gVisor 运行时可以通过 <code>runsc</code>（run Sandboxed Container） 和 Docker 以及 Kubernetes 进行无缝集成。</p>

<p>runsc 运行时与 Docker 的默认容器运行时 runc 可以互换。runsc 的安装很简单，一旦安装完成，只需要在运行 docker 的时候增加一个参数就可以使用沙箱容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker run --runtime=runsc hello-world
</span><span class='line'>$ docker run --runtime=runsc -p 3306:3306 mysql</span></code></pre></td></tr></table></div></figure>


<p>在 Kubernetes 中，大多数资源隔离都以 Pod 为单位，因此 Pod 也自然成为了 gVisor 沙箱的边界（boundary）。Kubernetes 社区目前正在致力于实现沙箱 Pod API，但是今天 gVisor 沙箱已经可以在实验版中（experimental support）可用。</p>

<p>runsc 运行时可以通过 cri-o 或 cri-containerd 等项目来在 Kubernetes 群集中使用沙箱技术，这些项目会将 Kubelet 中的消息转换为 OCI 运行时命令。</p>

<p>gVisor 实现了大部分 Linux 系统 API （ 200 个系统调用，并且还在增加中），但并不是所有的系统调用。目前有一些系统调用和参数还没有支持，以及 /proc 和 /sys 文件系统的一些部分内容。因此，并不是说所有的应用程序都可以在 gVisor 中正常运行，但大部分应用程序应该都可以正常运行，包括 Node.js、Java 8、MySQL、Jenkins、Apache、Redis 和 MongoDB 等等。</p>

<p>gVisor 已经开源，可以在 <a href="https://github.com/google/gvisor">https://github.com/google/gvisor</a> 查看到其内容，相信这里将会是大家了解 gVisor 最好的开始。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向 Kubernetes 学习 - Controller manager 的高可用实现方式]]></title>
    <link href="http://liubin.org/blog/2018/04/28/how-to-build-controller-manager-high-available/"/>
    <updated>2018-04-28T19:04:56+08:00</updated>
    <id>http://liubin.org/blog/2018/04/28/how-to-build-controller-manager-high-available</id>
    <content type="html"><![CDATA[<p>这不是一系列入门级别的文章，也不是按部就班而来的，而是我看到哪里，发现有些代码写的精妙的地方，都值得我们学习下，顺手记录下来，一方面是让自己将来可以有迹可循，另外对大家应该也会有所帮助。而且记录本身成本并不是很高。</p>

<p>高可用部署情况下，需要部署多个controller manager （以下简称 cm ），每个 cm 需要 <code>--leader-elect=true</code> 启动参数，即告知 cm 以高可用方式启动，谁要想进行真正的工作，必须先抢到锁，被选举为 leader 才行，而抢不到所得只能待机，在 leader 因为异常终止的时候，由剩余的其余节点再次获得锁。</p>

<p>关于分布式锁的实现很多，可以自己从零开始制造。当然更简单的是基于现有中间件，比如有基于 Redis 或数据库的实现方式，最近 Zookeeper/ETCD 也提供了相关功能。但 K8s 的实现并没有使用这些方式，而是另辟蹊径使用了资源锁的概念，简单来说就是通过创建 K8s 的资源（当前的实现中实现了 ConfigMap 和 Endpoint 两种类型的资源）来维护锁的状态。</p>

<p>分布式锁一般实现原理就是大家先去抢锁，抢到的人成为 leader ，然后 leader 会定期更新锁的状态，声明自己的活动状态，不让其他人把锁抢走。K8s 的资源锁也类似，抢到锁的节点会将自己的标记（目前是hostname）设为锁的持有者，其他人则需要通过对比锁的更新时间和持有者来判断自己是否能成为新的 leader ，而 leader 则可以通过更新 <code>RenewTime</code> 来确保持续保有该锁。</p>

<p>大概看了下 K8s 的实现，老实说其实现方式并不算高雅，但是却给我们开拓了一种思路：K8s 里的 resource 是万能的，不要以为 Endpoint 只是 Endpoint 。不过反过来有时候也挺让人费解的，刚了解的时候容易摸不着头脑，也不是好事。而且 scheduler 和 cm 都采用了资源锁，但是实现起来却不尽相同，也值得吐槽下。不管怎么说，这个实现算是挺有意思的实现，值得我们深入了解下。</p>

<p>我们首先来看一下 cm 启动的时候，是如何去 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/cmd/kube-controller-manager/app/controllermanager.go#L184-L208">初始化</a> 抢锁的。启动的时候，如果指定了 <code>--leader-elect=true</code> 参数的话，则会进入下面的代码，首先获取自己的资源标志（这里是 hostname 加一串随机数字）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Hostname</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// add a uniquifier so that two processes on the same host don&#39;t accidentally both become active</span>
</span><span class='line'><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">uuid</span><span class="p">.</span><span class="nx">NewUUID</span><span class="p">())</span>
</span><span class='line'><span class="nx">rl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">resourcelock</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">ResourceLock</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&quot;kube-system&quot;</span><span class="p">,</span>                                 <span class="c1">// 该资源所在 Namespace</span>
</span><span class='line'>  <span class="s">&quot;kube-controller-manager&quot;</span><span class="p">,</span>                     <span class="c1">// 资源名称</span>
</span><span class='line'>  <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">LeaderElectionClient</span><span class="p">.</span><span class="nx">CoreV1</span><span class="p">(),</span>
</span><span class='line'>  <span class="nx">resourcelock</span><span class="p">.</span><span class="nx">ResourceLockConfig</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">Identity</span><span class="p">:</span>      <span class="nx">id</span><span class="p">,</span>                         <span class="c1">// 锁持有者标志</span>
</span><span class='line'>      <span class="nx">EventRecorder</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">EventRecorder</span><span class="p">,</span>
</span><span class='line'>  <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面创建资源锁的代码说明请参考文中中文注释。</p>

<p>之后，在下面的代码中，资源锁，即上面的 rl（resource lock） 变量，被用于进行 leader 选举。具体的说明也嵌入在了下面的代码中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">leaderelection</span><span class="p">.</span><span class="nx">RunOrDie</span><span class="p">(</span><span class="nx">leaderelection</span><span class="p">.</span><span class="nx">LeaderElectionConfig</span><span class="p">{</span>
</span><span class='line'>  <span class="nx">Lock</span><span class="p">:</span>          <span class="nx">rl</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">// 下面 3 个参数是一些重时间，租赁期间等的设置，不是很重要</span>
</span><span class='line'>  <span class="nx">LeaseDuration</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">LeaseDuration</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">RenewDeadline</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">RenewDeadline</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">RetryPeriod</span><span class="p">:</span>   <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">RetryPeriod</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">Callbacks</span><span class="p">:</span> <span class="nx">leaderelection</span><span class="p">.</span><span class="nx">LeaderCallbacks</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">OnStartedLeading</span><span class="p">:</span> <span class="nx">run</span><span class="p">,</span>                   <span class="c1">// cm 的主要工作函数</span>
</span><span class='line'>      <span class="nx">OnStoppedLeading</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;leaderelection lost&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们再来看看 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L85-L103">LeaderElectionConfig</a> 的内容，说明见注释（其实就是将代码的英文翻译过来而已）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">type</span> <span class="nx">LeaderElectionConfig</span> <span class="kd">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 资源锁的实现对象</span>
</span><span class='line'>  <span class="nx">Lock</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">Interface</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 是非 leader 在获取锁之前需要检查 leader 过期的时间</span>
</span><span class='line'>  <span class="nx">LeaseDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 当前 leader 尝试更新锁状态的期限。</span>
</span><span class='line'>  <span class="nx">RenewDeadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 抢锁时尝试间隔</span>
</span><span class='line'>  <span class="nx">RetryPeriod</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 锁状态发生变化的时候，需要进行处理的一组回调函数</span>
</span><span class='line'>  <span class="nx">Callbacks</span> <span class="nx">LeaderCallbacks</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L110-L119">Callbacks</a> 具体如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">Callbacks</span><span class="p">:</span> <span class="nx">leaderelection</span><span class="p">.</span><span class="nx">LeaderCallbacks</span><span class="p">{</span>
</span><span class='line'>  <span class="nx">OnStartedLeading</span><span class="p">:</span> <span class="nx">run</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">OnStoppedLeading</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;leaderelection lost&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">},</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，在获取锁（成为leader，<code>OnStartedLeading</code>）之后，将会执行 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/cmd/kube-controller-manager/app/controllermanager.go#L137"><code>run</code></a> 方法，在失去锁（<code>OnStoppedLeading</code>）之后打印错误消息后退出。<code>run</code> 方法是 cm 的主要方法，和抢锁选主流程没什么关系，这里就不介绍了。</p>

<p>下面的 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go#L37-L43">LeaderElectionRecord</a> 结构，保存了锁的信息，包括持有者（的hostname），获取时间，更新时间，leader 切换次数等（<code>LeaseDurationSeconds</code> 虽然定义了，但是并没有使用的感觉）。</p>

<p>这个结构可以说是资源锁中最重要的信息了，大家一定先混个脸熟，多念几遍 struct 的名字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// LeaderElectionRecord is the record that is stored in the leader election annotation.</span>
</span><span class='line'><span class="c1">// This information should be used for observational purposes only and could be replaced</span>
</span><span class='line'><span class="c1">// with a random string (e.g. UUID) with only slight modification of this code.</span>
</span><span class='line'><span class="kd">type</span> <span class="nx">LeaderElectionRecord</span> <span class="kd">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">HolderIdentity</span>       <span class="kt">string</span>      <span class="s">`json:&quot;holderIdentity&quot;`</span>
</span><span class='line'>  <span class="nx">LeaseDurationSeconds</span> <span class="kt">int</span>         <span class="s">`json:&quot;leaseDurationSeconds&quot;`</span>
</span><span class='line'>  <span class="nx">AcquireTime</span>          <span class="nx">metav1</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`json:&quot;acquireTime&quot;`</span>
</span><span class='line'>  <span class="nx">RenewTime</span>            <span class="nx">metav1</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`json:&quot;renewTime&quot;`</span>
</span><span class='line'>  <span class="nx">LeaderTransitions</span>    <span class="kt">int</span>         <span class="s">`json:&quot;leaderTransitions&quot;`</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个锁信息，就是存在 K8s 的 ConfigMap 或者 Endpoint 里面的，当然，存哪里可能大家已经想到了，只能存 annotation 里面，该 annotation 的 key 就是 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go#L28"><code>control-plane.alpha.kubernetes.io/leader</code></a> 。</p>

<p>到这里总结一下就是：LeaderElectionRecord 用于保存锁的信息，但是这一信息会以 annotation 的方式，保存到 k8s 的 ConfigMap 或者 Endpoint 等资源里面。</p>

<p>下面我们来看一下资源锁的实现。</p>

<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go#L57-L76">资源锁接口</a> 的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">Get</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">LeaderElectionRecord</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">Create</span><span class="p">(</span><span class="nx">ler</span> <span class="nx">LeaderElectionRecord</span><span class="p">)</span> <span class="kt">error</span>
</span><span class='line'>  <span class="nx">Update</span><span class="p">(</span><span class="nx">ler</span> <span class="nx">LeaderElectionRecord</span><span class="p">)</span> <span class="kt">error</span>
</span><span class='line'>  <span class="nx">RecordEvent</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">Identity</span><span class="p">()</span> <span class="kt">string</span>
</span><span class='line'>  <span class="nx">Describe</span><span class="p">()</span> <span class="kt">string</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>基本实现了 CRUD 几个方法，当然这里没有 D ，即 Delete，因为也没必要 Delete， 下一次抢锁的时候，抢到的 Leader 直接 Update 就可以了。</p>

<p>关键的方法我们看前 3 个就够了： Get 用于获取锁的最新信息，Update 用于更新，Create 用于创建资源锁对象，估计对大多数集群来说，只有第一次的时候才会调用 Create 创建这个对象。RecordEvent 也可以关注下，这个 event 属于锁资源，里面会记录 leader 切换等事件。</p>

<p>这里我们以 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/endpointslock.go#L39">Endpoint</a> 为例（这也是默认的资源锁类型，该参数可以通过 <code>leader-elect-resource-lock</code> 来设置），来看看资源锁的具体实现。</p>

<p>下面的代码省略了对 error 的检查，你懂得。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// Get returns the election record from a Endpoints Annotation</span>
</span><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">el</span> <span class="o">*</span><span class="nx">EndpointsLock</span><span class="p">)</span> <span class="nx">Get</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">LeaderElectionRecord</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">record</span> <span class="nx">LeaderElectionRecord</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span><span class='line'>  <span class="c1">// el.e 就是一个正经的 Endpoint 资源对象。</span>
</span><span class='line'>  <span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Client</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nx">Get</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">GetOptions</span><span class="p">{})</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 去获取 control-plane.alpha.kubernetes.io/leader annotation。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">recordBytes</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">Annotations</span><span class="p">[</span><span class="nx">LeaderElectionRecordAnnotationKey</span><span class="p">];</span> <span class="nx">found</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">recordBytes</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">record</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">record</span><span class="p">,</span> <span class="kc">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/endpointslock.go#L58">Create</a> 也很简单，就是一个普通的 Endpoint 对象，加上锁专用的 annotation ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Client</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nx">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">{</span>
</span><span class='line'>  <span class="nx">ObjectMeta</span><span class="p">:</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">ObjectMeta</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">Name</span><span class="p">:</span>      <span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">Namespace</span><span class="p">:</span> <span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">Annotations</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span><span class='line'>          <span class="nx">LeaderElectionRecordAnnotationKey</span><span class="p">:</span> <span class="nb">string</span><span class="p">(</span><span class="nx">recordBytes</span><span class="p">),</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/endpointslock.go#L76">更新方法</a> 的主体如下，将 <code>LeaderElectionRecord</code> 结构的对象序列化为字符串后，存到 annotation：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">Annotations</span><span class="p">[</span><span class="nx">LeaderElectionRecordAnnotationKey</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">recordBytes</span><span class="p">)</span>
</span><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Client</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nx">Update</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的方法，我们应该已经了解到了，锁的实现主要载体是 LeaderElectionRecord 对象，其实我们完全可以自己实现其他类型的资源锁了，比如基于 Secret ，不过好像也没啥意义。</p>

<p>介绍了上面的实现基础，我们最后来看看抢锁及使用锁的过程，<a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L138-L148">主要的入口</a> 如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// Run starts the leader election loop</span>
</span><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">Run</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 先去抢锁，阻塞操作</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">acquire</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span><span class='line'>  <span class="c1">// 抢到锁后，执行主函数，就是我们前面提到的 run 函数，通过 Callbacks.OnStartedLeading 回调启动</span>
</span><span class='line'>  <span class="k">go</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Callbacks</span><span class="p">.</span><span class="nx">OnStartedLeading</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">// 抢到锁后，需要定期更新，确保自己一直持有该锁</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">renew</span><span class="p">()</span>
</span><span class='line'>  <span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，里面主要调用了两个方法： <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L172-L187"><code>acquire</code></a> 和 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L190-L206"><code>renew</code></a> 。</p>

<p>我们先来看看 <code>acquire</code> 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">acquire</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span><span class='line'>  <span class="nx">wait</span><span class="p">.</span><span class="nx">JitterUntil</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">succeeded</span> <span class="o">:=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">tryAcquireOrRenew</span><span class="p">()</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">maybeReportTransition</span><span class="p">()</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">!</span><span class="nx">succeeded</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;failed to acquire lease %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">RecordEvent</span><span class="p">(</span><span class="s">&quot;became leader&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;successfully acquired lease %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
</span><span class='line'>      <span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="p">},</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">RetryPeriod</span><span class="p">,</span> <span class="nx">JitterFactor</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现也很短，这个函数会通过 <code>wait.JitterUntil</code> 来定期调用 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L211-L264"><code>tryAcquireOrRenew</code> 方法</a> 来获取锁，直到成功为止，如果获取不到锁，则会以 <code>RetryPeriod</code> 为间隔不断尝试。如果获取到锁，就会关闭 stop 通道（ <code>close(stop)</code> ），通知 <code>wait.JitterUntil</code> 停止尝试。<code>tryAcquireOrRenew</code> 是最核心的方法，我们会在介绍完 <code>renew</code> 方法之后再进行介绍。</p>

<p><code>renew</code> 只有在获取锁之后才会调用，它会通过持续更新资源锁的数据，来确保继续持有已获得的锁，保持自己的 leader 状态。这里还是用到了很多 <code>wait</code> 包里的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">renew</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span><span class='line'>  <span class="nx">wait</span><span class="p">.</span><span class="nx">Until</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wait</span><span class="p">.</span><span class="nx">Poll</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">RetryPeriod</span><span class="p">,</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">RenewDeadline</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nx">le</span><span class="p">.</span><span class="nx">tryAcquireOrRenew</span><span class="p">(),</span> <span class="kc">nil</span>
</span><span class='line'>      <span class="p">})</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">maybeReportTransition</span><span class="p">()</span>
</span><span class='line'>      <span class="nx">desc</span> <span class="o">:=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Describe</span><span class="p">()</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;successfully renewed lease %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">RecordEvent</span><span class="p">(</span><span class="s">&quot;stopped leading&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;failed to renew lease %v: %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>      <span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="p">},</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的精妙之处在于，<code>wait.Until</code> 会不断的调用 <code>wait.Poll</code> 方法，前者是进行无限循环操作，直到 <code>stop</code> chan 被关闭，<code>wait.Poll</code>则不断的对某一条件进行检查，以 <code>RetryPeriod</code> 为间隔，直到该条件返回true、error或者超时（上面的 RenewDeadline 参数）。这一条件是一个需要满足 <code>func() (bool, error)</code> 签名的方法，比如这个例子很简单，只是调用了 <code>le.tryAcquireOrRenew()</code>。</p>

<p><code>tryAcquireOrRenew</code> 方法本身不是一个阻塞操作，只返回 true/false，对应为获取到锁和没有获取到锁的状态。结合 <code>wait.Poll</code> 来使用，该函数返回会有以下几种情况：</p>

<ul>
<li><code>tryAcquireOrRenew</code> 获取到锁，返回 true</li>
<li><code>tryAcquireOrRenew</code> 没有获取到锁，返回 false</li>
<li><code>tryAcquireOrRenew</code> 超时，返回 <code>ErrWaitTimeout</code>（errors.New(&ldquo;timed out waiting for the condition&rdquo;)）</li>
</ul>


<p>最后，我们再来重点了解下 <code>tryAcquireOrRenew</code> 的内容。renew有两个功能，获取锁，或者在已经获取锁的时候，对锁进行更新，确保锁不被他人抢走。</p>

<p>具体的说明也放到了注释里，这段代码流程上不不复杂，但是需要对前后两个状态，以及 leader 和非 leader 两个角色的不同执行流程有所分辨。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">tryAcquireOrRenew</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">now</span> <span class="o">:=</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>  <span class="c1">// 这个 leaderElectionRecord 就是保存在 Endpoint 的 annotation 中的值。</span>
</span><span class='line'>  <span class="c1">// 每个节点都将 HolderIdentity 设置为自己，以及关于获取和更新锁的时间。后面会对时间进行修正，才会更新到 API server</span>
</span><span class='line'>  <span class="nx">leaderElectionRecord</span> <span class="o">:=</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">LeaderElectionRecord</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">HolderIdentity</span><span class="p">:</span>       <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Identity</span><span class="p">(),</span>
</span><span class='line'>      <span class="nx">LeaseDurationSeconds</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">LeaseDuration</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
</span><span class='line'>      <span class="nx">RenewTime</span><span class="p">:</span>            <span class="nx">now</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">AcquireTime</span><span class="p">:</span>          <span class="nx">now</span><span class="p">,</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 1. 获取或者创建 ElectionRecord</span>
</span><span class='line'>  <span class="nx">oldLeaderElectionRecord</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Get</span><span class="p">()</span>
</span><span class='line'>  <span class="c1">// 获取记录出错，有可能是记录不存在，这种错误需要处理。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nx">IsNotFound</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;error retrieving resource lock %v: %v&quot;</span><span class="p">,</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Describe</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="c1">// 记录不存在的话，则创建一条新的记录</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">leaderElectionRecord</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;error initially creating leader election record: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="c1">// 创建记录成功，同时表示获得了锁，返回true</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span> <span class="p">=</span> <span class="nx">leaderElectionRecord</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 2. 正常获取了锁资源的记录，检查锁持有者和更新时间。</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span><span class="p">,</span> <span class="o">*</span><span class="nx">oldLeaderElectionRecord</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 记录之前的锁持有者，其实有可能就是自己。</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span> <span class="p">=</span> <span class="o">*</span><span class="nx">oldLeaderElectionRecord</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// 在满足以下所有的条件下，认为锁由他人持有，并且还没有过期，返回 false</span>
</span><span class='line'>  <span class="c1">// a. 当前锁持有者的并非自己</span>
</span><span class='line'>  <span class="c1">// b. 上一次观察时间 + 观测检查间隔大于现在时间，即距离上次观测的间隔，小于 `LeaseDuration` 的设置值。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">LeaseDuration</span><span class="p">).</span><span class="nx">After</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>      <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span> <span class="o">!=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Identity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;lock is held by %v and has not yet expired&quot;</span><span class="p">,</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// 3. 更新资源的 annotation 内容。</span>
</span><span class='line'>  <span class="c1">// 在本函数开头 leaderElectionRecord 有一些字段被设置成了默认值，这里来设置正确的值。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span> <span class="o">==</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Identity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 如果自己持有锁，则继承之前的获取时间和 leader 切换次数</span>
</span><span class='line'>      <span class="nx">leaderElectionRecord</span><span class="p">.</span><span class="nx">AcquireTime</span> <span class="p">=</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">AcquireTime</span>
</span><span class='line'>      <span class="nx">leaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span> <span class="p">=</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 发生 leader 切换，所以 LeaderTransitions + 1</span>
</span><span class='line'>      <span class="nx">leaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span> <span class="p">=</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 更新锁资源对象</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Update</span><span class="p">(</span><span class="nx">leaderElectionRecord</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;Failed to update lock: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span> <span class="p">=</span> <span class="nx">leaderElectionRecord</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>  <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>再回到 <code>renew</code> 方法，在被 <code>Poll</code> 阻塞住之后，只要 <code>Poll</code> 返回了，就可以继续执行下面的代码。<code>le.maybeReportTransition()</code> 很关键，里面会判断是否出现了 leader 的切换，进而调用 <code>Callbacks</code> 的 <code>OnNewLeader</code> 方法，尽管 cm 初始化的时候并没有设置这个 Callback 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">maybeReportTransition</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">observedRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span> <span class="o">==</span> <span class="nx">l</span><span class="p">.</span><span class="nx">reportedLeader</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">l</span><span class="p">.</span><span class="nx">reportedLeader</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">observedRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Callbacks</span><span class="p">.</span><span class="nx">OnNewLeader</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">go</span> <span class="nx">l</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Callbacks</span><span class="p">.</span><span class="nx">OnNewLeader</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">reportedLeader</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码看起来比较烧脑，本文读起来也比较摸不着头，可能最好的办法就是一遍遍的阅读源代码了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向 Kubernetes 学习 - 如何实现定时轮训]]></title>
    <link href="http://liubin.org/blog/2018/04/27/learn-from-k8s-running-func-periodically/"/>
    <updated>2018-04-27T19:29:04+08:00</updated>
    <id>http://liubin.org/blog/2018/04/27/learn-from-k8s-running-func-periodically</id>
    <content type="html"><![CDATA[<p>编程中常见的场景包括定时执行任务，很多语言，比如 Java 提供了非常方便易用且功能强大的类库，但是 Golang 中并没有，虽然我们可以通过 <code>time.Ticker</code> 等机制实现，但是不如原生直接支持更简单。</p>

<p>其实参考别人的代码是最好的学习方式了，比如通过阅读 K8s 的源代码，我们可以学习到很多编程技巧。</p>

<p>这里我们以实现定时轮训功能为例，来看看 K8s 是怎么实现的。</p>

<p>首先简单介绍下 K8s 的简单架构，主要包括以下几个组件（大体流程）：</p>

<ul>
<li>API server</li>
<li>Scheduler</li>
<li>Controller manager</li>
<li>Kubelet</li>
</ul>


<p>这几个组件只是完整运行 K8s 的4个组件，并不是全部，这里我们只是为了了解而只对这几个组件进行说明。</p>

<p>首先客户端（API 或者 kubectl 工具）发出请求，比如创建一个Deployment，Controller manager 会负责这个 Deployment 的生命周期，Scheduler 会为 Pod 分配节点，该节点上的 Kubelet 会负责在自己的机器上启动这个 Pod，这是一个非常简单的流程。</p>

<p>这些组件，都是以守护进程方式运行的，即会一直无限循环的运行下去，不会退出。在其中有很多例子都是诸如每隔 5 分钟做一次同步，每隔 10 秒做一次 retry 的尝试。对于这样的需求，即使只有一处，相信从代码结构的角度，我们都会把这些功能抽象成 util 函数。</p>

<p>K8s 就实现了很多这样的方法，比如 &ldquo;k8s.io/apimachinery/pkg/util/wait&rdquo; 包就有很多非常实用的方法，值得我们借鉴。</p>

<p>首先，最简单的每隔 10 秒执行一个函数，永不停止，那么可以用<a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L78">这个方法</a>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Forever</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">period</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你想在上面的基础上，在需要的时候停止循环，那么可以使用<a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L87">下面的方法</a>，增加一个用于停止的 <code>chan</code> 即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Until</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">period</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">stopCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的第三个参数 <code>stopCh</code> 就是用于退出无限循环的标志，停止的时候我们 close 掉这个 chan 就可以了。</p>

<p>K8s 的很多地方都用到了这些函数，比如这里在 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/dockershim/cm/container_manager_linux.go#L70-L81">Container manager 启动的时候</a>，就启动了一个无限循环来进行实际的工作（ <code>m.doWork</code> 函数）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">containerManager</span><span class="p">)</span> <span class="nx">Start</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// TODO: check if the required cgroups are mounted.</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">cgroupsName</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">manager</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">createCgroupManager</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">cgroupsName</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nx">err</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nx">m</span><span class="p">.</span><span class="nx">cgroupsManager</span> <span class="p">=</span> <span class="nx">manager</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">go</span> <span class="nx">wait</span><span class="p">.</span><span class="nx">Until</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">doWork</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">,</span> <span class="nx">wait</span><span class="p">.</span><span class="nx">NeverStop</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="kc">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面只是简单的定期运行任务的例子，有时候，我们还会需要在运行前去检查先决条件，在条件满足的时候才去运行某一任务，这时候可以使用 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L220">Poll 方法</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Poll</span><span class="p">(</span><span class="nx">interval</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">condition</span> <span class="nx">ConditionFunc</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数会以 <code>interval</code> 为间隔，不断去检查 <code>condition</code> 条件是否为真，如果为真则可以继续后续处理；如果指定了 <code>timeout</code> 参数，则该函数也可以只常识指定的时间。</p>

<p>一个非常常见的例子就是我们在创建资源之后，资源不会立即就位，我们需要等资源创建完成之后，才能进行后续操作，这时候使用 <code>Poll</code> 方法应该就会非常方便了。</p>

<p>此外这个函数还有两个快捷方式， <code>PollImmediate</code> 、 <code>PollInfinite</code> 和 <code>PollImmediateInfinite</code> ，具体意义从名称上面即可理解。</p>

<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L289"><code>PollUntil</code></a> 方法和上面的类似，但是没有 <code>timeout</code> 参数，多了一个 <code>stopCh</code> 参数。</p>

<p>此外，这个包里还有一个公开方法 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L307"><code>WaitFor</code></a> ，好像并没有直接被外部调用，而是在 <code>PollUtil</code> 中被使用，这个方法需要自己编写 <code>WaitFunc</code> 类型的方法作为第一个参数，具体可以参考 <code>PollUntil</code> 的实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python/Java 才是王道，PHP 还得靠边站]]></title>
    <link href="http://liubin.org/blog/2017/07/18/python-and-java-main-stream/"/>
    <updated>2017-07-18T15:01:02+08:00</updated>
    <id>http://liubin.org/blog/2017/07/18/python-and-java-main-stream</id>
    <content type="html"><![CDATA[<p>3 月份 Erik Bernhardsson 发表了一篇文章 <a href="https://erikbern.com/2017/03/15/the-eigenvector-of-why-we-moved-from-language-x-to-language-y.html">The eigenvector of &ldquo;Why we moved from language X to language Y”</a> ，作者根据 Google 里面搜索 <code>move from &lt;language 1&gt; to &lt;language 2&gt;</code> 或 <code>switch to &lt;language 2&gt; from &lt;language 1&gt;</code> 等的结果数量，做了一个编程语言之间的转移矩阵（Stochastic matrix），采用马可夫链的平稳分布，得到了一些关于未来什么语言最流行的结论，文中也多次提到，那就是 go 语言，很多人搜索了从 xx 到 go ，go 语言才是未来的语言。此外，作者认为 Perl 已死，Java 正当年，Rust 也很有希望。</p>

<p>当然，在 Google 搜一下从 xx 到 yy ，并不代表真的开发者就要移情别恋，只有真的写了 yy 的代码，新的恋情才算开始。</p>

<p>所以，上周 Waren Long 基于 GitHub 数据的统计结果，发表了一篇文章 <a href="https://blog.sourced.tech/post/language_migrations/">Analyzing GitHub, how developers change programming languages over time</a> ，该文章统计了包含GitHub 中 450 万用户，以及10 TB 的源代码，分析了 393 种语言的变化趋势，最后得出的结论就是：Python 和 Java 才是王道。</p>

<p>这是 Waren Long 总结出来的流行语言的 Top 10 ：</p>

<p><img src="http://liubin.org/images/2017/07/language_top_10.png" alt="" /></p>

<p>从上图可以看到 Python (16.1 %) 才是最流行的编程语言，紧随其后的是 Java (15.3 %) 。而且前五名中，Python 代码量也比其他语言所占的比例要低（只有 11.3 %，我们可以理解为投入产出比、效益率，投入越少，产出越大，当然语言就比较流行），PHP 代码量最大，达到了 24.4 %，但是其流行程度只有 Python 的一半而已。</p>

<p>在这个排名中，go 排名第 9 ，但是相对于其 0.9 % 的代码量占比，这个位置还是很牛的了，效益率也是最高的。考虑到这个数据的时效性，相信 go 语言肯定还会进一步扩大受众。</p>

<p>下图是各语言之间的转换矩阵，左面是 From ，右面是 To ：</p>

<p><img src="http://liubin.org/images/2017/07/sum_matrix_22lang_eig.svg" alt="" /></p>

<p>在排名前 5 的语言中（Java、 C、 C++、 PHP、 Ruby，除去 Python ），有平均近 22% 的概率，会转移到 Python，不过大叔不理解的是为啥 Ruby 还会转移到 Python ？</p>

<p>而作为统计学领域中的 Fortran (36 %)、 Matlab (33 %) 和 R (40 %) ，转移到 Python 的概率都是非常高的，可见，在数学计算、机器学习等领域，Python 的地位似乎越来越稳固了。</p>

<p>从上面的转移矩阵，我们还可以发现一些有意思的规律，比如：</p>

<ul>
<li>Pascal 程序员最喜欢学习 Java</li>
<li>Visual Basic 程序员学习 C# 顺理成章，C# 程序员爱转 Python</li>
<li>Scala/Clojure 程序员最喜欢 Java，但是反过来不是，Java 程序员爱转 Python</li>
<li>Object C 和 Swift 互转说明这个统计结果还是挺靠谱的</li>
<li>转 go 最多的竟然不是 PHP 这样的脚本语言，而是 Rust，难道是 Rust 的学习曲线太陡了？</li>
</ul>


<p>下面的图是 16 年来各语言的平稳分布图：</p>

<p><img src="http://liubin.org/images/2017/07/eigenvect_stack_22lang.png" alt="" /></p>

<p>不过大叔不知道这16年的数据是怎么来的，如果我没记错的话，那时候应该还没有 GitHub 。</p>

<p>前两名 Python 和 Java 的趋势基本一样，都是稳中有升的形状。这两个语言已经取代了 C 语言的霸主地位，如果把这 3 种语言合起来看，则它们的总量几乎没什么变化。</p>

<p>Perl 基本死了，PHP 的扩张趋势也没那么明显，Ruby 粗了几年又细了，应该是和 Python 份额的扩大和 go 等的日渐流行有关。</p>

<p>如果让我总结一下，那么 Java、Python 和 go 值得关注、持续学习。</p>

<hr>


<p>这就是 Waren Long 原文里的几个重要结论，如果你对原始数据和算法感兴趣，可以直接 <a href="https://blog.sourced.tech/post/language_migrations/">阅读原文</a>  。</p>

<p><em>注意： 由于 JavaScript 的特殊性（前后通吃、受众广等，不适用于统计模型），Waren Long 的文章中并没有将 JavaScript 作为评价对象。</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[沟通的原则]]></title>
    <link href="http://liubin.org/blog/2017/06/16/rules-for-communication/"/>
    <updated>2017-06-16T07:40:16+08:00</updated>
    <id>http://liubin.org/blog/2017/06/16/rules-for-communication</id>
    <content type="html"><![CDATA[<p>沟通是工作中第一要义。</p>

<p>有效地沟通，能使工作更高效、提高大家的满意度；相反，错误的沟通方式除了降低工作的效率，还会制造出各种部门隔阂、人之矛盾，影响公司士气。因此高效的沟通不仅能更好地完成工作，还有助于提高公司的凝聚力，创造良好的公司文化。</p>

<h2>信息共享范围</h2>

<p>信息应该让谁知道，不该让谁知道？</p>

<p>在程序实现里我们爱用白名单，宁可错杀一千，不可放过一个；而在沟通中，则适用黑名单。如果某一信息确实不想让某些人知道，别让他知道就行了，否则就让所有人都知道，至于这些信息是否有用，是否需要处理，留给接收方决定即可。</p>

<p>常见的例子是功能需求讨论。一个功能，到底会不会影响其他功能，或者说是否有其他功能对该功能有兴趣，这个不是新功能的产品经理能掌握的，这时候最好的方式是全员周知，其他功能的负责人自然会判断这条信息是否跟自己有关，自己是否应该站出来参与到讨论当中。</p>

<p>是否会造成信息泛滥？有可能，不过我能接受这一点问题，相对来说，信息丢失更可怕。</p>

<h2>让信息共享成为常态</h2>

<p>最好的方式就是定期的会议，比如周会。这是员工了解公司、组织最常见的方式，也是效果比较好的方式。公司最近的变动，业务发展情况，都可以由中层领导传递给下属员工。除了让员工能了解公司的详细信息，还能鼓动员工干劲，提高员工对公司的信任程度。信任是双方向的，你若信任对方，对方也会 120% 的信任你。</p>

<p>欺瞒甚至扭曲事实最终都会偿还回来的，这个不会有例外。即使赢了世界，也会输掉人心。</p>

<p>领导不应该吝惜自己所掌握的信息，也不要以为这些信息对员工并无卵用。事实上多后进的员工，都会或多或少关心公司的某些方面。</p>

<p>更不要担心流言蜚语，空气太纯净，细菌滋生危害才会越大，正因为你不说，流言蜚语才会起来。</p>

<h2>以吼为荣</h2>

<p>原始社会，通讯基本靠吼；原始的才是最纯粹的，因为原始，效率最高。</p>

<p>文字的表达效率低于直接语言沟通，相信很多人有过通过 IM 一个字一个字的进行远程交流那种心急如焚、坐立不安的感觉。这时候只要条件允许，就应该换电话或者实时语音来进行交流，这才是效率最高、成本最低的方式。</p>

<p>同一个办公室，离着 5 米都不到，用 IM 你不怕费你的 HHKB Pro 么？</p>

<h2>要 <code>ack</code></h2>

<p>重要信息，需要得到对方的反馈，哪怕只有一句“好”、“明白了”也可以，确保对方收到了你的信息，而不是对方因为心不在焉而丢失了你要传达的消息。</p>

<p>交流要采用 TCP 的机制，需要对请求回应进行确认，不要像使用 UDP 那样，把消息放出去就不管了。</p>

<h2>以诚为本</h2>

<p>对事不对人是重要的原则，可以对人的做法、成果进行指责，但是不应该直接对人本身，尤其是人品进行评判。首先要尊重沟通的各方，换位思考，以同理心来进行交流，把自己摆在对方的角度进行假设，全面思考，在提出问题的时候，同时考虑是否可以提出一些解决方案，带着答案问问题，除了能更高效的解决问题，也能获得对方的信赖和感情分。</p>

<h2>会话的 Context 很重要</h2>

<p>你有多少次莫名其妙的被人拉进到一个群里被莫名其妙的问你各种问题的、一脸懵逼的经历么？</p>

<p>Context ，即背景，在向别人传达指令，或者寻求帮助的时候，需要让对方对整个事情的背景、详细情况或者来龙去脉有所了解，也就是提供对方能理解你所描述问题的所有线索。</p>

<p>比如 Bug 或故障，第一件事就是现象，哪里出了问题，怎么不正常，应该是什么样的。其次，要提供详细的操作说明，最好精确到每一个输入、每一次点击，以及有哪些预置条件。最重要的，还需要提供全面的日志，对开发人员来说，日志是解决问题的关键所在，程序的运行时异常、服务的逻辑异常，都能通过日志找到问题所在并提供解决问题的线索。</p>

<p>十几年前流传很广的一篇文章叫《提问的技巧》，那你是否掌握了《提 Bug 的技巧》或者《说明问题的技巧》？</p>

<h2>金字塔原理</h2>

<p>看似和上一条矛盾，根据情况，有时候信息接收者的关注点只是你的结论，而不关心过程，所以很多时候我们在表达的时候一定要先说结论和重点。</p>

<p>比如领导问你这个功能什么时候完成，你怎么回答？</p>

<p>最好的回答就是一个具体的时间点，就这么一句话，比如“本周末”、“6/20”等等。</p>

<p>如果这个时间点比计划的时间要晚，当然你要补充说明延迟的理由；如果并没有规定时间点或者说早于计划时间，那么别人问你什么时候完成的时候，你回答“我现在在做 xxx，出了点问题，需要谁谁谁来帮我解决一下；之后还要做 yyy，在 zzz 之后才能开始，预计 6/20 能完成”，说那么多废话有用么？我相信多数时候领导在问你进度的时候，最关心的是否有延期，是否能按时完成，没有问题就不要给领导添堵。</p>

<p>这是另一个例子，一段真实的对话。</p>

<p>A： “你几点回家？”</p>

<p>B： “我今天来的比较晚。”</p>

<p>A： “那是几点？”</p>

<p>B： “还有点活，干完就走”</p>

<p>A： “你就告诉是 7 点还是 8 点行么？”</p>

<p>B： “ 7 点”</p>

<p>推荐一本同名的书，大家可以找来读读。</p>

<hr />

<p>7 年前参加过拍马屁（PMP）的培训和考试，很多都忘了，只对沟通部分的原则和案例有些记忆，毕竟大多数时候，我们不是一个人在战斗。</p>

<p>所以，请重视沟通的方式、技巧和效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工具的品格]]></title>
    <link href="http://liubin.org/blog/2017/06/15/task-toolss-element/"/>
    <updated>2017-06-15T16:46:01+08:00</updated>
    <id>http://liubin.org/blog/2017/06/15/task-toolss-element</id>
    <content type="html"><![CDATA[<p>开发人员除了开发工具（编辑器、中间件），还需要各种必备的任务管理（或者进度管理、项目管理，不纠结其名字）工具，你可能用的是免费的 TODO list、Trello，或者诸如 JIRA 等商业软件，亦或是自己编写的简单 Web 管理工具，甚至记事本、OneNote等。也不管我们叫他 GTD 还是个人助理，我们依赖这些软件的原因之一无非是好脑子不如烂笔头，记下来就不会“忘”。</p>

<p>前面的“忘”字为什么加个双引号呢？因为记下来你看不到，还是会忘，因为这个工具可能并没有告诉现在你应该去做什么，这个任务，可能一直沉睡于箱子的底部。</p>

<p>一个好的任务管理工具最，我觉得基本应该包括以下几点必须的品格：</p>

<h2>任务状态</h2>

<p>是在进行中，还是准备中；是否处于一个流水线上，处于哪个阶段；是否顺利，有什么 Block 的问题等等。有了任务状态，才能决定采取何种措施。我们对应用程序的性能、服务器的使用情况、中间件的健康程度都有监控，自己的任务也应该有类似的监控机制：你的任务是绿？黄？还是红？（Elastic Search用户都秒懂的）</p>

<h2>任务优先级</h2>

<p>对大多数软件开发人员来说，并行工作司空见惯，反过来一个月只做一件事的人估计只能是宝洁或者厨子了。一个人很多时候可能担任多个项目、多个产品、多个组件的开发工作，这时候任务列表可能堆积如山，如果没有为这些工作设置优先级并进行可视化，你看到这么多任务如何决定该先干哪个后干哪个？有新的任务进来，是不是该停下手头的工作开始新任务？还是让新任务靠边站。</p>

<p>为任务排序，是有条不紊高效工作的第一步。</p>

<h2>依赖关系</h2>

<p>大多时候你不是一个人在战斗，你可能会和前端、后端、日志服务、API服务、运维或者产品经理一起在完成一个功能，你即依赖别人，也被别人依赖。DevOps 主张消除浪费，每个等待都是浪费，你写到一半的代码就像保存在仓库中的玉米，天气潮湿可能发霉、生虫。</p>

<p>识别依赖关系、解决绊脚石，能保证任务顺利完成。</p>

<h2>工作流支持</h2>

<p>DevOps 要做的是一个统一工作流平台，就像流水线那样，零件从一个部分传到下一个部分，如果流水线的履带宽度不一样、速度不一样，能衔接的稳？</p>

<p>任务管理工具也是，和其他工具的无缝集成是一个大大的必备项。比如是否支持开发中其他工具，比如构建、发布或测试等的插件支持。</p>

<p>这很重要，也是 DevOps 或者流水线的关键，我们的每项开发活动的产出物，是否可以通畅的缴费给流水线的下一个动作？</p>

<p>考察这一点的标准也很简单，你是否在不同的工具之间拷贝某个提交号、版本号、或者某些说明？</p>

<h2>领导角度</h2>

<p>个人需要方便的任务管理工具，领导更需要。成员的任务就是组织的任务，领导是最任务的终责任者，最终责任者更需要对任务状态、进度等了如指掌，这是第一。</p>

<p>第二，你需要掌握组员的状态。而任务可以在很大的程度上体现组员的现在状态：是否工作压力很大，是否遇到了麻烦，是否可以抽出来去做别的救火队员。</p>

<p>从管理角度上来说，多维度的报表也很重要，项目进度、花费的成本、产品的质量，都可以从任务管理工具得到直观的结果。</p>

<h2>铁证如山</h2>

<p>不管你要扯皮的对象是谁：同事、领导、客户、其他部门，你都需要拿出证据去说服别人、怼（dǔi）到让别人无话可说。</p>

<p>这时候，我们就需要工具具备丰富的记录功能，至少能传个附件吧，修改履历功能也是必不可少的。</p>

<hr />

<p>上面列出来的只是自己的观点，有些人可能不觉得，甚至很多人都不在乎，不过大叔实在是难以忍受不抱怨工具的开发 ：-）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang中一个不错的处理 JSON 的库 go-dproxy]]></title>
    <link href="http://liubin.org/blog/2016/10/08/go-dproxy/"/>
    <updated>2016-10-08T18:11:13+08:00</updated>
    <id>http://liubin.org/blog/2016/10/08/go-dproxy</id>
    <content type="html"><![CDATA[<p>Golang 自己就带了 JSON (encoding/json) 处理的库，也有第三方的 <a href="https://github.com/bitly/go-simplejson">simplejson</a> 之类的库，但总是感觉不如Python这样的动态语言方便，在 Python 里，数组和字典的处理都很方便，和 JSON 互转也非常简单。</p>

<p><code>encoding/json</code> 最大的问题是不够灵活，需要预先定义很多的 <code>struct</code> 来进行编解码，这样对于处理结构不定的 JSON 文件非常不方便。</p>

<p>这里介绍一个名为 <a href="https://github.com/koron/go-dproxy">go-dproxy</a> 的库，非常方便和简单，不需要预先定义 <code>struct</code> ，还可以类似 XPath 那样查找。</p>

<p>下面是一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="p">(</span>
</span><span class='line'>  <span class="s">&quot;encoding/json&quot;</span>
</span><span class='line'>  <span class="s">&quot;fmt&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/koron/go-dproxy&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">v</span> <span class="kd">interface</span><span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{</span>
</span><span class='line'><span class="s">      &quot;name&quot;: &quot;dproxy&quot;,</span>
</span><span class='line'><span class="s">  &quot;strings&quot;: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ],</span>
</span><span class='line'><span class="s">  &quot;numbers&quot;: [ 1,2,3 ],</span>
</span><span class='line'><span class="s">  &quot;mixs&quot;: [&quot;a&quot;, 1, &quot;b&quot;],</span>
</span><span class='line'>
</span><span class='line'><span class="s">  &quot;tags&quot;: {</span>
</span><span class='line'><span class="s">    &quot;key-1&quot;: &quot;value-1&quot;,</span>
</span><span class='line'><span class="s">    &quot;key-2&quot;: 100,</span>
</span><span class='line'><span class="s">    &quot;key-3&quot;: [4,5,6]</span>
</span><span class='line'><span class="s">  }</span>
</span><span class='line'><span class="s">}`</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// s == &quot;dproxy&quot;, got a string.</span>
</span><span class='line'>  <span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;1. name is %s\n&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// err: not matched types: expected=int64 actual=string: name</span>
</span><span class='line'>  <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">).</span><span class="nx">Int64</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;2. err is %s\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// can be chained. n == 3, got a int64</span>
</span><span class='line'>  <span class="nx">n</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;numbers&quot;</span><span class="p">).</span><span class="nx">A</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">Int64</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;3. n is %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// got value-1</span>
</span><span class='line'>  <span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;tags&quot;</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;key-1&quot;</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;4. key-1 is %s\n&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// err.Error() == &quot;not found: data.kustom&quot;, wrong query can be verified.</span>
</span><span class='line'>  <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;data&quot;</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;kustom&quot;</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;5. err is %s\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// n == 5</span>
</span><span class='line'>  <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&quot;/tags/key-3/1&quot;</span><span class="p">).</span><span class="nx">Int64</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;6. n is %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者从 <a href="https://gist.github.com/liubin/5521035cb9dab26e5981549b2cea355a">gist</a> 下载这个文件，执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="err">$</span> <span class="k">go</span> <span class="nx">get</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">koron</span><span class="o">/</span><span class="k">go</span><span class="o">-</span><span class="nx">dproxy</span>
</span><span class='line'><span class="err">$</span> <span class="k">go</span> <span class="nx">build</span> <span class="nx">dproxy</span><span class="o">-</span><span class="nx">test</span><span class="p">.</span><span class="k">go</span>
</span><span class='line'><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">dproxy</span><span class="o">-</span><span class="nx">test</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>即可。</p>

<p>总之，这个库处理JSON应该算是非常简单，希望对你有所帮助。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年8月读书记录]]></title>
    <link href="http://liubin.org/blog/2016/09/06/2016-08-reading/"/>
    <updated>2016-09-06T19:34:20+08:00</updated>
    <id>http://liubin.org/blog/2016/09/06/2016-08-reading</id>
    <content type="html"><![CDATA[<h2>穿越百年中东</h2>

<p><img src="https://img3.doubanio.com/lpic/s28419285.jpg" alt="" /></p>

<p>推荐指数：★★★★★</p>

<p>这本书是我阅读到的关于伊斯兰的比较详细的一本书，从奥匈帝国和第一次世界大战开始，讲述了伊拉克、以色列等建国，契丹人、穆斯林、犹太人的渊源和纷争，伊斯兰教的兴起和发展，逊尼派和什叶派的争斗等等，内容非常详细。</p>

<p>如果你也对最近的叙利亚冲突等不甚明了，那么可以试读一下本书。</p>

<h2>《禅与摩托车维修艺术》</h2>

<p><img src="https://img3.doubanio.com/lpic/s6927676.jpg" alt="" /></p>

<p>推荐指数：★★★★☆</p>

<p>这是新世相活动收到的第一本书，用了12天才看完，中间过程各种闹心，多次要放弃，但是要考虑到129块钱。</p>

<p>说实话，没太懂，不知道看完这本书有什么新的收获。只是对古典和浪漫、两良质等词汇印象深刻。</p>

<p>讲哲学？有点像，哲学是什么？是探究事物的本质？万相皆有其缘，不是佛法中的尤其因必有其果，而是不论什么结果，都可以找到相应的原因。</p>

<p>哲学是不断对本质的思考，而思考则会受到个人在不同环境、时代、地区等的影响，因此，人的看法才会变，对世界、对本质的理解才会变。</p>

<p>唯一不变的，就是对本质本身的追求，不断地思考。</p>

<p>&ldquo;我在公路上慢慢地走着，不想去打扰阳光，这正是早秋的感觉。&rdquo;</p>

<p><img src="http://image.beekka.com/blog/201112/bg2011121802.jpg" alt="" /></p>

<h2>《虚无的十字架》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28096698.jpg" alt="" /></p>

<p>推荐指数：★★★★★</p>

<p>看了不到1/3，我就大概猜出来凶手是为包庇自己子女顶罪了，但至于原因还是到最后才知道。怀孕杀死新生婴儿这个设定太狗血了。</p>

<p>总之，作为各个书店推荐的畅销品，还是不错的。</p>

<h2>《五十年代的尘埃》</h2>

<p><img src="https://img3.doubanio.com/lpic/s27996544.jpg" alt="五十年代的尘埃" /></p>

<p>推荐指数：★★★★☆</p>

<p>这是新世相的第二本书，比较薄，一天就看完了。</p>

<p>书中内容主要是作者在50年代左右的一些随笔，比如梅兰芳传记，自己租房的记录等等，算是对50年代大陆生人又去美国发展的那一代人的生活、意识有了一点了解。</p>

<h2>《废都》</h2>

<p><img src="https://img3.doubanio.com/lpic/s7633093.jpg" alt="废都" /></p>

<p>推荐指数：★★★★☆</p>

<p>不多说了，90年代感十足的一本书。</p>

<h2>《伊斯兰国》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28363789.jpg" alt="" /></p>

<p>推荐指数：★★☆☆☆</p>

<p>这也能算本书？附录占了多一半，在kindle上看的，大概只用了30分钟左右吧。</p>

<p>不推荐。而推荐下面的《穿越百年中东》一书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年7月读书记录]]></title>
    <link href="http://liubin.org/blog/2016/08/05/07-reading/"/>
    <updated>2016-08-05T23:46:34+08:00</updated>
    <id>http://liubin.org/blog/2016/08/05/07-reading</id>
    <content type="html"><![CDATA[<p>7月大概是比较忙的原因吧，读完的只有3本，一本是东野圭吾的《梦幻花》，kindle上看着价格还不错就买了；还有一本是最近比较火的管理类，杰克•韦尔奇的《商业的本质》。《无声告白》也是在kindle上看的。</p>

<h2>《梦幻花》</h2>

<p><img src="https://img1.doubanio.com/lpic/s27980309.jpg" alt="梦幻花" /></p>

<p>推荐指数：★★★★☆</p>

<p>其实仔细想想，情节也很“日式”，每个人都坚信着自己的“义务”或者“责任”，为了家族或者宿命而“不得不”背负的责任。这有点类似家臣的意思，即一代为臣，世代效忠主人，而上一代人所肩负的责任，也会被下一代继承和发扬，面对现实，不去逃避，而是努力去解决。</p>

<p>作为悬疑小说，推理方面的吸引力一般。最后找到真正的杀人凶手有点虎头蛇尾的感觉，就那么几十个字带过，而之前的各种推理、假设和怀疑还是挺吸引人的；而凶手的暴露太突然了，有点意犹未尽的感觉。</p>

<h2>《商业的本质》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28504660.jpg" alt="商业的本质" /></p>

<p>推荐指数：★★★★★</p>

<p>我一贯认为，成功（至少在金钱方面）和市面管理类书籍之间没有任何关系：即使你熟记了所有经管类、个人传记类的成功案例，你也很难成功；成功的人，很多地方都不符合这些书中所提到的观点、方式或者经验。</p>

<p>凡是能写成书的，大都是因为“成功了，屁都是经验”。当然，这本书也不例外。</p>

<p>那我为什么还要读这类的书？至少对我来说，可以找一下和成功人士的共同语言，提高一下自己的“品格”，还有就是能多些谈资，学习更多的经验。所以说，多少还是要读一些的。</p>

<p>首先这本书的中文名翻译就有问题，英文名应该是《The real life MBA》吧，所以，这本书只有不到一半的内容是关于商业的东西，比如成本、销售或者市场等，而更多的是像在讲管理，比如如何构建团队、提高领导力和构建自己的职业生涯等。</p>

<h2>《无声告白》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28109182.jpg" alt="无声告白" /></p>

<p>推荐指数：★★★★★</p>

<p>母亲在年轻时爱上了爸爸，并不得不放弃了自己的学业。多年以后，母亲当时的理想并未褪去，在老二（莉迪亚本书开篇即死去的高中女孩）出生后不久一个人离家出走想继续学业，无奈后来发现怀了老三，只好回家，不得不放弃了自己的理想，但是，却把自己的希望都寄托给了莉迪亚，对她严加管教、全面指导。</p>

<p>而一家人之间并不是那么“亲密”，人之间关系比较冷淡，父亲按部就班的工作，目前全职主妇，辅导二女儿学习，父母之间，父母和孩子之间，并没有真实真心的交流。莉迪亚只是被动的活着，一切都要听母亲的摆布，而哥哥即将远赴哈佛读大学，也让莉迪亚变得对人生更加不抱希望，在孤独中选择了自杀。</p>

<p>家庭是什么，虽然有各种分工，有人负责赚钱，养家糊口，有人复杂相夫教子把持家务，但任何人之间的真诚交流都是必不可少的，即使对小孩子也是，更何况已经是成人的高中生？</p>

<p>孩子除了学习，心理的健康也是不得不关注的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年6月读书记录]]></title>
    <link href="http://liubin.org/blog/2016/07/09/06-reading/"/>
    <updated>2016-07-09T23:06:52+08:00</updated>
    <id>http://liubin.org/blog/2016/07/09/06-reading</id>
    <content type="html"><![CDATA[<p>度过5月低潮，6月的阅读时间又升上来了，本月基本上以微信读书为主。至于是什么原因呢？可能是因为一本书读起来就不想放下，一直读下去，直到读完。</p>

<p>6月一共阅读了6本，分别是《消费心理十四讲》、《袁腾飞讲先秦上古春秋》、《中国为什么有前途》、《白夜行》、《最神奇的经济学定律》和《国学讲演录》</p>

<h2>《白夜行》</h2>

<p><img src="https://img3.doubanio.com/lpic/s4610502.jpg" alt="白夜行" /></p>

<p>推荐指数：★★★★★</p>

<p>这可能是东野圭吾在国内最著名的小说之一了，也被翻拍成了影视作品。</p>

<p>作为侦探小说，情节还算不错。</p>

<p>我的感觉是，人生的长河，你总能找到同路人，相同的家庭环境，类似的遭遇或者不幸；不管是旋涡、阻挡，亦或是激流之后一湾浅滩的平静。每个人的人生都不同，但是总有重复相同经历的人。</p>

<h2>《袁腾飞讲先秦上古春秋》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28013690.jpg" alt="袁腾飞讲先秦上古春秋" /></p>

<p>推荐指数：★★★★★</p>

<p>这是一本历史书，从人文之初、轩辕黄帝一直讲到了春秋晚期，包括三代夏商周的更迭，以及春秋时期各诸侯的争霸。
对于长久不学习历史的人来说，算是一个很好的补足，对已经遗忘的、在初中、高中所学历史的补足。我们的传统文化还是很悠久和博大精深的，我觉得无论年纪大小，都应该读一下。</p>

<p>龙的传人：</p>

<p>伏羲和女娲结婚时，女娲才16岁，比伏羲小15岁。伏羲龙身，女娲蛇身，因此后代被称为龙的传人。</p>

<p>炎黄子孙：</p>

<p>炎帝和黄帝同为华夏部落，所以我们也成为炎黄子孙。</p>

<h2>《中国为什么有前途》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28562483.jpg" alt="中国为什么有前途" /></p>

<p>推荐指数：★★★★★</p>

<p>罗胖从政治、历史、经济和宗教等方面，针对各种消极、自卑和唱衰言论，东拉西扯、引经据典外加自己缜密的推断，论述了他眼中的中国为什么有前途。</p>

<p>尽管这一观点我不是很同意。</p>

<p>作为一个70年代出生，经历了30多年的改革开放，生活水平大幅提高，事业有成的罗胖，得出此结论并不奇怪，乐观派没什么不好，乐观派才能干成事。</p>

<p>然而现实实际是如何？近期的南海问题、韩国萨德、吃KFC成卖国贼等等，哪一个不是引起轩然大波，吸引力全社会各个阶层的关注甚至撕b？</p>

<p>我只是觉得，没朋友很孤独，尽管国家之间的友谊，更多时候是利害关系的外衣。</p>

<p>我们的朋友真的不多。</p>

<h2>《国学讲演录》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28306721.jpg" alt="国学讲演录" /></p>

<p>推荐指数：★★★★★</p>

<p>本书作者是南怀瑾高足魏承思，是一本由讲稿整理而成的书，讨论了国学的概念、定义、范围，还对诸子百家学说进行了详细的介绍。包括儒、释、道，还有墨家和法家，以及魏晋、隋唐的佛学、宋明理学等。同时，也对四书五经、诸子学说与二十四史等经史子集进行了深入的说明，是对我们中学所学历史的丰富补充。</p>

<p>总之，对于像学习一下中国传统文化、国学的人来说，都可以说算的上一本非常好的入门，内容浅显易懂而又详实饱满，张杰组织和条理也都很清楚。</p>

<h2>《最神奇的经济学定律》</h2>

<p><img src="https://img3.doubanio.com/lpic/s6179345.jpg" alt="最神奇的经济学定律" /></p>

<p>推荐指数：★★★★☆</p>

<p>这不是晦涩难懂、偏重理论的一本关于经济学的书，而是结合了具体事例，分析了各种现象，并给出了各种适用场景和建议告诉我们在现实世界中，在哪里以及如何应用这些定律。</p>

<p>同时本书也引用了很多历史典故、有趣的事例等。</p>

<p>比如美国航天飞机火箭助推器的宽度，为什么是现在这个值么？答案就是：</p>

<blockquote><p>现代铁路两条铁轨之间的标准距离是4.85英尺。原来，早期的铁路是由建电车的人所设计的，而4．85英尺正是电车所用的轮距标准。那么，电车的标准又是从哪里来的呢？最先造电车的人以前是造马车的，所以电车的标准是沿用马车的轮距标准。马车又为什么要用这个轮距标准呢？英国马路辙迹的宽度是4．85英尺，所以，如果马车用其他轮距，它的轮子很快会在英国的老路上撞坏。这些辙迹又是从何而来的呢？从古罗马人那里来的。因为整个欧洲，包括英国的长途老路都是由罗马人为它的军队所铺设的，而4．85英尺正是罗马战车的宽度。任何其他轮宽的战车在这些路上行驶的话，轮子的寿命都不会很长。罗马人为什么以4．85英尺作为战车的轮距宽度呢？原因很简单，这是牵引一辆战车的两匹马屁股的宽度。故事到此还没有结束。美国航天飞机燃料箱的两旁有两个火箭推进器，因为这些推进器造好之后要用火车运送，路上又要通过一些隧道，而这些隧道的宽度只比火车轨道宽一点，因此火箭助推器的宽度是由铁轨的宽度所决定的。
所以，最后的结论是：路径依赖导致了美国航天飞机火箭助推器的宽度，竟然是两千年前便由两匹马屁股的宽度所决定。</p></blockquote>

<p>当然，本书不是讲故事，也还是介绍了很多经济学专门知识的，比如凯恩斯对宏观经济的看法、基尼系数等。</p>

<h2>《消费心理十四讲》</h2>

<p><img src="https://img1.doubanio.com/lpic/s27184788.jpg" alt="消费心理十四讲" /></p>

<p>推荐指数：★★★☆☆</p>

<p>本书主要讲的是如何让品牌深入人心，如何吸引顾客的注意力和兴趣、满足顾客、把商品卖给顾客。</p>

<p>书中介绍了购物时人的心理的各个阶段：</p>

<ul>
<li>1.注意目标</li>
<li>2.引起兴趣</li>
<li>3.产生购买欲望</li>
<li>4.信任</li>
<li>5.决定购买</li>
<li>6.满足</li>
</ul>


<p>围绕这几个阶段，作者在各个章节展开了详细的叙述，比如如何吸引用户的兴趣，如何取得用户的信任，如何影响用户做决定等等。</p>

<p>其中关于群体效应的章节中，作者介绍哦啊了潮流产生和发展的几个阶段和特征，我觉得挺有意思的：</p>

<ul>
<li>1.潮流开始时一定包含着某些创新元素，即以前没有过的。</li>
<li>2.潮流最开始兴起的原因是某些人为了表明自己与众不同。</li>
<li>3.潮流的下一个特征——模仿，其他人会模仿最初的尝试者。</li>
<li>4.模仿阶段之后，曾经拥有新装备的潮流发起个体，即最初的尝试者不再突出。</li>
</ul>


<p>具体的话可以找来这本书看看。</p>

<p>总之，这不是一本特别差的书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初试Docker swarm]]></title>
    <link href="http://liubin.org/blog/2016/06/21/try-new-docker-swarm/"/>
    <updated>2016-06-21T20:41:42+08:00</updated>
    <id>http://liubin.org/blog/2016/06/21/try-new-docker-swarm</id>
    <content type="html"><![CDATA[<p>DockerCon 2016今天凌晨开始了，Docker公司的CEO和CTO都做了慷慨激昂的演讲（其实是我瞎想象的，没听，只是看了一些别人整理的 highlight ）。</p>

<p>同时，1.12 RC2也出来了，很多 <a href="http://liubin.org/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0/">新功能</a> 已经可以试用了， 这里我们就来试一下 <code>docker swarm</code> 命令吧，这也是 <code>swarm</code> 成为Docker子命令的第一个版本。</p>

<p>测试环境：</p>

<ul>
<li>OS：OS X</li>
<li>Docker：1.12.0-rc2</li>
<li>Docker Machine：0.8.0-rc1</li>
</ul>


<p>系统构成：</p>

<ul>
<li>master 1台</li>
<li>worker 2台</li>
</ul>


<h2>升级Docker</h2>

<p>使用Docker for Mac升级Docker很简单，这里不多说了；升级之后确认一下是最新版的Docker就可以了。</p>

<h2>创建3台Docker主机</h2>

<p>首先，使用Docker Machine创建3台主机，一台名为 <code>manager1</code> ，其余两台为 <code>worker1</code> 和 <code>worker2</code> ：</p>

<p>创建master节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine create --driver virtualbox manager1</span></code></pre></td></tr></table></div></figure>


<p>创建2个worker节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine create --driver virtualbox worker1
</span><span class='line'>$ docker-machine create --driver virtualbox worker2</span></code></pre></td></tr></table></div></figure>


<p>之后可以确认一下3台机器是否创建成功，以及ta们的IP地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine ls
</span><span class='line'>NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
</span><span class='line'>manager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v1.12.0-rc2   
</span><span class='line'>worker1    -        virtualbox   Running   tcp://192.168.99.101:2376           v1.12.0-rc2   
</span><span class='line'>worker2    -        virtualbox   Running   tcp://192.168.99.102:2376           v1.12.0-rc2   
</span></code></pre></td></tr></table></div></figure>


<h2>创建Swarm集群</h2>

<p>首先，切换到 <code>manager1</code> 主机，使用 <code>docker swarm init</code> 命令创建一个集群：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ eval $(docker-machine env manager1)
</span><span class='line'>
</span><span class='line'>$ docker swarm init --listen-addr 192.168.99.100:2377
</span><span class='line'>Swarm initialized: current node (alq8w7fi34f41j3z4ise1vkd7) is now a manager.</span></code></pre></td></tr></table></div></figure>


<p>使用 <code>docker info</code> 确认一下当前节点信息，可以看到Swarm属性部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker info
</span><span class='line'>... ...
</span><span class='line'>Swarm: active
</span><span class='line'> NodeID: alq8w7fi34f41j3z4ise1vkd7
</span><span class='line'> IsManager: Yes
</span><span class='line'> Managers: 1
</span><span class='line'> Nodes: 1
</span><span class='line'> CACertHash: sha256:7a9d0eb1621afe2be07c5fd405b8f038c76be3a8dc7b2c73944a2d1ab9dffd76
</span><span class='line'>
</span><span class='line'>... ...</span></code></pre></td></tr></table></div></figure>


<p>在2台worker节点上，通过  <code>docker swarm join</code> 命令加入到刚才创建的集群中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ eval $(docker-machine env worker1)
</span><span class='line'>$ docker swarm join 192.168.99.100:2377
</span><span class='line'>This node joined a Swarm as a worker.
</span><span class='line'>$ docker info
</span><span class='line'>... ...
</span><span class='line'>Swarm: active
</span><span class='line'> NodeID: 4l2a9ebgmcpwqlo0roye0n6m5
</span><span class='line'> IsManager: No
</span><span class='line'>... ...</span></code></pre></td></tr></table></div></figure>


<p>回到 <code>manager1</code> 节点，确认一下集群中节点的个数和状态。在 <code>MANAGER STATUS</code> 属性中，可以看到谁是Leader：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ eval $(docker-machine env manager1)
</span><span class='line'>$ docker node ls
</span><span class='line'>ID                           NAME      MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
</span><span class='line'>4l2a9ebgmcpwqlo0roye0n6m5    worker1   Accepted    Ready   Active        
</span><span class='line'>alq8w7fi34f41j3z4ise1vkd7 *  manager1  Accepted    Ready   Active        Leader
</span><span class='line'>e0khh79c6owm0e14mli602q0a    worker2   Accepted    Ready   Active        </span></code></pre></td></tr></table></div></figure>


<h2>创建nginx服务</h2>

<p>首先，创建一个覆盖网络：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker network create -d overlay ngx_net
</span><span class='line'>8kiv8muduf60f66rs99ufo25f</span></code></pre></td></tr></table></div></figure>


<p>然后使用这个覆盖网络，创建nginx服务：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service create --name nginx --replicas 1 --network ngx_net -p 80:80/tcp nginx
</span><span class='line'>78cmmh8ef4qcwmjjzgn3k45ch</span></code></pre></td></tr></table></div></figure>


<p>这样，就创建了一个具有一个副本（ <code>--replicas 1</code> ）的 <code>nginx</code> 服务，使用镜像 <code>nginx</code> 。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE           DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Preparing 9 seconds  Running        manager1</span></code></pre></td></tr></table></div></figure>


<p>注意上面的 <code>STATE</code> 字段中刚开始的服务状态为 <code>Preparing</code>，需要等一会才能变为 <code>Running</code> 状态，其中最费时间的应该是下载镜像的过程。</p>

<p>过一会再查看服务状态，就可以看到状态已经变为 <code>Running</code> 了，这是可以通过 <code>http://192.168.99.100/</code> 查看 Nginx服务。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE              DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running About a minute  Running        manager1
</span><span class='line'>
</span><span class='line'># 通过curl查看服务是否正常运行
</span><span class='line'>$ curl http://192.168.99.100/
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure>


<h2>对服务进行扩展（scale）</h2>

<p>当然，如果只是通过service启动容器，swarm也算不上什么新鲜东西了。Service还提供了复制（类似k8s里的副本）功能。可以通过 <code>docker service scale</code> 命令来设置服务中容器的副本数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service scale nginx=5
</span><span class='line'>nginx scaled to 5</span></code></pre></td></tr></table></div></figure>


<p>和创建服务一样，增加scale数之后，将会创建新的容器，这些新启动的容器也会经历从准备到运行的过程，过一分钟左右，服务应该就会启动完成，这时候可以再来看一下 <code>nginx</code> 服务中的容器（task）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE         DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running 5 minutes  Running        manager1
</span><span class='line'>co0re9u7infoo9qiegm6yiqcn  nginx.2  nginx    nginx  Running 2 minutes  Running        worker1
</span><span class='line'>19dvayah8fjz3vykrl2oi12uu  nginx.3  nginx    nginx  Running 2 minutes  Running        worker1
</span><span class='line'>d8okdip767972p083tix4dk7d  nginx.4  nginx    nginx  Running 2 minutes  Running        manager1
</span><span class='line'>9rq59mf6bq5m411y6gdzb5pq6  nginx.5  nginx    nginx  Running 2 minutes  Running        worker2</span></code></pre></td></tr></table></div></figure>


<p>可以看到，之前 <code>nginx</code> 容器只在 <code>manager1</code> 上有一个实例，而现在又增加了4个实例。</p>

<p>我们可以在 <code>manager1</code> 上查看一下这台主机上运行的容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
</span><span class='line'>4bbc02bc426e        nginx:latest        "nginx -g 'daemon off"   4 minutes ago       Up 4 minutes        80/tcp, 443/tcp     nginx.4.d8okdip767972p083tix4dk7d
</span><span class='line'>1eda6f7d3029        nginx:latest        "nginx -g 'daemon off"   5 minutes ago       Up 5 minutes        80/tcp, 443/tcp     nginx.1.394by1b72i44a44jms2xwk6ud</span></code></pre></td></tr></table></div></figure>


<h2>容器异常停止时的处理</h2>

<p>如果一个服务中的一个任务突然终止了，Docker会怎么处理？这里我们就来模拟某一容器异常终止的情况。</p>

<p>在操作之前，我们在另一个窗口，准备好使用 <code>tail -f /var/log/docker.log</code> 命令来查看Docker守护进程的日志。</p>

<p>我们通过 <code>docker rm -f</code> 来删除一个容器（<code>4b</code> 表示的是我们第一个启动的 <code>4bbc02bc426e</code> 容器）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker rm -f 4b
</span><span class='line'>4b
</span></code></pre></td></tr></table></div></figure>


<p>回到Docker守护进程的日志查看窗口，我们会看到类似这样的日志（有删减），从日志中，我们可以看到旧容器（id为 <code>4bbc02bc426e</code> ，task id为 <code>d8okdip767972p083tix4dk7d</code>）的删除和新容器（task id为 <code>cumjdktbadaxca66rt4hi63na</code>）的调度过程（删除了日志中的时间戳和日志级别等非重要信息，但保留了日志的时间顺序）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 调用删除容器的API
</span><span class='line'>msg="Calling DELETE /v1.24/containers/4b?force=1" 
</span><span class='line'>
</span><span class='line'># d8的任务从RUNNING变为了FAILED状态
</span><span class='line'>msg="state changed" module=taskmanager state.desired=RUNNING state.transition="RUNNING-&gt;FAILED" task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>
</span><span class='line'># 将旧任务停止
</span><span class='line'>msg=assigned module=agent task.desiredstate=SHUTDOWN task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>
</span><span class='line'># 分配到新的节点，创建新的任务id： cumj
</span><span class='line'>msg="Assigning to node e0khh79c6owm0e14mli602q0a" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 旧任务状态更新为FAILED
</span><span class='line'>msg="(*Agent).UpdateTaskStatus" module=agent task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="FAILED-&gt;FAILED" task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>
</span><span class='line'># 新任务从ASSIGNED变为接受状态
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="ASSIGNED-&gt;ACCEPTED" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 准备运行新任务
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="ACCEPTED-&gt;PREPARING" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 运行新任务
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="PREPARING-&gt;STARTING" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 新任务启动完成
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="STARTING-&gt;RUNNING" task.id=cumjdktbadaxca66rt4hi63na 
</span></code></pre></td></tr></table></div></figure>


<p>从上面的日志我们不难看出，一个任务的生命周期的前半生，大概就是 <code>ASSIGNED</code> -> <code>ACCEPTED</code> -> <code>PREPARING</code> -> <code>STARTING</code> -> <code>RUNNING</code> 。</p>

<p>在 <code>manager1</code>主机上，我们看到这个容器已经删除了， <code>ps</code> 只能看到一个容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
</span><span class='line'>1eda6f7d3029        nginx:latest        "nginx -g 'daemon off"   6 minutes ago       Up 6 minutes        80/tcp, 443/tcp     nginx.1.394by1b72i44a44jms2xwk6ud</span></code></pre></td></tr></table></div></figure>


<p>再来查看一下 <code>nginx</code> 服务的任务列表，可以看到新创建的任务 <code>cumjdktbadaxca66rt4hi63na</code> 被调度到了 <code>worker2</code> 上运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE          DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running 8 minutes   Running        manager1
</span><span class='line'>co0re9u7infoo9qiegm6yiqcn  nginx.2  nginx    nginx  Running 5 minutes   Running        worker1
</span><span class='line'>19dvayah8fjz3vykrl2oi12uu  nginx.3  nginx    nginx  Running 5 minutes   Running        worker1
</span><span class='line'>cumjdktbadaxca66rt4hi63na  nginx.4  nginx    nginx  Running 32 seconds  Running        worker2
</span><span class='line'>9rq59mf6bq5m411y6gdzb5pq6  nginx.5  nginx    nginx  Running 5 minutes   Running        worker2</span></code></pre></td></tr></table></div></figure>


<h2>删除一个节点？</h2>

<p>不难想象，如果一个节点都宕机了，则Docker应该会将在该节点运行的容器，调度到其他节点，以满足指定数量的副本保持运行状态。</p>

<p>下面我们就来模拟一下这种场景。</p>

<p>首先，我们删除一个节点 <code>worker2</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine rm worker2
</span><span class='line'>About to remove worker2
</span><span class='line'>Are you sure? (y/n): y
</span><span class='line'>Successfully removed worker2</span></code></pre></td></tr></table></div></figure>


<p>删除之后，Docker就会开始重新调度，最终调度结束（&lt; 1分钟）后，再查看该服务的任务状态，应该如下面这样，有5个 <code>nginx</code> 容器在剩下的两台机器上运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE          DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running 22 minutes  Running        manager1
</span><span class='line'>co0re9u7infoo9qiegm6yiqcn  nginx.2  nginx    nginx  Running 19 minutes  Running        worker1
</span><span class='line'>19dvayah8fjz3vykrl2oi12uu  nginx.3  nginx    nginx  Running 19 minutes  Running        worker1
</span><span class='line'>991v97eg9q1hnnzxda6c9mmv7  nginx.4  nginx    nginx  Running 20 seconds  Running        manager1
</span><span class='line'>e9yztfmy5luaxnadz80e5j8nl  nginx.5  nginx    nginx  Running 20 seconds  Running        manager1</span></code></pre></td></tr></table></div></figure>


<p>除了上面用到的一些命令， <code>docker service</code> 还有以下一些子命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service --help
</span><span class='line'>
</span><span class='line'>Usage:    docker service COMMAND
</span><span class='line'>
</span><span class='line'>Manage Docker services
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>      --help   Print usage
</span><span class='line'>
</span><span class='line'>Commands:
</span><span class='line'>  create      Create a new service
</span><span class='line'>  inspect     Inspect a service
</span><span class='line'>  tasks       List the tasks of a service
</span><span class='line'>  ls          List services
</span><span class='line'>  rm          Remove a service
</span><span class='line'>  scale       Scale one or multiple services
</span><span class='line'>  update      Update a service
</span><span class='line'>
</span><span class='line'>Run 'docker service COMMAND --help' for more information on a command.</span></code></pre></td></tr></table></div></figure>


<p>比如我们可以用 <code>docker service inspect</code> 来获得 <code>nginx</code> 服务的详情信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service inspect nginx
</span><span class='line'>[
</span><span class='line'>    {
</span><span class='line'>        "ID": "78cmmh8ef4qcwmjjzgn3k45ch",
</span><span class='line'>        "Version": {
</span><span class='line'>            "Index": 32
</span><span class='line'>        },
</span><span class='line'>        "CreatedAt": "2016-06-21T08:31:21.427244594Z",
</span><span class='line'>        "UpdatedAt": "2016-06-21T08:33:50.75625288Z",
</span><span class='line'>        "Spec": {
</span><span class='line'>            "Name": "nginx",
</span><span class='line'>            "TaskTemplate": {
</span><span class='line'>                "ContainerSpec": {
</span><span class='line'>                    "Image": "nginx"
</span><span class='line'>                },
</span><span class='line'>                "Resources": {
</span><span class='line'>                    "Limits": {},
</span><span class='line'>                    "Reservations": {}
</span><span class='line'>                },
</span><span class='line'>                "RestartPolicy": {
</span><span class='line'>                    "Condition": "any",
</span><span class='line'>                    "MaxAttempts": 0
</span><span class='line'>                },
</span><span class='line'>                "Placement": {}
</span><span class='line'>            },
</span><span class='line'>            "Mode": {
</span><span class='line'>                "Replicated": {
</span><span class='line'>                    "Replicas": 5
</span><span class='line'>                }
</span><span class='line'>            },
</span><span class='line'>            "UpdateConfig": {},
</span><span class='line'>            "Networks": [
</span><span class='line'>                {
</span><span class='line'>                    "Target": "8kiv8muduf60f66rs99ufo25f"
</span><span class='line'>                }
</span><span class='line'>            ],
</span><span class='line'>            "EndpointSpec": {
</span><span class='line'>                "Mode": "vip",
</span><span class='line'>                "Ports": [
</span><span class='line'>                    {
</span><span class='line'>                        "Protocol": "tcp",
</span><span class='line'>                        "TargetPort": 80,
</span><span class='line'>                        "PublishedPort": 80
</span><span class='line'>                    }
</span><span class='line'>                ]
</span><span class='line'>            }
</span><span class='line'>        },
</span><span class='line'>        "Endpoint": {
</span><span class='line'>            "Spec": {},
</span><span class='line'>            "Ports": [
</span><span class='line'>                {
</span><span class='line'>                    "Protocol": "tcp",
</span><span class='line'>                    "TargetPort": 80,
</span><span class='line'>                    "PublishedPort": 80
</span><span class='line'>                }
</span><span class='line'>            ],
</span><span class='line'>            "VirtualIPs": [
</span><span class='line'>                {
</span><span class='line'>                    "NetworkID": "e9et32s47olva4e0uisamdqao",
</span><span class='line'>                    "Addr": "10.255.0.6/16"
</span><span class='line'>                },
</span><span class='line'>                {
</span><span class='line'>                    "NetworkID": "8kiv8muduf60f66rs99ufo25f",
</span><span class='line'>                    "Addr": "10.0.0.2/24"
</span><span class='line'>                }
</span><span class='line'>            ]
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<p>也可以通过 <code>docker service rm nginx</code> 命令，删除 <code>nginx</code> 服务（现在的版本删除服务前没有警告提示，请小心操作）。</p>

<h2>总结</h2>

<p>上手很简单，Docker swarm可以非常方便的创建类似k8s那样带有副本的服务，确保一定数量的容器运行，保证服务的高可用。</p>

<p>然而，光从官方文档来说，功能似乎又有些简单，从生产环境来说，下面这些方面都还有所欠缺（其实从Swarm v1就有这个问题）：</p>

<ul>
<li>没有配置文件，不好进行版本化管理，不方便部署</li>
<li>持久存储的缺失。Docker已经支持Volume Driver，k8s等也有存储卷插件在机制，真正的生产环境没有Volume支持估计是很难想象的。</li>
<li>是否能确保本身的高可用</li>
<li>调度策略还处于初级阶段</li>
</ul>


<p>不过，正如Docker让容器技术变得平民化一样，Docker Machine和Swarm，也将在各种基础设施上运行Docker和Docker集群变得更加简单，从这一点上来说，其意义也是很大的。</p>

<p>不过在开源社区和商业竞争的角度来看，Docker Swarm将会走向何方呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年5月读书记录]]></title>
    <link href="http://liubin.org/blog/2016/06/18/05-reading/"/>
    <updated>2016-06-18T19:07:29+08:00</updated>
    <id>http://liubin.org/blog/2016/06/18/05-reading</id>
    <content type="html"><![CDATA[<p>5月读完的，大概只有一本。</p>

<h2>《途客圈创业记：不疯魔，不成活》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28482679.jpg" alt="途客圈创业记：不疯魔，不成活" /></p>

<p>推荐指数：★★★★★</p>

<p>和作者陈天有过一面之缘，还是在几年前国内第一次Docker Meetup，有幸和陈天同台分享了一下Docker方面的内容，我的偏向于原理介绍，他的更偏实战，很像他的风格。</p>

<p>这本书讲述了陈天自己从兴趣开始，如何自己写原型，参加demo day类似的活动，找合伙人、组建团队，找投资，做产品，涉及到了一个创意从想出点子，到实现、上线的过程。</p>

<p>如果你是初出道的创业者，刚只是有一些点子和想法而已，那么这本书绝对值得参考，前人的经验，能帮你避免犯一些没有必要的错误。</p>

<p>我个人有一些感触，这里列出几点简单介绍一下。</p>

<h3>管理团队</h3>

<p>管理团队很重要，以至于很多投资人的理念其实是投人、投团队，也就是人靠谱，给你钱干什么都行。</p>

<p>这方面主要问题是管理团队的构成、分工以及定位。在能力上最好是互补的，比如市场、销售、技术活产品等。</p>

<p>而定位很重要，本书作者的一大经验就是陈天作为创始人、大股东、产品负责人是事实上的核心，而CEO则有些被边缘化。所以说，每个人的定位要明确，一个萝卜一个坑，有什么事都能找到唯一一个、明确的负责人，员工有事了，知道什么事该找什么人。</p>

<p>一个公司如果对高层的分工都不明确，可以说是CEO没有从大局上来让公司员工能有一个统一的认识，没有明确的的定义出管理团队的架构。</p>

<p>项目也是，最烦一件事不知道找谁，每个人都想支一嘴。</p>

<h3>控制产品</h3>

<p>如果说99%的创业都会失败，我觉得其中90%的原因都是其产品并非“刚需”。你的刚需不一定是别人的刚需，产品还需要吃场和运营的验证。</p>

<p>这时候，又有一个词叫Pivot，愿意有“关键转折”或者“战略调整”的意思，在精益创业中一般指根据公司、产品的运营现状（尤其是运行出现问题或者出现重大机会，多指前者）时，改变公司的产品形式和方向、营销策略、公司战略等。</p>

<p>最简单的方法就是产品出来之后，根据用户和媒体的反响，以及各种运营数据来判断是否能达到预期，如果持续数据不太乐观，就必须要考虑产品的问题了。</p>

<p>第一版就抓到用户刚需，成为装机必备的软件，几率太低，多出产品都是通过不停的发布、反馈和调整来不断进行优化的。</p>

<p>在对产品进行调整时，即依赖于团队的能力、经验，坏的情况下，可能还会导致团队分歧、影响战斗力。</p>

<h3>控制节奏</h3>

<p>节奏包括产品的节奏，公司发展的规模等。不能太慢，互联网不是讲唯快不破么；也不能过快，繁华背后都会有隐忧，过快的发展可能会使危机不断地积蓄和发酵，大规模爆发时说不定会超出处理能力。</p>

<p>要有张有弛，控制节奏。就像跑马拉松，首先要上路，不能上来就找不到方向；其次要坚持，创业不是短跑，用尽全力会倒在强弩之末。</p>

<p>不过遗憾的是，途客圈没有完成下一轮融资，不得不被合并了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker 1.12.0将要发布的新功能]]></title>
    <link href="http://liubin.org/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0/"/>
    <updated>2016-06-17T18:27:03+08:00</updated>
    <id>http://liubin.org/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0</id>
    <content type="html"><![CDATA[<p>按计划，6/14 是1.12.0版本的 <a href="https://github.com/docker/docker/wiki">feature冻结</a> 的日子，再有两个星期Docker 1.12.0也该发布了。这里列出来的新功能，都是已经合并到主分支的功能，不出意外，下一个版本的Docker应该是能体验到了。</p>

<p>下周2016 DockerCon也该开始了，好像也有一场专门来讲Docker新特性的，不过在这之前，我们就可以抢先一步，浏览一下这些新功能、新特性。尤其是前两个，都是比较吸引人的功能。</p>

<h2>Swarmkit集成</h2>

<p>前几天Docker刚刚发布了 <a href="https://github.com/docker/swarmkit">Swarmkit</a> ，也就是Swarm V2。</p>

<p>同时，在这个版本的Docker中，Swarm/Swarmkit 相关命令也被整合到了Docker子命令中。这可能算得上是1.12.0版本中最大的变更点了。</p>

<p><a href="https://github.com/docker/docker/pull/23361">这个PR（Add dependency to docker/swarmkit）</a> 有600个文件变动。
除了传统的image和container对象，这个PR增加了task和service等资源类型。</p>

<p>相关几个子PR包括 <a href="https://github.com/docker/docker/pull/23362">23362</a> 、<a href="https://github.com/docker/docker/pull/23363">23363</a> 、 <a href="https://github.com/docker/docker/pull/23364">23364</a>。</p>

<p>使用新的Docker命令，可以这样直接创建Swarm集群：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker swarm init --listen-addr 192.168.99.100:2377
</span><span class='line'>Swarm initialized: current node (09fm6su6c24qn) is now a manager.</span></code></pre></td></tr></table></div></figure>


<p>查看节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker node ls
</span><span class='line'>ID              NAME      MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS  LEADER
</span><span class='line'>09fm6su6c24q *  manager1  Accepted    Ready   Active        Reachable       Yes</span></code></pre></td></tr></table></div></figure>


<p>然后这样来部署一个新的service：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service create --scale 1 --name helloworld alpine ping docker.com
</span><span class='line'>2zs4helqu64f3k3iuwywbk49w
</span><span class='line'>
</span><span class='line'>$ docker service ls
</span><span class='line'>ID            NAME        SCALE  IMAGE   COMMAND
</span><span class='line'>2zs4helqu64f  helloworld  1      alpine  ping docker.com</span></code></pre></td></tr></table></div></figure>


<p>需要scale了？没关系，也可以在Docker中直接完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service update --scale 5 helloworld
</span><span class='line'>helloworld
</span><span class='line'>
</span><span class='line'>$ docker service tasks helloworld
</span><span class='line'>ID                         NAME          SERVICE     IMAGE   DESIRED STATE  LAST STATE          NODE
</span><span class='line'>1n6wif51j0w840udalgw6hphg  helloworld.1  helloworld  alpine  RUNNING        RUNNING 2 minutes   manager1
</span><span class='line'>dfhsosk00wxfb7j0cazp3fmhy  helloworld.2  helloworld  alpine  RUNNING        RUNNING 15 seconds  worker2
</span><span class='line'>6cbedbeywo076zn54fnwc667a  helloworld.3  helloworld  alpine  RUNNING        RUNNING 15 seconds  worker1
</span><span class='line'>7w80cafrry7asls96lm2tmwkz  helloworld.4  helloworld  alpine  RUNNING        RUNNING 10 seconds  worker1
</span><span class='line'>bn67kh76crn6du22ve2enqg5j  helloworld.5  helloworld  alpine  RUNNING        RUNNING 10 seconds  manager1</span></code></pre></td></tr></table></div></figure>


<p>在一台机器上使用 <code>docker ps</code> :</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps
</span><span class='line'>
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span class='line'>910669d5e188        alpine:latest       "ping docker.com"   10 seconds ago      Up 10 seconds                           helloworld.5.bn67kh76crn6du22ve2enqg5j
</span><span class='line'>a0b6c02868ca        alpine:latest       "ping docker.com"   2 minutes  ago      Up 2 minutes                            helloworld.1.1n6wif51j0w840udalgw6hphg
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以这样使用 <code>dcoekr service</code> 子命令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service create --scale 3 --name redis --update-delay 10s --update-parallelism 1 redis:3.0.6
</span><span class='line'>
</span><span class='line'>69uh57k8o03jtqj9uvmteodbb
</span><span class='line'>$ docker service tasks redis
</span><span class='line'>ID                         NAME     SERVICE  IMAGE        LAST STATE          DESIRED STATE  NODE
</span><span class='line'>3wfqsgxecktpwoyj2zjcrcn4r  redis.1  redis    redis:3.0.6  RUNNING 13 minutes  RUNNING        worker2
</span><span class='line'>8lcm041z3v80w0gdkczbot0gg  redis.2  redis    redis:3.0.6  RUNNING 13 minutes  RUNNING        worker1
</span><span class='line'>d48skceeph9lkz4nbttig1z4a  redis.3  redis    redis:3.0.6  RUNNING 12 minutes  RUNNING        manager1</span></code></pre></td></tr></table></div></figure>


<p>总之，新的Docker和Swarm结合在一起，管理集群和服务将会更方便。</p>

<h2>插件管理（Plugin repository，experimental版）</h2>

<p>PR地址： <a href="https://github.com/docker/docker/pull/23446">https://github.com/docker/docker/pull/23446</a></p>

<p>插件管理功能可能算是第二大变更点了。很多软件都支持插件机制，大家比较熟悉的从Wordpress到ElasticSearch等，都支持在软件内部通过plugin功能安装、管理插件。</p>

<p>Docker最近也增加了一些网络和卷管理的插件功能，这次还在体验版中增加了插件（基于容器）管理功能，可以通过 <code>docker plugin</code> 命令来管理插件。除了提供了一个统一的插件管理入口，还可以对插件的生命周期进行更好的管理，Docker君，我的插件写的比较不专业，请罩着我点。</p>

<p>这是一个大概的使用示意，通过 <code>docker plugin install</code> 可以安装插件， <code>docker plugin ls</code> 可以列出当前安装的插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker plugin install aragunathan/no-remove
</span><span class='line'>Plugin "aragunathan/no-remove:latest" requested the following privileges:
</span><span class='line'> - Networking: host
</span><span class='line'> - Mounting host path: /data
</span><span class='line'>Do you grant the above permissions? [y/N] y</span></code></pre></td></tr></table></div></figure>


<p>查看插件列表：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker plugin ls
</span><span class='line'>NAME                    VERSION             ACTIVE
</span><span class='line'>aragunathan/no-remove   latest              true</span></code></pre></td></tr></table></div></figure>


<p>目前 <code>docker plugin</code> 支持如下子命令：</p>

<ul>
<li>plugin ls</li>
<li>plugin enable</li>
<li>plugin inspect</li>
<li>plugin install</li>
<li>plugin rm</li>
</ul>


<h2>增加 <code>overlay2</code> 存储驱动（PR#22126 Overlay multiple lower directory support）</h2>

<p><a href="https://github.com/docker/docker/pull/22126">这个PR</a> 增加一个新的名为 <code>overlay2</code> 的驱动，以解决Docker在存储优化方面的不足，充分利用4.0内核的 <code>lower directories</code> 新特性，解决inode耗尽等问题。</p>

<p>这个PR中的描述也提到了新旧overlay驱动的性能对比数据，有兴趣的可以参考一下。</p>

<h2>Live restore</h2>

<p><a href="https://github.com/docker/docker/pull/23213">这个PR</a> 最大的好处就是提供了对daemonless容器的支持，即使daemon宕了，容器也不会受影响。</p>

<p>使用方法就是在启动 <code>dockerd</code> 的时候，增加 <code>--live-restore</code> 标志。</p>

<p>你是不是特别喜欢这个功能？</p>

<h2>Healthcheck</h2>

<p><code>docker run</code> 和 <code>Dockerfile</code> 新增加的 <a href="https://github.com/docker/docker/pull/23218">健康检查功能</a>。</p>

<p>比如在 <code>docker run</code> 中，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker run --name=test -d \
</span><span class='line'>    --health-cmd='stat /etc/passwd || exit 1' \
</span><span class='line'>    --health-interval=2s \
</span><span class='line'>    busybox sleep 1d</span></code></pre></td></tr></table></div></figure>


<p>查看健康状态，返回 <code>healthy</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sleep 2; docker inspect --format='' test
</span><span class='line'>healthy</span></code></pre></td></tr></table></div></figure>


<p>故意删除 <code>/etc/passwd</code> 文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker exec test rm /etc/passwd</span></code></pre></td></tr></table></div></figure>


<p>再次查看节点健康状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sleep 2; docker inspect --format='' test
</span><span class='line'>{
</span><span class='line'>  "Status": "unhealthy",
</span><span class='line'>  "FailingStreak": 3,
</span><span class='line'>  "Log": [
</span><span class='line'>    {
</span><span class='line'>      "Start": "2016-05-25T17:22:04.635478668Z",
</span><span class='line'>      "End": "2016-05-25T17:22:04.7272552Z",
</span><span class='line'>      "ExitCode": 0,
</span><span class='line'>      "Output": "  File: /etc/passwd\n  Size: 334       \tBlocks: 8          IO Block: 4096   regular file\nDevice: 32h/50d\tInode: 12          Links: 1\nAccess: (0664/-rw-rw-r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2015-12-05 22:05:32.000000000\nModify: 2015..."
</span><span class='line'>    },
</span><span class='line'>    {
</span><span class='line'>      "Start": "2016-05-25T17:22:06.732900633Z",
</span><span class='line'>      "End": "2016-05-25T17:22:06.822168935Z",
</span><span class='line'>      "ExitCode": 0,
</span><span class='line'>      "Output": "  File: /etc/passwd\n  Size: 334       \tBlocks: 8          IO Block: 4096   regular file\nDevice: 32h/50d\tInode: 12          Links: 1\nAccess: (0664/-rw-rw-r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2015-12-05 22:05:32.000000000\nModify: 2015..."
</span><span class='line'>    },
</span><span class='line'>    {
</span><span class='line'>      "Start": "2016-05-25T17:22:08.823956535Z",
</span><span class='line'>      "End": "2016-05-25T17:22:08.897359124Z",
</span><span class='line'>      "ExitCode": 1,
</span><span class='line'>      "Output": "stat: can't stat '/etc/passwd': No such file or directory\n"
</span><span class='line'>    }
</span><span class='line'>  ]
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h2>其他改进</h2>

<p>除了上述能单独拿出来的，要么比较重量级，要么非常实用的功能，Docker还有很多其他方面的改进。这里我们简单看看其中的一些。</p>

<h3><code>dockerd</code> 和 <code>docker</code> 二进制文件分离</h3>

<p><code>docker daemon</code> 改为了 <code>dockerd</code> ，这样以后就需要使用两个可执行程序了。</p>

<p>PR： <a href="https://github.com/docker/docker/pull/22386">https://github.com/docker/docker/pull/22386</a></p>

<h3>为 <code>btrfs</code> 存储驱动增加容器 <code>rootfs</code> 的限额功能</h3>

<p>类似这样，可以在Docker守护进程或者容器级别设置根文件系统的大小：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker daemon --storage-opt btrfs.min_space=xx
</span><span class='line'>$ docker run --storage-opt size=xx</span></code></pre></td></tr></table></div></figure>


<p>PR1：<a href="https://github.com/docker/docker/pull/19651">https://github.com/docker/docker/pull/19651</a>
PR2：<a href="https://github.com/docker/docker/pull/19367">https://github.com/docker/docker/pull/19367</a></p>

<h3><code>docker search</code> 增加 <code>--limit</code> 和 <code>filter</code> 参数</h3>

<ul>
<li><code>--limit</code> 参数</li>
</ul>


<p><code>docker search</code> 命令增加了一个 <code>--limit</code> 参数，可以设置查找镜像的返回结果个数。这个参数的默认值为25，可以接受的范围是0-100（实际上好像服务端最多只能返回100条记录）。</p>

<p>PR：<a href="https://github.com/docker/docker/pull/23107">https://github.com/docker/docker/pull/23107</a></p>

<ul>
<li><code>--filter</code> 参数</li>
</ul>


<p>比如可以指定只返回官方镜像，或者返回一定数量star的镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker search --filter is-official=true ubuntu
</span><span class='line'>
</span><span class='line'>$ docker search --filter stars=30 ubuntu
</span></code></pre></td></tr></table></div></figure>


<p>PR：<a href="https://github.com/docker/docker/pull/22369">https://github.com/docker/docker/pull/22369</a></p>

<h3><code>docker ps</code> 命令增加 <code>--filter network=xxx</code>参数</h3>

<p>只列出指定网络模式的容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker run -d --net=bridge --name=onbridgenetwork busybox top
</span><span class='line'>$ docker run -d --net=none --name=onnonenetwork busybox top
</span><span class='line'>
</span><span class='line'>$ docker ps --filter network=bridge </span></code></pre></td></tr></table></div></figure>


<p>PR： <a href="https://github.com/docker/docker/pull/23300">https://github.com/docker/docker/pull/23300</a></p>

<h3><code>pid</code> 支持指定其他容器的pid</h3>

<p>在之前的版本中，<code>pid</code> 参数只支持 <code>host</code> 模式，现在也可以和其他容器共享PID命名空间了。这也可能是一个比较实用的功能。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker run --name my-redis -d redis
</span><span class='line'>
</span><span class='line'>$ # 在其他容器中使用strace进行调试
</span><span class='line'>
</span><span class='line'>$ docker run --it --pid=container:my-redis bash
</span><span class='line'>$ strace -p 1</span></code></pre></td></tr></table></div></figure>


<p>PR： <a href="https://github.com/docker/docker/pull/22481">https://github.com/docker/docker/pull/22481</a></p>

<h3><code>docker network ls</code> 新增了两种过滤类型</h3>

<p><code>docker network ls</code> 也增加了两种类型的过滤</p>

<ul>
<li>按驱动类型过滤</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker network ls --filter driver=bridge
</span><span class='line'>NETWORK ID          NAME                DRIVER
</span><span class='line'>db9db329f835        test1               bridge
</span><span class='line'>f6e212da9dfd        test2               bridge</span></code></pre></td></tr></table></div></figure>


<p>PR： <a href="https://github.com/docker/docker/pull/22319">https://github.com/docker/docker/pull/22319</a></p>

<ul>
<li>按label过滤</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker network ls -f "label=usage"
</span><span class='line'>NETWORK ID          NAME                DRIVER
</span><span class='line'>db9db329f835        test1               bridge              
</span><span class='line'>f6e212da9dfd        test2               bridge</span></code></pre></td></tr></table></div></figure>


<p>PR: <a href="https://github.com/docker/docker/pull/21495">https://github.com/docker/docker/pull/21495</a></p>

<h3>CLI子命令重构</h3>

<p>很多Docker 子命令都采用 <a href="https://github.com/spf13/cobra">cobra</a> 对CLI进行了重构，应该不算是什么大的改动。</p>

<h2>总结</h2>

<p>当然，还有类似小的一些改进，这里并没有都列出来，到时候大家看一下参考手册就能见到了，也许很多功能大家根本就不会用到：-）</p>

<p>到这里我们简单的就浏览了一下新版本的Docker中将会搭载的新功能，如果你觉得哪些是你想要的，就等着Docker 1.12.0的发布吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年4月读书记录]]></title>
    <link href="http://liubin.org/blog/2016/05/26/04-reading/"/>
    <updated>2016-05-26T23:13:27+08:00</updated>
    <id>http://liubin.org/blog/2016/05/26/04-reading</id>
    <content type="html"><![CDATA[<p>这两个月效率非常低，也没什么兴致。4月读的书不多，总结也拖到了5月底，最近私事较多，希望6越以后能好转，至少可以不用为别的事分心。</p>

<p>4月读了3本书，2本电子书，1本纸版。</p>

<p>其中一本《HBase in action》的中文版，这是人邮异步社区送的电子版，在Kindle阅读器上读的，效果不是特别理想，这种书，还是得买纸版，或者在电脑的Kindle软件上才好吧。</p>

<p>另外有两本非技术书，一本是《互联网运营之道》，一本是《共享经济：互联网时代如何实现股东、员工与顾客的共赢》</p>

<h2>《HBase实战》</h2>

<p><img src="https://img3.doubanio.com/lpic/s27020560.jpg" alt="HBase实战" /></p>

<p>推荐指数：★★★★</p>

<p>这个是计算机书籍，讲的HBase的方方面面，从原理入门到线上运维和实际环境的配置等都有涉及，非常适合入门HBase。</p>

<p>从英文名字也可以看出，In Action系列一般来说都是非常值得信赖的。</p>

<h2>《共享经济：互联网时代如何实现股东、员工与顾客的共赢》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28024129.jpg" alt="互联网运营之道" /></p>

<p>推荐指数：★★★★★</p>

<p>媒介：Kindle</p>

<p>这本书是误打误撞读到的。本来是想看看和共享经济相关的书，但被本书的标题迷惑了，实际副标题更体现了本书的主要思想，那就是如何通过信任来实现股东、员工与顾客的共赢。</p>

<p>本书的核心，就是围绕着信任两字来讲的。</p>

<p>随着社会和科技的进步，透明度也会提高，加强了人和人之间的互动，真正的实现了“坏事传千里”。随着人们之间的交往越来越高效，信任也正在逐渐成为人类文化的一个根本属性，如果按照传统的思维，企业提供高质量的产品，完善的售后，不一定就能在竞争中利于不败之地，而是需要一种全新的方式，体现自己的“值得信赖”。</p>

<p>书中举了很多例子来说明，如何让客户觉得企业可信，是站在自己的这一边的。</p>

<blockquote><p>我的一个朋友托马斯在网上订购了一套三件组合的桌子，其中两件顺利到货，但是第三件一星期之后还没送到。于是，托马斯打电话到公司询问，结果发现第三件被快递公司送错了地方，发到了另外一个配送中心，商品被送到了其他城市。在线零售客服很快解决了这个问题：“先生，发生这样的状况我们很抱歉。我们马上为您更换货物，用连夜快递为您配送剩下的一件，这样您明天就能收到货物。”我的朋友本来打算大发牢骚，但是客服及时地解决了问题，一下子让我的朋友心情缓和下来。当客服说“由于我们给您带来的不便，我们将会向您的信用卡返还25美元”时，我的朋友说这不是零售商的错，而是物流公司的错。客服说：“请您别担心，我们只是想确保您明天能够在您的新办公桌前办公。”这样的服务算是好的客户服务吗？这说明这家公司有良好的意图，还是有能力？谁在意呢？反正这样的公司就是人们能依靠的公司。这样的公司是完全值得人们依赖的公司。</p>

<p>无数研究表明，医疗事故投诉的最大导火索不是医生的技术，而是他们对病人的态度。不管医生的技术如何，病人们是不会控告那些被他们当作朋友的、具有同理心的医务人员的。但是，一旦医生（或公司）没能与病人建立友好的关系，或者没能表现出同理心，和他们相处时没有展示出“人性的面孔”，那么他们很可能就会遭到更多的投诉。</p>

<p>我们的房地产经纪人卡伦·凯利（Karen Kelly）是柯克兰集团（Corcoran Group）的，她带我们用几天时间看了40套公寓。最后当我们把选择的范围缩小到3套公寓时，我们突然接到一个朋友的电话，说他正在帮业主卖一套传统的合作公寓20。于是我们打电话给卡伦，问她该怎么做。她建议我们先去看看那套公寓，我们去后发现那套公寓非常不错。尽管卡伦从中得不到半分佣金，但她却带着很多有用的资料——包括建筑的历史、维修记录以及纳税信息，赶到我们这边。后来我们坚持要把这套公寓当作是她负责的，付给她买方应付的费用。因为即便她从这笔交易当中赚不到钱，她还是希望我们能够买到合适的公寓。从那以后，我们介绍了好几个人给她，包括买主和卖主。能帮我们的朋友在曼哈顿找到一个真正可以信任的房地产经纪人，我们会觉得自己为朋友帮上了忙。同时，我们当然也很希望看到卡伦获得成功！</p>

<p>一个值得依赖的汽车品牌会在保修期到期30天前给你发邮件或者打电话，这样一来，如果你有任何需要维修的地方，都能趁着保修期内及时地得到维修。</p></blockquote>

<p>还有几个例子，也很有趣，我忘了作者是要说明什么问题来着：</p>

<blockquote><p>在统计推理存在问题的案例当中，最臭名昭著的案例之一要数辛普森杀妻案。诉讼方认为，由于辛普森在过去经常对妻子妮可·辛普森实施暴力，所以他非常有可能谋杀了妻子。辩护律师轻易地推翻了这个论点，告诉陪审团说，上一年遭受丈夫家庭暴力的女性有400万，但是每2500人当中只有1人真正遭到谋杀。这一论点在当时显得非常具有说服力，无法驳倒，反映了诉讼方完全缺乏统计方面的知识（新闻媒体、法律评论员以及其他人在案件的展开过程中，评估案件时都反映出了同样的问题）。不论你对最后的裁决持什么样的观点，要是诉讼方当时指出另一项相关性更大的统计数据，案件的结果可能就不一样了。这项统计就是：上一年所有被丈夫殴打后又被谋杀的女性当中，90%都是被实施家暴的丈夫杀害的。</p>

<p>20世纪70年代，西班牙一名男子特意挑选了一张尾数为48的彩票，结果中奖了。他得意洋洋地告诉别人自己的“策略”，说：“我连续7天都梦到7这个数字，7乘以7就是48。”</p></blockquote>

<p>作者也认为企业应该抛弃“控制”，因为复杂系统没有自然科学那样的规律性和可预测性，尤其是不可预测的反馈系统：“跟推陀螺一样，如果你试图控制某个系统的行为，就很有可能失败，因为系统的反馈回路会产生意想不到的效果”。放弃控制，说到底就是要信任他人，并帮助他们相信你。如果希望你的员工对工作真正投入，你就必须准备好放弃一部分控制，相信他们能够把事情做好。</p>

<p>当然，本书也不是完全和共享无关。作者认为，随着社会的进步，人们更愿意和别人分享自己的知识和经验，更愿意与人交流，形成所谓的“社交经济”：不以经济目标为主，而是为了获得尊重、个人价值、社会地位和满足感等等非经济“利益”。这就是一种共享的文化，共享知识和数据，并享受这个过程。</p>

<p>企业必须积极关注顾客利益，甚至比顾客还关注顾客利益，才能真正的“俘获人心”，获得顾客的深度信任。企业也应该做到透明，而技术的进步也让社会更透明，“纸里包不住火”，该暴露的丑闻早晚大白于天下，如果<strong>顾客都不相信你，撒谎将没有任何意义</strong>。</p>

<p>企业也应该真诚的暴露自己的问题和缺点，没有完美的公司，如果你可以隐藏缺点，只是一味的吹嘘自己的有点，顾客就会认为企业一定在刻意隐瞒什么。有时候，为了赢得别人的信任，学会暴露自己的缺点很重要。</p>

<p>总之，真本书还是非常推荐读一下的，如果你真的是把客户当“上帝”的话。</p>

<h2>《互联网运营之道》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28363838.jpg" alt="互联网运营之道" /></p>

<p>推荐指数：★★★☆☆</p>

<p>媒介：纸版</p>

<p>看书的介绍作者背景很不错，作者来自新浪，目前就职于创新工场。众所周知新浪微博的成功和他们的运营分不开，从一定程度上来说也可以认为是微博也是运营驱动的产品。</p>

<p>但拿到此书之后觉得有点亏，满打满算才190页，定价49，有点小贵，让我觉得有点哗众取宠想趁着风口多骗一些╭︿︿︿╮ {/ o  o /}   ( (oo) )     ︶︶︶。</p>

<p>其次是内容也不太实用。确实，运营这个事，如果看案例非常有意思，但是如果拿出一个让人信服，外行看了点头赞叹“原来如此”的系统化、理论化的原则原理或者方案，还是比较难的。每个公司都有不同的组织形式，工作流程和分工协作，别人的方式当然不能拿来直接用。</p>

<p>当然本书也不是一无是处，比如作者提到“目标用户是贯穿整个工作流程的主线”、“与其研究流式的的用户，不如研究活跃的用户”，通过本书，我才知道原来运营可以细分为内容运营、活动运营和用户运营（题外话：也有人建议将技术系的运维改为“技术运营”，仔细想想也有一定道理）。</p>

<p>通过本书，我的一个感想就是想清楚你的用户是谁，他们要干什么，然后围绕这两点，进行全方位的运营。</p>

<h2>这届初夏不行</h2>

<p>今年春末夏初，出了几件大事，不同类型、地区，基本都涉及到了人的安全问题，而且出现时机衔接如此紧密，这也是导致我分心的原因，所以整个4、5月都是在浑浑噩噩中度过。</p>

<p>想想4月的阅读情况，再想想现在已经是5月底，不知道如何清除初夏带来的心魔。</p>
]]></content>
  </entry>
  
</feed>
