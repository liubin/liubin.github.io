<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[自言自语]]></title>
  <link href="http://liubin.github.io/atom.xml" rel="self"/>
  <link href="http://liubin.github.io/"/>
  <updated>2018-04-28T08:04:35+08:00</updated>
  <id>http://liubin.github.io/</id>
  <author>
    <name><![CDATA[bin liu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[向 Kubernetes 学习 - Controller manager 的高可用实现方式]]></title>
    <link href="http://liubin.github.io/blog/2018/04/28/how-to-build-controller-manager-high-available/"/>
    <updated>2018-04-28T19:04:56+08:00</updated>
    <id>http://liubin.github.io/blog/2018/04/28/how-to-build-controller-manager-high-available</id>
    <content type="html"><![CDATA[<p>这不是一系列入门级别的文章，也不是按部就班而来的，而是我看到哪里，发现有些代码写的精妙的地方，都值得我们学习下，顺手记录下来，一方面是让自己将来可以有迹可循，另外对大家应该也会有所帮助。而且记录本身成本并不是很高。</p>

<p>高可用部署情况下，需要部署多个controller manager （以下简称 cm ），每个 cm 需要 <code>--leader-elect=true</code> 启动参数，即告知 cm 以高可用方式启动，谁要想进行真正的工作，必须先抢到锁，被选举为 leader 才行，而抢不到所得只能待机，在 leader 因为异常终止的时候，由剩余的其余节点再次获得锁。</p>

<p>关于分布式锁的实现很多，可以自己从零开始制造。当然更简单的是基于现有中间件，比如有基于 Redis 或数据库的实现方式，最近 Zookeeper/ETCD 也提供了相关功能。但 K8s 的实现并没有使用这些方式，而是另辟蹊径使用了资源锁的概念，简单来说就是通过创建 K8s 的资源（当前的实现中实现了 ConfigMap 和 Endpoint 两种类型的资源）来维护锁的状态。</p>

<p>分布式锁一般实现原理就是大家先去抢锁，抢到的人成为 leader ，然后 leader 会定期更新锁的状态，声明自己的活动状态，不让其他人把锁抢走。K8s 的资源锁也类似，抢到锁的节点会将自己的标记（目前是hostname）设为锁的持有者，其他人则需要通过对比锁的更新时间和持有者来判断自己是否能成为新的 leader ，而 leader 则可以通过更新 <code>RenewTime</code> 来确保持续保有该锁。</p>

<p>大概看了下 K8s 的实现，老实说其实现方式并不算高雅，但是却给我们开拓了一种思路：K8s 里的 resource 是万能的，不要以为 Endpoint 只是 Endpoint 。不过反过来有时候也挺让人费解的，刚了解的时候容易摸不着头脑，也不是好事。而且 scheduler 和 cm 都采用了资源锁，但是实现起来却不尽相同，也值得吐槽下。不管怎么说，这个实现算是挺有意思的实现，值得我们深入了解下。</p>

<p>我们首先来看一下 cm 启动的时候，是如何去 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/cmd/kube-controller-manager/app/controllermanager.go#L184-L208">初始化</a> 抢锁的。启动的时候，如果指定了 <code>--leader-elect=true</code> 参数的话，则会进入下面的代码，首先获取自己的资源标志（这里是 hostname 加一串随机数字）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Hostname</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// add a uniquifier so that two processes on the same host don&#39;t accidentally both become active</span>
</span><span class='line'><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">uuid</span><span class="p">.</span><span class="nx">NewUUID</span><span class="p">())</span>
</span><span class='line'><span class="nx">rl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">resourcelock</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">ResourceLock</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&quot;kube-system&quot;</span><span class="p">,</span>                                 <span class="c1">// 该资源所在 Namespace</span>
</span><span class='line'>  <span class="s">&quot;kube-controller-manager&quot;</span><span class="p">,</span>                     <span class="c1">// 资源名称</span>
</span><span class='line'>  <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">LeaderElectionClient</span><span class="p">.</span><span class="nx">CoreV1</span><span class="p">(),</span>
</span><span class='line'>  <span class="nx">resourcelock</span><span class="p">.</span><span class="nx">ResourceLockConfig</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">Identity</span><span class="p">:</span>      <span class="nx">id</span><span class="p">,</span>                         <span class="c1">// 锁持有者标志</span>
</span><span class='line'>      <span class="nx">EventRecorder</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">EventRecorder</span><span class="p">,</span>
</span><span class='line'>  <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面创建资源锁的代码说明请参考文中中文注释。</p>

<p>之后，在下面的代码中，资源锁，即上面的 rl（resource lock） 变量，被用于进行 leader 选举。具体的说明也嵌入在了下面的代码中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">leaderelection</span><span class="p">.</span><span class="nx">RunOrDie</span><span class="p">(</span><span class="nx">leaderelection</span><span class="p">.</span><span class="nx">LeaderElectionConfig</span><span class="p">{</span>
</span><span class='line'>  <span class="nx">Lock</span><span class="p">:</span>          <span class="nx">rl</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">// 下面 3 个参数是一些重时间，租赁期间等的设置，不是很重要</span>
</span><span class='line'>  <span class="nx">LeaseDuration</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">LeaseDuration</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">RenewDeadline</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">RenewDeadline</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">RetryPeriod</span><span class="p">:</span>   <span class="nx">c</span><span class="p">.</span><span class="nx">Generic</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">GenericComponent</span><span class="p">.</span><span class="nx">LeaderElection</span><span class="p">.</span><span class="nx">RetryPeriod</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">Callbacks</span><span class="p">:</span> <span class="nx">leaderelection</span><span class="p">.</span><span class="nx">LeaderCallbacks</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">OnStartedLeading</span><span class="p">:</span> <span class="nx">run</span><span class="p">,</span>                   <span class="c1">// cm 的主要工作函数</span>
</span><span class='line'>      <span class="nx">OnStoppedLeading</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;leaderelection lost&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们再来看看 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L85-L103">LeaderElectionConfig</a> 的内容，说明见注释（其实就是将代码的英文翻译过来而已）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">type</span> <span class="nx">LeaderElectionConfig</span> <span class="kd">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 资源锁的实现对象</span>
</span><span class='line'>  <span class="nx">Lock</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">Interface</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 是非 leader 在获取锁之前需要检查 leader 过期的时间</span>
</span><span class='line'>  <span class="nx">LeaseDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 当前 leader 尝试更新锁状态的期限。</span>
</span><span class='line'>  <span class="nx">RenewDeadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 抢锁时尝试间隔</span>
</span><span class='line'>  <span class="nx">RetryPeriod</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 锁状态发生变化的时候，需要进行处理的一组回调函数</span>
</span><span class='line'>  <span class="nx">Callbacks</span> <span class="nx">LeaderCallbacks</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L110-L119">Callbacks</a> 具体如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">Callbacks</span><span class="p">:</span> <span class="nx">leaderelection</span><span class="p">.</span><span class="nx">LeaderCallbacks</span><span class="p">{</span>
</span><span class='line'>  <span class="nx">OnStartedLeading</span><span class="p">:</span> <span class="nx">run</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">OnStoppedLeading</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;leaderelection lost&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">},</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，在获取锁（成为leader，<code>OnStartedLeading</code>）之后，将会执行 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/cmd/kube-controller-manager/app/controllermanager.go#L137"><code>run</code></a> 方法，在失去锁（<code>OnStoppedLeading</code>）之后打印错误消息后退出。<code>run</code> 方法是 cm 的主要方法，和抢锁选主流程没什么关系，这里就不介绍了。</p>

<p>下面的 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go#L37-L43">LeaderElectionRecord</a> 结构，保存了锁的信息，包括持有者（的hostname），获取时间，更新时间，leader 切换次数等（<code>LeaseDurationSeconds</code> 虽然定义了，但是并没有使用的感觉）。</p>

<p>这个结构可以说是资源锁中最重要的信息了，大家一定先混个脸熟，多念几遍 struct 的名字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// LeaderElectionRecord is the record that is stored in the leader election annotation.</span>
</span><span class='line'><span class="c1">// This information should be used for observational purposes only and could be replaced</span>
</span><span class='line'><span class="c1">// with a random string (e.g. UUID) with only slight modification of this code.</span>
</span><span class='line'><span class="kd">type</span> <span class="nx">LeaderElectionRecord</span> <span class="kd">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">HolderIdentity</span>       <span class="kt">string</span>      <span class="s">`json:&quot;holderIdentity&quot;`</span>
</span><span class='line'>  <span class="nx">LeaseDurationSeconds</span> <span class="kt">int</span>         <span class="s">`json:&quot;leaseDurationSeconds&quot;`</span>
</span><span class='line'>  <span class="nx">AcquireTime</span>          <span class="nx">metav1</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`json:&quot;acquireTime&quot;`</span>
</span><span class='line'>  <span class="nx">RenewTime</span>            <span class="nx">metav1</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`json:&quot;renewTime&quot;`</span>
</span><span class='line'>  <span class="nx">LeaderTransitions</span>    <span class="kt">int</span>         <span class="s">`json:&quot;leaderTransitions&quot;`</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个锁信息，就是存在 K8s 的 ConfigMap 或者 Endpoint 里面的，当然，存哪里可能大家已经想到了，只能存 annotation 里面，该 annotation 的 key 就是 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go#L28"><code>control-plane.alpha.kubernetes.io/leader</code></a> 。</p>

<p>到这里总结一下就是：LeaderElectionRecord 用于保存锁的信息，但是这一信息会以 annotation 的方式，保存到 k8s 的 ConfigMap 或者 Endpoint 等资源里面。</p>

<p>下面我们来看一下资源锁的实现。</p>

<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go#L57-L76">资源锁接口</a> 的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">Get</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">LeaderElectionRecord</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">Create</span><span class="p">(</span><span class="nx">ler</span> <span class="nx">LeaderElectionRecord</span><span class="p">)</span> <span class="kt">error</span>
</span><span class='line'>  <span class="nx">Update</span><span class="p">(</span><span class="nx">ler</span> <span class="nx">LeaderElectionRecord</span><span class="p">)</span> <span class="kt">error</span>
</span><span class='line'>  <span class="nx">RecordEvent</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">Identity</span><span class="p">()</span> <span class="kt">string</span>
</span><span class='line'>  <span class="nx">Describe</span><span class="p">()</span> <span class="kt">string</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>基本实现了 CRUD 几个方法，当然这里没有 D ，即 Delete，因为也没必要 Delete， 下一次抢锁的时候，抢到的 Leader 直接 Update 就可以了。</p>

<p>关键的方法我们看前 3 个就够了： Get 用于获取锁的最新信息，Update 用于更新，Create 用于创建资源锁对象，估计对大多数集群来说，只有第一次的时候才会调用 Create 创建这个对象。RecordEvent 也可以关注下，这个 event 属于锁资源，里面会记录 leader 切换等事件。</p>

<p>这里我们以 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/endpointslock.go#L39">Endpoint</a> 为例（这也是默认的资源锁类型，该参数可以通过 <code>leader-elect-resource-lock</code> 来设置），来看看资源锁的具体实现。</p>

<p>下面的代码省略了对 error 的检查，你懂得。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// Get returns the election record from a Endpoints Annotation</span>
</span><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">el</span> <span class="o">*</span><span class="nx">EndpointsLock</span><span class="p">)</span> <span class="nx">Get</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">LeaderElectionRecord</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">record</span> <span class="nx">LeaderElectionRecord</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span><span class='line'>  <span class="c1">// el.e 就是一个正经的 Endpoint 资源对象。</span>
</span><span class='line'>  <span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Client</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nx">Get</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">GetOptions</span><span class="p">{})</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 去获取 control-plane.alpha.kubernetes.io/leader annotation。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">recordBytes</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">Annotations</span><span class="p">[</span><span class="nx">LeaderElectionRecordAnnotationKey</span><span class="p">];</span> <span class="nx">found</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">recordBytes</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">record</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">record</span><span class="p">,</span> <span class="kc">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/endpointslock.go#L58">Create</a> 也很简单，就是一个普通的 Endpoint 对象，加上锁专用的 annotation ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Client</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nx">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">{</span>
</span><span class='line'>  <span class="nx">ObjectMeta</span><span class="p">:</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">ObjectMeta</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">Name</span><span class="p">:</span>      <span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">Namespace</span><span class="p">:</span> <span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">Annotations</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span><span class='line'>          <span class="nx">LeaderElectionRecordAnnotationKey</span><span class="p">:</span> <span class="nb">string</span><span class="p">(</span><span class="nx">recordBytes</span><span class="p">),</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/endpointslock.go#L76">更新方法</a> 的主体如下，将 <code>LeaderElectionRecord</code> 结构的对象序列化为字符串后，存到 annotation：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">Annotations</span><span class="p">[</span><span class="nx">LeaderElectionRecordAnnotationKey</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">recordBytes</span><span class="p">)</span>
</span><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Client</span><span class="p">.</span><span class="nx">Endpoints</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">EndpointsMeta</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nx">Update</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">e</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的方法，我们应该已经了解到了，锁的实现主要载体是 LeaderElectionRecord 对象，其实我们完全可以自己实现其他类型的资源锁了，比如基于 Secret ，不过好像也没啥意义。</p>

<p>介绍了上面的实现基础，我们最后来看看抢锁及使用锁的过程，<a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L138-L148">主要的入口</a> 如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// Run starts the leader election loop</span>
</span><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">Run</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 先去抢锁，阻塞操作</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">acquire</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span><span class='line'>  <span class="c1">// 抢到锁后，执行主函数，就是我们前面提到的 run 函数，通过 Callbacks.OnStartedLeading 回调启动</span>
</span><span class='line'>  <span class="k">go</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Callbacks</span><span class="p">.</span><span class="nx">OnStartedLeading</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">// 抢到锁后，需要定期更新，确保自己一直持有该锁</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">renew</span><span class="p">()</span>
</span><span class='line'>  <span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，里面主要调用了两个方法： <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L172-L187"><code>acquire</code></a> 和 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L190-L206"><code>renew</code></a> 。</p>

<p>我们先来看看 <code>acquire</code> 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">acquire</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span><span class='line'>  <span class="nx">wait</span><span class="p">.</span><span class="nx">JitterUntil</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">succeeded</span> <span class="o">:=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">tryAcquireOrRenew</span><span class="p">()</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">maybeReportTransition</span><span class="p">()</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">!</span><span class="nx">succeeded</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;failed to acquire lease %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">RecordEvent</span><span class="p">(</span><span class="s">&quot;became leader&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;successfully acquired lease %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
</span><span class='line'>      <span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="p">},</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">RetryPeriod</span><span class="p">,</span> <span class="nx">JitterFactor</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现也很短，这个函数会通过 <code>wait.JitterUntil</code> 来定期调用 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L211-L264"><code>tryAcquireOrRenew</code> 方法</a> 来获取锁，直到成功为止，如果获取不到锁，则会以 <code>RetryPeriod</code> 为间隔不断尝试。如果获取到锁，就会关闭 stop 通道（ <code>close(stop)</code> ），通知 <code>wait.JitterUntil</code> 停止尝试。<code>tryAcquireOrRenew</code> 是最核心的方法，我们会在介绍完 <code>renew</code> 方法之后再进行介绍。</p>

<p><code>renew</code> 只有在获取锁之后才会调用，它会通过持续更新资源锁的数据，来确保继续持有已获得的锁，保持自己的 leader 状态。这里还是用到了很多 <code>wait</code> 包里的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">renew</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span><span class='line'>  <span class="nx">wait</span><span class="p">.</span><span class="nx">Until</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wait</span><span class="p">.</span><span class="nx">Poll</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">RetryPeriod</span><span class="p">,</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">RenewDeadline</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nx">le</span><span class="p">.</span><span class="nx">tryAcquireOrRenew</span><span class="p">(),</span> <span class="kc">nil</span>
</span><span class='line'>      <span class="p">})</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">maybeReportTransition</span><span class="p">()</span>
</span><span class='line'>      <span class="nx">desc</span> <span class="o">:=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Describe</span><span class="p">()</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;successfully renewed lease %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">RecordEvent</span><span class="p">(</span><span class="s">&quot;stopped leading&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;failed to renew lease %v: %v&quot;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>      <span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="p">},</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的精妙之处在于，<code>wait.Until</code> 会不断的调用 <code>wait.Poll</code> 方法，前者是进行无限循环操作，直到 <code>stop</code> chan 被关闭，<code>wait.Poll</code>则不断的对某一条件进行检查，以 <code>RetryPeriod</code> 为间隔，直到该条件返回true、error或者超时（上面的 RenewDeadline 参数）。这一条件是一个需要满足 <code>func() (bool, error)</code> 签名的方法，比如这个例子很简单，只是调用了 <code>le.tryAcquireOrRenew()</code>。</p>

<p><code>tryAcquireOrRenew</code> 方法本身不是一个阻塞操作，只返回 true/false，对应为获取到锁和没有获取到锁的状态。结合 <code>wait.Poll</code> 来使用，该函数返回会有以下几种情况：</p>

<ul>
<li><code>tryAcquireOrRenew</code> 获取到锁，返回 true</li>
<li><code>tryAcquireOrRenew</code> 没有获取到锁，返回 false</li>
<li><code>tryAcquireOrRenew</code> 超时，返回 <code>ErrWaitTimeout</code>（errors.New(&ldquo;timed out waiting for the condition&rdquo;)）</li>
</ul>


<p>最后，我们再来重点了解下 <code>tryAcquireOrRenew</code> 的内容。renew有两个功能，获取锁，或者在已经获取锁的时候，对锁进行更新，确保锁不被他人抢走。</p>

<p>具体的说明也放到了注释里，这段代码流程上不不复杂，但是需要对前后两个状态，以及 leader 和非 leader 两个角色的不同执行流程有所分辨。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">le</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">tryAcquireOrRenew</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">now</span> <span class="o">:=</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>  <span class="c1">// 这个 leaderElectionRecord 就是保存在 Endpoint 的 annotation 中的值。</span>
</span><span class='line'>  <span class="c1">// 每个节点都将 HolderIdentity 设置为自己，以及关于获取和更新锁的时间。后面会对时间进行修正，才会更新到 API server</span>
</span><span class='line'>  <span class="nx">leaderElectionRecord</span> <span class="o">:=</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">LeaderElectionRecord</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">HolderIdentity</span><span class="p">:</span>       <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Identity</span><span class="p">(),</span>
</span><span class='line'>      <span class="nx">LeaseDurationSeconds</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">LeaseDuration</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
</span><span class='line'>      <span class="nx">RenewTime</span><span class="p">:</span>            <span class="nx">now</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">AcquireTime</span><span class="p">:</span>          <span class="nx">now</span><span class="p">,</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 1. 获取或者创建 ElectionRecord</span>
</span><span class='line'>  <span class="nx">oldLeaderElectionRecord</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Get</span><span class="p">()</span>
</span><span class='line'>  <span class="c1">// 获取记录出错，有可能是记录不存在，这种错误需要处理。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nx">IsNotFound</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;error retrieving resource lock %v: %v&quot;</span><span class="p">,</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Describe</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="c1">// 记录不存在的话，则创建一条新的记录</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">leaderElectionRecord</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">glog</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;error initially creating leader election record: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="c1">// 创建记录成功，同时表示获得了锁，返回true</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span> <span class="p">=</span> <span class="nx">leaderElectionRecord</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 2. 正常获取了锁资源的记录，检查锁持有者和更新时间。</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span><span class="p">,</span> <span class="o">*</span><span class="nx">oldLeaderElectionRecord</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 记录之前的锁持有者，其实有可能就是自己。</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span> <span class="p">=</span> <span class="o">*</span><span class="nx">oldLeaderElectionRecord</span>
</span><span class='line'>      <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// 在满足以下所有的条件下，认为锁由他人持有，并且还没有过期，返回 false</span>
</span><span class='line'>  <span class="c1">// a. 当前锁持有者的并非自己</span>
</span><span class='line'>  <span class="c1">// b. 上一次观察时间 + 观测检查间隔大于现在时间，即距离上次观测的间隔，小于 `LeaseDuration` 的设置值。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">LeaseDuration</span><span class="p">).</span><span class="nx">After</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>      <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span> <span class="o">!=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Identity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">Infof</span><span class="p">(</span><span class="s">&quot;lock is held by %v and has not yet expired&quot;</span><span class="p">,</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// 3. 更新资源的 annotation 内容。</span>
</span><span class='line'>  <span class="c1">// 在本函数开头 leaderElectionRecord 有一些字段被设置成了默认值，这里来设置正确的值。</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span> <span class="o">==</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Identity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 如果自己持有锁，则继承之前的获取时间和 leader 切换次数</span>
</span><span class='line'>      <span class="nx">leaderElectionRecord</span><span class="p">.</span><span class="nx">AcquireTime</span> <span class="p">=</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">AcquireTime</span>
</span><span class='line'>      <span class="nx">leaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span> <span class="p">=</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 发生 leader 切换，所以 LeaderTransitions + 1</span>
</span><span class='line'>      <span class="nx">leaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span> <span class="p">=</span> <span class="nx">oldLeaderElectionRecord</span><span class="p">.</span><span class="nx">LeaderTransitions</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 更新锁资源对象</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">le</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Lock</span><span class="p">.</span><span class="nx">Update</span><span class="p">(</span><span class="nx">leaderElectionRecord</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">glog</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;Failed to update lock: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">observedRecord</span> <span class="p">=</span> <span class="nx">leaderElectionRecord</span>
</span><span class='line'>  <span class="nx">le</span><span class="p">.</span><span class="nx">observedTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</span><span class='line'>  <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>再回到 <code>renew</code> 方法，在被 <code>Poll</code> 阻塞住之后，只要 <code>Poll</code> 返回了，就可以继续执行下面的代码。<code>le.maybeReportTransition()</code> 很关键，里面会判断是否出现了 leader 的切换，进而调用 <code>Callbacks</code> 的 <code>OnNewLeader</code> 方法，尽管 cm 初始化的时候并没有设置这个 Callback 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LeaderElector</span><span class="p">)</span> <span class="nx">maybeReportTransition</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">observedRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span> <span class="o">==</span> <span class="nx">l</span><span class="p">.</span><span class="nx">reportedLeader</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">l</span><span class="p">.</span><span class="nx">reportedLeader</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">observedRecord</span><span class="p">.</span><span class="nx">HolderIdentity</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Callbacks</span><span class="p">.</span><span class="nx">OnNewLeader</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">go</span> <span class="nx">l</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Callbacks</span><span class="p">.</span><span class="nx">OnNewLeader</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">reportedLeader</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码看起来比较烧脑，本文读起来也比较摸不着头，可能最好的办法就是一遍遍的阅读源代码了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向 Kubernetes 学习 - 如何实现定时轮训]]></title>
    <link href="http://liubin.github.io/blog/2018/04/27/learn-from-k8s-running-func-periodically/"/>
    <updated>2018-04-27T19:29:04+08:00</updated>
    <id>http://liubin.github.io/blog/2018/04/27/learn-from-k8s-running-func-periodically</id>
    <content type="html"><![CDATA[<p>编程中常见的场景包括定时执行任务，很多语言，比如 Java 提供了非常方便易用且功能强大的类库，但是 Golang 中并没有，虽然我们可以通过 <code>time.Ticker</code> 等机制实现，但是不如原生直接支持更简单。</p>

<p>其实参考别人的代码是最好的学习方式了，比如通过阅读 K8s 的源代码，我们可以学习到很多编程技巧。</p>

<p>这里我们以实现定时轮训功能为例，来看看 K8s 是怎么实现的。</p>

<p>首先简单介绍下 K8s 的简单架构，主要包括以下几个组件（大体流程）：</p>

<ul>
<li>API server</li>
<li>Scheduler</li>
<li>Controller manager</li>
<li>Kubelet</li>
</ul>


<p>这几个组件只是完整运行 K8s 的4个组件，并不是全部，这里我们只是为了了解而只对这几个组件进行说明。</p>

<p>首先客户端（API 或者 kubectl 工具）发出请求，比如创建一个Deployment，Controller manager 会负责这个 Deployment 的生命周期，Scheduler 会为 Pod 分配节点，该节点上的 Kubelet 会负责在自己的机器上启动这个 Pod，这是一个非常简单的流程。</p>

<p>这些组件，都是以守护进程方式运行的，即会一直无限循环的运行下去，不会退出。在其中有很多例子都是诸如每隔 5 分钟做一次同步，每隔 10 秒做一次 retry 的尝试。对于这样的需求，即使只有一处，相信从代码结构的角度，我们都会把这些功能抽象成 util 函数。</p>

<p>K8s 就实现了很多这样的方法，比如 &ldquo;k8s.io/apimachinery/pkg/util/wait&rdquo; 包就有很多非常实用的方法，值得我们借鉴。</p>

<p>首先，最简单的每隔 10 秒执行一个函数，永不停止，那么可以用<a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L78">这个方法</a>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Forever</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">period</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你想在上面的基础上，在需要的时候停止循环，那么可以使用<a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L87">下面的方法</a>，增加一个用于停止的 <code>chan</code> 即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Until</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">period</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">stopCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的第三个参数 <code>stopCh</code> 就是用于退出无限循环的标志，停止的时候我们 close 掉这个 chan 就可以了。</p>

<p>K8s 的很多地方都用到了这些函数，比如这里在 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/dockershim/cm/container_manager_linux.go#L70-L81">Container manager 启动的时候</a>，就启动了一个无限循环来进行实际的工作（ <code>m.doWork</code> 函数）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">containerManager</span><span class="p">)</span> <span class="nx">Start</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// TODO: check if the required cgroups are mounted.</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">cgroupsName</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">manager</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">createCgroupManager</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">cgroupsName</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nx">err</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nx">m</span><span class="p">.</span><span class="nx">cgroupsManager</span> <span class="p">=</span> <span class="nx">manager</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">go</span> <span class="nx">wait</span><span class="p">.</span><span class="nx">Until</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">doWork</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">,</span> <span class="nx">wait</span><span class="p">.</span><span class="nx">NeverStop</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="kc">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面只是简单的定期运行任务的例子，有时候，我们还会需要在运行前去检查先决条件，在条件满足的时候才去运行某一任务，这时候可以使用 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L220">Poll 方法</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Poll</span><span class="p">(</span><span class="nx">interval</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">condition</span> <span class="nx">ConditionFunc</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数会以 <code>interval</code> 为间隔，不断去检查 <code>condition</code> 条件是否为真，如果为真则可以继续后续处理；如果指定了 <code>timeout</code> 参数，则该函数也可以只常识指定的时间。</p>

<p>一个非常常见的例子就是我们在创建资源之后，资源不会立即就位，我们需要等资源创建完成之后，才能进行后续操作，这时候使用 <code>Poll</code> 方法应该就会非常方便了。</p>

<p>此外这个函数还有两个快捷方式， <code>PollImmediate</code> 、 <code>PollInfinite</code> 和 <code>PollImmediateInfinite</code> ，具体意义从名称上面即可理解。</p>

<p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L289"><code>PollUntil</code></a> 方法和上面的类似，但是没有 <code>timeout</code> 参数，多了一个 <code>stopCh</code> 参数。</p>

<p>此外，这个包里还有一个公开方法 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.10/staging/src/k8s.io/apimachinery/pkg/util/wait/wait.go#L307"><code>WaitFor</code></a> ，好像并没有直接被外部调用，而是在 <code>PollUtil</code> 中被使用，这个方法需要自己编写 <code>WaitFunc</code> 类型的方法作为第一个参数，具体可以参考 <code>PollUntil</code> 的实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python/Java 才是王道，PHP 还得靠边站]]></title>
    <link href="http://liubin.github.io/blog/2017/07/18/python-and-java-main-stream/"/>
    <updated>2017-07-18T15:01:02+08:00</updated>
    <id>http://liubin.github.io/blog/2017/07/18/python-and-java-main-stream</id>
    <content type="html"><![CDATA[<p>3 月份 Erik Bernhardsson 发表了一篇文章 <a href="https://erikbern.com/2017/03/15/the-eigenvector-of-why-we-moved-from-language-x-to-language-y.html">The eigenvector of &ldquo;Why we moved from language X to language Y”</a> ，作者根据 Google 里面搜索 <code>move from &lt;language 1&gt; to &lt;language 2&gt;</code> 或 <code>switch to &lt;language 2&gt; from &lt;language 1&gt;</code> 等的结果数量，做了一个编程语言之间的转移矩阵（Stochastic matrix），采用马可夫链的平稳分布，得到了一些关于未来什么语言最流行的结论，文中也多次提到，那就是 go 语言，很多人搜索了从 xx 到 go ，go 语言才是未来的语言。此外，作者认为 Perl 已死，Java 正当年，Rust 也很有希望。</p>

<p>当然，在 Google 搜一下从 xx 到 yy ，并不代表真的开发者就要移情别恋，只有真的写了 yy 的代码，新的恋情才算开始。</p>

<p>所以，上周 Waren Long 基于 GitHub 数据的统计结果，发表了一篇文章 <a href="https://blog.sourced.tech/post/language_migrations/">Analyzing GitHub, how developers change programming languages over time</a> ，该文章统计了包含GitHub 中 450 万用户，以及10 TB 的源代码，分析了 393 种语言的变化趋势，最后得出的结论就是：Python 和 Java 才是王道。</p>

<p>这是 Waren Long 总结出来的流行语言的 Top 10 ：</p>

<p><img src="http://liubin.github.io/images/2017/07/language_top_10.png" alt="" /></p>

<p>从上图可以看到 Python (16.1 %) 才是最流行的编程语言，紧随其后的是 Java (15.3 %) 。而且前五名中，Python 代码量也比其他语言所占的比例要低（只有 11.3 %，我们可以理解为投入产出比、效益率，投入越少，产出越大，当然语言就比较流行），PHP 代码量最大，达到了 24.4 %，但是其流行程度只有 Python 的一半而已。</p>

<p>在这个排名中，go 排名第 9 ，但是相对于其 0.9 % 的代码量占比，这个位置还是很牛的了，效益率也是最高的。考虑到这个数据的时效性，相信 go 语言肯定还会进一步扩大受众。</p>

<p>下图是各语言之间的转换矩阵，左面是 From ，右面是 To ：</p>

<p><img src="http://liubin.github.io/images/2017/07/sum_matrix_22lang_eig.svg" alt="" /></p>

<p>在排名前 5 的语言中（Java、 C、 C++、 PHP、 Ruby，除去 Python ），有平均近 22% 的概率，会转移到 Python，不过大叔不理解的是为啥 Ruby 还会转移到 Python ？</p>

<p>而作为统计学领域中的 Fortran (36 %)、 Matlab (33 %) 和 R (40 %) ，转移到 Python 的概率都是非常高的，可见，在数学计算、机器学习等领域，Python 的地位似乎越来越稳固了。</p>

<p>从上面的转移矩阵，我们还可以发现一些有意思的规律，比如：</p>

<ul>
<li>Pascal 程序员最喜欢学习 Java</li>
<li>Visual Basic 程序员学习 C# 顺理成章，C# 程序员爱转 Python</li>
<li>Scala/Clojure 程序员最喜欢 Java，但是反过来不是，Java 程序员爱转 Python</li>
<li>Object C 和 Swift 互转说明这个统计结果还是挺靠谱的</li>
<li>转 go 最多的竟然不是 PHP 这样的脚本语言，而是 Rust，难道是 Rust 的学习曲线太陡了？</li>
</ul>


<p>下面的图是 16 年来各语言的平稳分布图：</p>

<p><img src="http://liubin.github.io/images/2017/07/eigenvect_stack_22lang.png" alt="" /></p>

<p>不过大叔不知道这16年的数据是怎么来的，如果我没记错的话，那时候应该还没有 GitHub 。</p>

<p>前两名 Python 和 Java 的趋势基本一样，都是稳中有升的形状。这两个语言已经取代了 C 语言的霸主地位，如果把这 3 种语言合起来看，则它们的总量几乎没什么变化。</p>

<p>Perl 基本死了，PHP 的扩张趋势也没那么明显，Ruby 粗了几年又细了，应该是和 Python 份额的扩大和 go 等的日渐流行有关。</p>

<p>如果让我总结一下，那么 Java、Python 和 go 值得关注、持续学习。</p>

<hr>


<p>这就是 Waren Long 原文里的几个重要结论，如果你对原始数据和算法感兴趣，可以直接 <a href="https://blog.sourced.tech/post/language_migrations/">阅读原文</a>  。</p>

<p><em>注意： 由于 JavaScript 的特殊性（前后通吃、受众广等，不适用于统计模型），Waren Long 的文章中并没有将 JavaScript 作为评价对象。</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[沟通的原则]]></title>
    <link href="http://liubin.github.io/blog/2017/06/16/rules-for-communication/"/>
    <updated>2017-06-16T07:40:16+08:00</updated>
    <id>http://liubin.github.io/blog/2017/06/16/rules-for-communication</id>
    <content type="html"><![CDATA[<p>沟通是工作中第一要义。</p>

<p>有效地沟通，能使工作更高效、提高大家的满意度；相反，错误的沟通方式除了降低工作的效率，还会制造出各种部门隔阂、人之矛盾，影响公司士气。因此高效的沟通不仅能更好地完成工作，还有助于提高公司的凝聚力，创造良好的公司文化。</p>

<h2>信息共享范围</h2>

<p>信息应该让谁知道，不该让谁知道？</p>

<p>在程序实现里我们爱用白名单，宁可错杀一千，不可放过一个；而在沟通中，则适用黑名单。如果某一信息确实不想让某些人知道，别让他知道就行了，否则就让所有人都知道，至于这些信息是否有用，是否需要处理，留给接收方决定即可。</p>

<p>常见的例子是功能需求讨论。一个功能，到底会不会影响其他功能，或者说是否有其他功能对该功能有兴趣，这个不是新功能的产品经理能掌握的，这时候最好的方式是全员周知，其他功能的负责人自然会判断这条信息是否跟自己有关，自己是否应该站出来参与到讨论当中。</p>

<p>是否会造成信息泛滥？有可能，不过我能接受这一点问题，相对来说，信息丢失更可怕。</p>

<h2>让信息共享成为常态</h2>

<p>最好的方式就是定期的会议，比如周会。这是员工了解公司、组织最常见的方式，也是效果比较好的方式。公司最近的变动，业务发展情况，都可以由中层领导传递给下属员工。除了让员工能了解公司的详细信息，还能鼓动员工干劲，提高员工对公司的信任程度。信任是双方向的，你若信任对方，对方也会 120% 的信任你。</p>

<p>欺瞒甚至扭曲事实最终都会偿还回来的，这个不会有例外。即使赢了世界，也会输掉人心。</p>

<p>领导不应该吝惜自己所掌握的信息，也不要以为这些信息对员工并无卵用。事实上多后进的员工，都会或多或少关心公司的某些方面。</p>

<p>更不要担心流言蜚语，空气太纯净，细菌滋生危害才会越大，正因为你不说，流言蜚语才会起来。</p>

<h2>以吼为荣</h2>

<p>原始社会，通讯基本靠吼；原始的才是最纯粹的，因为原始，效率最高。</p>

<p>文字的表达效率低于直接语言沟通，相信很多人有过通过 IM 一个字一个字的进行远程交流那种心急如焚、坐立不安的感觉。这时候只要条件允许，就应该换电话或者实时语音来进行交流，这才是效率最高、成本最低的方式。</p>

<p>同一个办公室，离着 5 米都不到，用 IM 你不怕费你的 HHKB Pro 么？</p>

<h2>要 <code>ack</code></h2>

<p>重要信息，需要得到对方的反馈，哪怕只有一句“好”、“明白了”也可以，确保对方收到了你的信息，而不是对方因为心不在焉而丢失了你要传达的消息。</p>

<p>交流要采用 TCP 的机制，需要对请求回应进行确认，不要像使用 UDP 那样，把消息放出去就不管了。</p>

<h2>以诚为本</h2>

<p>对事不对人是重要的原则，可以对人的做法、成果进行指责，但是不应该直接对人本身，尤其是人品进行评判。首先要尊重沟通的各方，换位思考，以同理心来进行交流，把自己摆在对方的角度进行假设，全面思考，在提出问题的时候，同时考虑是否可以提出一些解决方案，带着答案问问题，除了能更高效的解决问题，也能获得对方的信赖和感情分。</p>

<h2>会话的 Context 很重要</h2>

<p>你有多少次莫名其妙的被人拉进到一个群里被莫名其妙的问你各种问题的、一脸懵逼的经历么？</p>

<p>Context ，即背景，在向别人传达指令，或者寻求帮助的时候，需要让对方对整个事情的背景、详细情况或者来龙去脉有所了解，也就是提供对方能理解你所描述问题的所有线索。</p>

<p>比如 Bug 或故障，第一件事就是现象，哪里出了问题，怎么不正常，应该是什么样的。其次，要提供详细的操作说明，最好精确到每一个输入、每一次点击，以及有哪些预置条件。最重要的，还需要提供全面的日志，对开发人员来说，日志是解决问题的关键所在，程序的运行时异常、服务的逻辑异常，都能通过日志找到问题所在并提供解决问题的线索。</p>

<p>十几年前流传很广的一篇文章叫《提问的技巧》，那你是否掌握了《提 Bug 的技巧》或者《说明问题的技巧》？</p>

<h2>金字塔原理</h2>

<p>看似和上一条矛盾，根据情况，有时候信息接收者的关注点只是你的结论，而不关心过程，所以很多时候我们在表达的时候一定要先说结论和重点。</p>

<p>比如领导问你这个功能什么时候完成，你怎么回答？</p>

<p>最好的回答就是一个具体的时间点，就这么一句话，比如“本周末”、“6/20”等等。</p>

<p>如果这个时间点比计划的时间要晚，当然你要补充说明延迟的理由；如果并没有规定时间点或者说早于计划时间，那么别人问你什么时候完成的时候，你回答“我现在在做 xxx，出了点问题，需要谁谁谁来帮我解决一下；之后还要做 yyy，在 zzz 之后才能开始，预计 6/20 能完成”，说那么多废话有用么？我相信多数时候领导在问你进度的时候，最关心的是否有延期，是否能按时完成，没有问题就不要给领导添堵。</p>

<p>这是另一个例子，一段真实的对话。</p>

<p>A： “你几点回家？”</p>

<p>B： “我今天来的比较晚。”</p>

<p>A： “那是几点？”</p>

<p>B： “还有点活，干完就走”</p>

<p>A： “你就告诉是 7 点还是 8 点行么？”</p>

<p>B： “ 7 点”</p>

<p>推荐一本同名的书，大家可以找来读读。</p>

<hr />

<p>7 年前参加过拍马屁（PMP）的培训和考试，很多都忘了，只对沟通部分的原则和案例有些记忆，毕竟大多数时候，我们不是一个人在战斗。</p>

<p>所以，请重视沟通的方式、技巧和效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工具的品格]]></title>
    <link href="http://liubin.github.io/blog/2017/06/15/task-toolss-element/"/>
    <updated>2017-06-15T16:46:01+08:00</updated>
    <id>http://liubin.github.io/blog/2017/06/15/task-toolss-element</id>
    <content type="html"><![CDATA[<p>开发人员除了开发工具（编辑器、中间件），还需要各种必备的任务管理（或者进度管理、项目管理，不纠结其名字）工具，你可能用的是免费的 TODO list、Trello，或者诸如 JIRA 等商业软件，亦或是自己编写的简单 Web 管理工具，甚至记事本、OneNote等。也不管我们叫他 GTD 还是个人助理，我们依赖这些软件的原因之一无非是好脑子不如烂笔头，记下来就不会“忘”。</p>

<p>前面的“忘”字为什么加个双引号呢？因为记下来你看不到，还是会忘，因为这个工具可能并没有告诉现在你应该去做什么，这个任务，可能一直沉睡于箱子的底部。</p>

<p>一个好的任务管理工具最，我觉得基本应该包括以下几点必须的品格：</p>

<h2>任务状态</h2>

<p>是在进行中，还是准备中；是否处于一个流水线上，处于哪个阶段；是否顺利，有什么 Block 的问题等等。有了任务状态，才能决定采取何种措施。我们对应用程序的性能、服务器的使用情况、中间件的健康程度都有监控，自己的任务也应该有类似的监控机制：你的任务是绿？黄？还是红？（Elastic Search用户都秒懂的）</p>

<h2>任务优先级</h2>

<p>对大多数软件开发人员来说，并行工作司空见惯，反过来一个月只做一件事的人估计只能是宝洁或者厨子了。一个人很多时候可能担任多个项目、多个产品、多个组件的开发工作，这时候任务列表可能堆积如山，如果没有为这些工作设置优先级并进行可视化，你看到这么多任务如何决定该先干哪个后干哪个？有新的任务进来，是不是该停下手头的工作开始新任务？还是让新任务靠边站。</p>

<p>为任务排序，是有条不紊高效工作的第一步。</p>

<h2>依赖关系</h2>

<p>大多时候你不是一个人在战斗，你可能会和前端、后端、日志服务、API服务、运维或者产品经理一起在完成一个功能，你即依赖别人，也被别人依赖。DevOps 主张消除浪费，每个等待都是浪费，你写到一半的代码就像保存在仓库中的玉米，天气潮湿可能发霉、生虫。</p>

<p>识别依赖关系、解决绊脚石，能保证任务顺利完成。</p>

<h2>工作流支持</h2>

<p>DevOps 要做的是一个统一工作流平台，就像流水线那样，零件从一个部分传到下一个部分，如果流水线的履带宽度不一样、速度不一样，能衔接的稳？</p>

<p>任务管理工具也是，和其他工具的无缝集成是一个大大的必备项。比如是否支持开发中其他工具，比如构建、发布或测试等的插件支持。</p>

<p>这很重要，也是 DevOps 或者流水线的关键，我们的每项开发活动的产出物，是否可以通畅的缴费给流水线的下一个动作？</p>

<p>考察这一点的标准也很简单，你是否在不同的工具之间拷贝某个提交号、版本号、或者某些说明？</p>

<h2>领导角度</h2>

<p>个人需要方便的任务管理工具，领导更需要。成员的任务就是组织的任务，领导是最任务的终责任者，最终责任者更需要对任务状态、进度等了如指掌，这是第一。</p>

<p>第二，你需要掌握组员的状态。而任务可以在很大的程度上体现组员的现在状态：是否工作压力很大，是否遇到了麻烦，是否可以抽出来去做别的救火队员。</p>

<p>从管理角度上来说，多维度的报表也很重要，项目进度、花费的成本、产品的质量，都可以从任务管理工具得到直观的结果。</p>

<h2>铁证如山</h2>

<p>不管你要扯皮的对象是谁：同事、领导、客户、其他部门，你都需要拿出证据去说服别人、怼（dǔi）到让别人无话可说。</p>

<p>这时候，我们就需要工具具备丰富的记录功能，至少能传个附件吧，修改履历功能也是必不可少的。</p>

<hr />

<p>上面列出来的只是自己的观点，有些人可能不觉得，甚至很多人都不在乎，不过大叔实在是难以忍受不抱怨工具的开发 ：-）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang中一个不错的处理 JSON 的库 go-dproxy]]></title>
    <link href="http://liubin.github.io/blog/2016/10/08/go-dproxy/"/>
    <updated>2016-10-08T18:11:13+08:00</updated>
    <id>http://liubin.github.io/blog/2016/10/08/go-dproxy</id>
    <content type="html"><![CDATA[<p>Golang 自己就带了 JSON (encoding/json) 处理的库，也有第三方的 <a href="https://github.com/bitly/go-simplejson">simplejson</a> 之类的库，但总是感觉不如Python这样的动态语言方便，在 Python 里，数组和字典的处理都很方便，和 JSON 互转也非常简单。</p>

<p><code>encoding/json</code> 最大的问题是不够灵活，需要预先定义很多的 <code>struct</code> 来进行编解码，这样对于处理结构不定的 JSON 文件非常不方便。</p>

<p>这里介绍一个名为 <a href="https://github.com/koron/go-dproxy">go-dproxy</a> 的库，非常方便和简单，不需要预先定义 <code>struct</code> ，还可以类似 XPath 那样查找。</p>

<p>下面是一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="p">(</span>
</span><span class='line'>  <span class="s">&quot;encoding/json&quot;</span>
</span><span class='line'>  <span class="s">&quot;fmt&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/koron/go-dproxy&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">v</span> <span class="kd">interface</span><span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{</span>
</span><span class='line'><span class="s">      &quot;name&quot;: &quot;dproxy&quot;,</span>
</span><span class='line'><span class="s">  &quot;strings&quot;: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ],</span>
</span><span class='line'><span class="s">  &quot;numbers&quot;: [ 1,2,3 ],</span>
</span><span class='line'><span class="s">  &quot;mixs&quot;: [&quot;a&quot;, 1, &quot;b&quot;],</span>
</span><span class='line'>
</span><span class='line'><span class="s">  &quot;tags&quot;: {</span>
</span><span class='line'><span class="s">    &quot;key-1&quot;: &quot;value-1&quot;,</span>
</span><span class='line'><span class="s">    &quot;key-2&quot;: 100,</span>
</span><span class='line'><span class="s">    &quot;key-3&quot;: [4,5,6]</span>
</span><span class='line'><span class="s">  }</span>
</span><span class='line'><span class="s">}`</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// s == &quot;dproxy&quot;, got a string.</span>
</span><span class='line'>  <span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;1. name is %s\n&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// err: not matched types: expected=int64 actual=string: name</span>
</span><span class='line'>  <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">).</span><span class="nx">Int64</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;2. err is %s\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// can be chained. n == 3, got a int64</span>
</span><span class='line'>  <span class="nx">n</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;numbers&quot;</span><span class="p">).</span><span class="nx">A</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">Int64</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;3. n is %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// got value-1</span>
</span><span class='line'>  <span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;tags&quot;</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;key-1&quot;</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;4. key-1 is %s\n&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// err.Error() == &quot;not found: data.kustom&quot;, wrong query can be verified.</span>
</span><span class='line'>  <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;data&quot;</span><span class="p">).</span><span class="nx">M</span><span class="p">(</span><span class="s">&quot;kustom&quot;</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;5. err is %s\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// n == 5</span>
</span><span class='line'>  <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">dproxy</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&quot;/tags/key-3/1&quot;</span><span class="p">).</span><span class="nx">Int64</span><span class="p">()</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;6. n is %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者从 <a href="https://gist.github.com/liubin/5521035cb9dab26e5981549b2cea355a">gist</a> 下载这个文件，执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="err">$</span> <span class="k">go</span> <span class="nx">get</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">koron</span><span class="o">/</span><span class="k">go</span><span class="o">-</span><span class="nx">dproxy</span>
</span><span class='line'><span class="err">$</span> <span class="k">go</span> <span class="nx">build</span> <span class="nx">dproxy</span><span class="o">-</span><span class="nx">test</span><span class="p">.</span><span class="k">go</span>
</span><span class='line'><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">dproxy</span><span class="o">-</span><span class="nx">test</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>即可。</p>

<p>总之，这个库处理JSON应该算是非常简单，希望对你有所帮助。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年8月读书记录]]></title>
    <link href="http://liubin.github.io/blog/2016/09/06/2016-08-reading/"/>
    <updated>2016-09-06T19:34:20+08:00</updated>
    <id>http://liubin.github.io/blog/2016/09/06/2016-08-reading</id>
    <content type="html"><![CDATA[<h2>穿越百年中东</h2>

<p><img src="https://img3.doubanio.com/lpic/s28419285.jpg" alt="" /></p>

<p>推荐指数：★★★★★</p>

<p>这本书是我阅读到的关于伊斯兰的比较详细的一本书，从奥匈帝国和第一次世界大战开始，讲述了伊拉克、以色列等建国，契丹人、穆斯林、犹太人的渊源和纷争，伊斯兰教的兴起和发展，逊尼派和什叶派的争斗等等，内容非常详细。</p>

<p>如果你也对最近的叙利亚冲突等不甚明了，那么可以试读一下本书。</p>

<h2>《禅与摩托车维修艺术》</h2>

<p><img src="https://img3.doubanio.com/lpic/s6927676.jpg" alt="" /></p>

<p>推荐指数：★★★★☆</p>

<p>这是新世相活动收到的第一本书，用了12天才看完，中间过程各种闹心，多次要放弃，但是要考虑到129块钱。</p>

<p>说实话，没太懂，不知道看完这本书有什么新的收获。只是对古典和浪漫、两良质等词汇印象深刻。</p>

<p>讲哲学？有点像，哲学是什么？是探究事物的本质？万相皆有其缘，不是佛法中的尤其因必有其果，而是不论什么结果，都可以找到相应的原因。</p>

<p>哲学是不断对本质的思考，而思考则会受到个人在不同环境、时代、地区等的影响，因此，人的看法才会变，对世界、对本质的理解才会变。</p>

<p>唯一不变的，就是对本质本身的追求，不断地思考。</p>

<p>&ldquo;我在公路上慢慢地走着，不想去打扰阳光，这正是早秋的感觉。&rdquo;</p>

<p><img src="http://image.beekka.com/blog/201112/bg2011121802.jpg" alt="" /></p>

<h2>《虚无的十字架》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28096698.jpg" alt="" /></p>

<p>推荐指数：★★★★★</p>

<p>看了不到1/3，我就大概猜出来凶手是为包庇自己子女顶罪了，但至于原因还是到最后才知道。怀孕杀死新生婴儿这个设定太狗血了。</p>

<p>总之，作为各个书店推荐的畅销品，还是不错的。</p>

<h2>《五十年代的尘埃》</h2>

<p><img src="https://img3.doubanio.com/lpic/s27996544.jpg" alt="五十年代的尘埃" /></p>

<p>推荐指数：★★★★☆</p>

<p>这是新世相的第二本书，比较薄，一天就看完了。</p>

<p>书中内容主要是作者在50年代左右的一些随笔，比如梅兰芳传记，自己租房的记录等等，算是对50年代大陆生人又去美国发展的那一代人的生活、意识有了一点了解。</p>

<h2>《废都》</h2>

<p><img src="https://img3.doubanio.com/lpic/s7633093.jpg" alt="废都" /></p>

<p>推荐指数：★★★★☆</p>

<p>不多说了，90年代感十足的一本书。</p>

<h2>《伊斯兰国》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28363789.jpg" alt="" /></p>

<p>推荐指数：★★☆☆☆</p>

<p>这也能算本书？附录占了多一半，在kindle上看的，大概只用了30分钟左右吧。</p>

<p>不推荐。而推荐下面的《穿越百年中东》一书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年7月读书记录]]></title>
    <link href="http://liubin.github.io/blog/2016/08/05/07-reading/"/>
    <updated>2016-08-05T23:46:34+08:00</updated>
    <id>http://liubin.github.io/blog/2016/08/05/07-reading</id>
    <content type="html"><![CDATA[<p>7月大概是比较忙的原因吧，读完的只有3本，一本是东野圭吾的《梦幻花》，kindle上看着价格还不错就买了；还有一本是最近比较火的管理类，杰克•韦尔奇的《商业的本质》。《无声告白》也是在kindle上看的。</p>

<h2>《梦幻花》</h2>

<p><img src="https://img1.doubanio.com/lpic/s27980309.jpg" alt="梦幻花" /></p>

<p>推荐指数：★★★★☆</p>

<p>其实仔细想想，情节也很“日式”，每个人都坚信着自己的“义务”或者“责任”，为了家族或者宿命而“不得不”背负的责任。这有点类似家臣的意思，即一代为臣，世代效忠主人，而上一代人所肩负的责任，也会被下一代继承和发扬，面对现实，不去逃避，而是努力去解决。</p>

<p>作为悬疑小说，推理方面的吸引力一般。最后找到真正的杀人凶手有点虎头蛇尾的感觉，就那么几十个字带过，而之前的各种推理、假设和怀疑还是挺吸引人的；而凶手的暴露太突然了，有点意犹未尽的感觉。</p>

<h2>《商业的本质》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28504660.jpg" alt="商业的本质" /></p>

<p>推荐指数：★★★★★</p>

<p>我一贯认为，成功（至少在金钱方面）和市面管理类书籍之间没有任何关系：即使你熟记了所有经管类、个人传记类的成功案例，你也很难成功；成功的人，很多地方都不符合这些书中所提到的观点、方式或者经验。</p>

<p>凡是能写成书的，大都是因为“成功了，屁都是经验”。当然，这本书也不例外。</p>

<p>那我为什么还要读这类的书？至少对我来说，可以找一下和成功人士的共同语言，提高一下自己的“品格”，还有就是能多些谈资，学习更多的经验。所以说，多少还是要读一些的。</p>

<p>首先这本书的中文名翻译就有问题，英文名应该是《The real life MBA》吧，所以，这本书只有不到一半的内容是关于商业的东西，比如成本、销售或者市场等，而更多的是像在讲管理，比如如何构建团队、提高领导力和构建自己的职业生涯等。</p>

<h2>《无声告白》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28109182.jpg" alt="无声告白" /></p>

<p>推荐指数：★★★★★</p>

<p>母亲在年轻时爱上了爸爸，并不得不放弃了自己的学业。多年以后，母亲当时的理想并未褪去，在老二（莉迪亚本书开篇即死去的高中女孩）出生后不久一个人离家出走想继续学业，无奈后来发现怀了老三，只好回家，不得不放弃了自己的理想，但是，却把自己的希望都寄托给了莉迪亚，对她严加管教、全面指导。</p>

<p>而一家人之间并不是那么“亲密”，人之间关系比较冷淡，父亲按部就班的工作，目前全职主妇，辅导二女儿学习，父母之间，父母和孩子之间，并没有真实真心的交流。莉迪亚只是被动的活着，一切都要听母亲的摆布，而哥哥即将远赴哈佛读大学，也让莉迪亚变得对人生更加不抱希望，在孤独中选择了自杀。</p>

<p>家庭是什么，虽然有各种分工，有人负责赚钱，养家糊口，有人复杂相夫教子把持家务，但任何人之间的真诚交流都是必不可少的，即使对小孩子也是，更何况已经是成人的高中生？</p>

<p>孩子除了学习，心理的健康也是不得不关注的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年6月读书记录]]></title>
    <link href="http://liubin.github.io/blog/2016/07/09/06-reading/"/>
    <updated>2016-07-09T23:06:52+08:00</updated>
    <id>http://liubin.github.io/blog/2016/07/09/06-reading</id>
    <content type="html"><![CDATA[<p>度过5月低潮，6月的阅读时间又升上来了，本月基本上以微信读书为主。至于是什么原因呢？可能是因为一本书读起来就不想放下，一直读下去，直到读完。</p>

<p>6月一共阅读了6本，分别是《消费心理十四讲》、《袁腾飞讲先秦上古春秋》、《中国为什么有前途》、《白夜行》、《最神奇的经济学定律》和《国学讲演录》</p>

<h2>《白夜行》</h2>

<p><img src="https://img3.doubanio.com/lpic/s4610502.jpg" alt="白夜行" /></p>

<p>推荐指数：★★★★★</p>

<p>这可能是东野圭吾在国内最著名的小说之一了，也被翻拍成了影视作品。</p>

<p>作为侦探小说，情节还算不错。</p>

<p>我的感觉是，人生的长河，你总能找到同路人，相同的家庭环境，类似的遭遇或者不幸；不管是旋涡、阻挡，亦或是激流之后一湾浅滩的平静。每个人的人生都不同，但是总有重复相同经历的人。</p>

<h2>《袁腾飞讲先秦上古春秋》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28013690.jpg" alt="袁腾飞讲先秦上古春秋" /></p>

<p>推荐指数：★★★★★</p>

<p>这是一本历史书，从人文之初、轩辕黄帝一直讲到了春秋晚期，包括三代夏商周的更迭，以及春秋时期各诸侯的争霸。
对于长久不学习历史的人来说，算是一个很好的补足，对已经遗忘的、在初中、高中所学历史的补足。我们的传统文化还是很悠久和博大精深的，我觉得无论年纪大小，都应该读一下。</p>

<p>龙的传人：</p>

<p>伏羲和女娲结婚时，女娲才16岁，比伏羲小15岁。伏羲龙身，女娲蛇身，因此后代被称为龙的传人。</p>

<p>炎黄子孙：</p>

<p>炎帝和黄帝同为华夏部落，所以我们也成为炎黄子孙。</p>

<h2>《中国为什么有前途》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28562483.jpg" alt="中国为什么有前途" /></p>

<p>推荐指数：★★★★★</p>

<p>罗胖从政治、历史、经济和宗教等方面，针对各种消极、自卑和唱衰言论，东拉西扯、引经据典外加自己缜密的推断，论述了他眼中的中国为什么有前途。</p>

<p>尽管这一观点我不是很同意。</p>

<p>作为一个70年代出生，经历了30多年的改革开放，生活水平大幅提高，事业有成的罗胖，得出此结论并不奇怪，乐观派没什么不好，乐观派才能干成事。</p>

<p>然而现实实际是如何？近期的南海问题、韩国萨德、吃KFC成卖国贼等等，哪一个不是引起轩然大波，吸引力全社会各个阶层的关注甚至撕b？</p>

<p>我只是觉得，没朋友很孤独，尽管国家之间的友谊，更多时候是利害关系的外衣。</p>

<p>我们的朋友真的不多。</p>

<h2>《国学讲演录》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28306721.jpg" alt="国学讲演录" /></p>

<p>推荐指数：★★★★★</p>

<p>本书作者是南怀瑾高足魏承思，是一本由讲稿整理而成的书，讨论了国学的概念、定义、范围，还对诸子百家学说进行了详细的介绍。包括儒、释、道，还有墨家和法家，以及魏晋、隋唐的佛学、宋明理学等。同时，也对四书五经、诸子学说与二十四史等经史子集进行了深入的说明，是对我们中学所学历史的丰富补充。</p>

<p>总之，对于像学习一下中国传统文化、国学的人来说，都可以说算的上一本非常好的入门，内容浅显易懂而又详实饱满，张杰组织和条理也都很清楚。</p>

<h2>《最神奇的经济学定律》</h2>

<p><img src="https://img3.doubanio.com/lpic/s6179345.jpg" alt="最神奇的经济学定律" /></p>

<p>推荐指数：★★★★☆</p>

<p>这不是晦涩难懂、偏重理论的一本关于经济学的书，而是结合了具体事例，分析了各种现象，并给出了各种适用场景和建议告诉我们在现实世界中，在哪里以及如何应用这些定律。</p>

<p>同时本书也引用了很多历史典故、有趣的事例等。</p>

<p>比如美国航天飞机火箭助推器的宽度，为什么是现在这个值么？答案就是：</p>

<blockquote><p>现代铁路两条铁轨之间的标准距离是4.85英尺。原来，早期的铁路是由建电车的人所设计的，而4．85英尺正是电车所用的轮距标准。那么，电车的标准又是从哪里来的呢？最先造电车的人以前是造马车的，所以电车的标准是沿用马车的轮距标准。马车又为什么要用这个轮距标准呢？英国马路辙迹的宽度是4．85英尺，所以，如果马车用其他轮距，它的轮子很快会在英国的老路上撞坏。这些辙迹又是从何而来的呢？从古罗马人那里来的。因为整个欧洲，包括英国的长途老路都是由罗马人为它的军队所铺设的，而4．85英尺正是罗马战车的宽度。任何其他轮宽的战车在这些路上行驶的话，轮子的寿命都不会很长。罗马人为什么以4．85英尺作为战车的轮距宽度呢？原因很简单，这是牵引一辆战车的两匹马屁股的宽度。故事到此还没有结束。美国航天飞机燃料箱的两旁有两个火箭推进器，因为这些推进器造好之后要用火车运送，路上又要通过一些隧道，而这些隧道的宽度只比火车轨道宽一点，因此火箭助推器的宽度是由铁轨的宽度所决定的。
所以，最后的结论是：路径依赖导致了美国航天飞机火箭助推器的宽度，竟然是两千年前便由两匹马屁股的宽度所决定。</p></blockquote>

<p>当然，本书不是讲故事，也还是介绍了很多经济学专门知识的，比如凯恩斯对宏观经济的看法、基尼系数等。</p>

<h2>《消费心理十四讲》</h2>

<p><img src="https://img1.doubanio.com/lpic/s27184788.jpg" alt="消费心理十四讲" /></p>

<p>推荐指数：★★★☆☆</p>

<p>本书主要讲的是如何让品牌深入人心，如何吸引顾客的注意力和兴趣、满足顾客、把商品卖给顾客。</p>

<p>书中介绍了购物时人的心理的各个阶段：</p>

<ul>
<li>1.注意目标</li>
<li>2.引起兴趣</li>
<li>3.产生购买欲望</li>
<li>4.信任</li>
<li>5.决定购买</li>
<li>6.满足</li>
</ul>


<p>围绕这几个阶段，作者在各个章节展开了详细的叙述，比如如何吸引用户的兴趣，如何取得用户的信任，如何影响用户做决定等等。</p>

<p>其中关于群体效应的章节中，作者介绍哦啊了潮流产生和发展的几个阶段和特征，我觉得挺有意思的：</p>

<ul>
<li>1.潮流开始时一定包含着某些创新元素，即以前没有过的。</li>
<li>2.潮流最开始兴起的原因是某些人为了表明自己与众不同。</li>
<li>3.潮流的下一个特征——模仿，其他人会模仿最初的尝试者。</li>
<li>4.模仿阶段之后，曾经拥有新装备的潮流发起个体，即最初的尝试者不再突出。</li>
</ul>


<p>具体的话可以找来这本书看看。</p>

<p>总之，这不是一本特别差的书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初试Docker swarm]]></title>
    <link href="http://liubin.github.io/blog/2016/06/21/try-new-docker-swarm/"/>
    <updated>2016-06-21T20:41:42+08:00</updated>
    <id>http://liubin.github.io/blog/2016/06/21/try-new-docker-swarm</id>
    <content type="html"><![CDATA[<p>DockerCon 2016今天凌晨开始了，Docker公司的CEO和CTO都做了慷慨激昂的演讲（其实是我瞎想象的，没听，只是看了一些别人整理的 highlight ）。</p>

<p>同时，1.12 RC2也出来了，很多 <a href="http://liubin.org/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0/">新功能</a> 已经可以试用了， 这里我们就来试一下 <code>docker swarm</code> 命令吧，这也是 <code>swarm</code> 成为Docker子命令的第一个版本。</p>

<p>测试环境：</p>

<ul>
<li>OS：OS X</li>
<li>Docker：1.12.0-rc2</li>
<li>Docker Machine：0.8.0-rc1</li>
</ul>


<p>系统构成：</p>

<ul>
<li>master 1台</li>
<li>worker 2台</li>
</ul>


<h2>升级Docker</h2>

<p>使用Docker for Mac升级Docker很简单，这里不多说了；升级之后确认一下是最新版的Docker就可以了。</p>

<h2>创建3台Docker主机</h2>

<p>首先，使用Docker Machine创建3台主机，一台名为 <code>manager1</code> ，其余两台为 <code>worker1</code> 和 <code>worker2</code> ：</p>

<p>创建master节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine create --driver virtualbox manager1</span></code></pre></td></tr></table></div></figure>


<p>创建2个worker节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine create --driver virtualbox worker1
</span><span class='line'>$ docker-machine create --driver virtualbox worker2</span></code></pre></td></tr></table></div></figure>


<p>之后可以确认一下3台机器是否创建成功，以及ta们的IP地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine ls
</span><span class='line'>NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
</span><span class='line'>manager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v1.12.0-rc2   
</span><span class='line'>worker1    -        virtualbox   Running   tcp://192.168.99.101:2376           v1.12.0-rc2   
</span><span class='line'>worker2    -        virtualbox   Running   tcp://192.168.99.102:2376           v1.12.0-rc2   
</span></code></pre></td></tr></table></div></figure>


<h2>创建Swarm集群</h2>

<p>首先，切换到 <code>manager1</code> 主机，使用 <code>docker swarm init</code> 命令创建一个集群：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ eval $(docker-machine env manager1)
</span><span class='line'>
</span><span class='line'>$ docker swarm init --listen-addr 192.168.99.100:2377
</span><span class='line'>Swarm initialized: current node (alq8w7fi34f41j3z4ise1vkd7) is now a manager.</span></code></pre></td></tr></table></div></figure>


<p>使用 <code>docker info</code> 确认一下当前节点信息，可以看到Swarm属性部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker info
</span><span class='line'>... ...
</span><span class='line'>Swarm: active
</span><span class='line'> NodeID: alq8w7fi34f41j3z4ise1vkd7
</span><span class='line'> IsManager: Yes
</span><span class='line'> Managers: 1
</span><span class='line'> Nodes: 1
</span><span class='line'> CACertHash: sha256:7a9d0eb1621afe2be07c5fd405b8f038c76be3a8dc7b2c73944a2d1ab9dffd76
</span><span class='line'>
</span><span class='line'>... ...</span></code></pre></td></tr></table></div></figure>


<p>在2台worker节点上，通过  <code>docker swarm join</code> 命令加入到刚才创建的集群中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ eval $(docker-machine env worker1)
</span><span class='line'>$ docker swarm join 192.168.99.100:2377
</span><span class='line'>This node joined a Swarm as a worker.
</span><span class='line'>$ docker info
</span><span class='line'>... ...
</span><span class='line'>Swarm: active
</span><span class='line'> NodeID: 4l2a9ebgmcpwqlo0roye0n6m5
</span><span class='line'> IsManager: No
</span><span class='line'>... ...</span></code></pre></td></tr></table></div></figure>


<p>回到 <code>manager1</code> 节点，确认一下集群中节点的个数和状态。在 <code>MANAGER STATUS</code> 属性中，可以看到谁是Leader：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ eval $(docker-machine env manager1)
</span><span class='line'>$ docker node ls
</span><span class='line'>ID                           NAME      MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
</span><span class='line'>4l2a9ebgmcpwqlo0roye0n6m5    worker1   Accepted    Ready   Active        
</span><span class='line'>alq8w7fi34f41j3z4ise1vkd7 *  manager1  Accepted    Ready   Active        Leader
</span><span class='line'>e0khh79c6owm0e14mli602q0a    worker2   Accepted    Ready   Active        </span></code></pre></td></tr></table></div></figure>


<h2>创建nginx服务</h2>

<p>首先，创建一个覆盖网络：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker network create -d overlay ngx_net
</span><span class='line'>8kiv8muduf60f66rs99ufo25f</span></code></pre></td></tr></table></div></figure>


<p>然后使用这个覆盖网络，创建nginx服务：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service create --name nginx --replicas 1 --network ngx_net -p 80:80/tcp nginx
</span><span class='line'>78cmmh8ef4qcwmjjzgn3k45ch</span></code></pre></td></tr></table></div></figure>


<p>这样，就创建了一个具有一个副本（ <code>--replicas 1</code> ）的 <code>nginx</code> 服务，使用镜像 <code>nginx</code> 。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE           DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Preparing 9 seconds  Running        manager1</span></code></pre></td></tr></table></div></figure>


<p>注意上面的 <code>STATE</code> 字段中刚开始的服务状态为 <code>Preparing</code>，需要等一会才能变为 <code>Running</code> 状态，其中最费时间的应该是下载镜像的过程。</p>

<p>过一会再查看服务状态，就可以看到状态已经变为 <code>Running</code> 了，这是可以通过 <code>http://192.168.99.100/</code> 查看 Nginx服务。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE              DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running About a minute  Running        manager1
</span><span class='line'>
</span><span class='line'># 通过curl查看服务是否正常运行
</span><span class='line'>$ curl http://192.168.99.100/
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure>


<h2>对服务进行扩展（scale）</h2>

<p>当然，如果只是通过service启动容器，swarm也算不上什么新鲜东西了。Service还提供了复制（类似k8s里的副本）功能。可以通过 <code>docker service scale</code> 命令来设置服务中容器的副本数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service scale nginx=5
</span><span class='line'>nginx scaled to 5</span></code></pre></td></tr></table></div></figure>


<p>和创建服务一样，增加scale数之后，将会创建新的容器，这些新启动的容器也会经历从准备到运行的过程，过一分钟左右，服务应该就会启动完成，这时候可以再来看一下 <code>nginx</code> 服务中的容器（task）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE         DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running 5 minutes  Running        manager1
</span><span class='line'>co0re9u7infoo9qiegm6yiqcn  nginx.2  nginx    nginx  Running 2 minutes  Running        worker1
</span><span class='line'>19dvayah8fjz3vykrl2oi12uu  nginx.3  nginx    nginx  Running 2 minutes  Running        worker1
</span><span class='line'>d8okdip767972p083tix4dk7d  nginx.4  nginx    nginx  Running 2 minutes  Running        manager1
</span><span class='line'>9rq59mf6bq5m411y6gdzb5pq6  nginx.5  nginx    nginx  Running 2 minutes  Running        worker2</span></code></pre></td></tr></table></div></figure>


<p>可以看到，之前 <code>nginx</code> 容器只在 <code>manager1</code> 上有一个实例，而现在又增加了4个实例。</p>

<p>我们可以在 <code>manager1</code> 上查看一下这台主机上运行的容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
</span><span class='line'>4bbc02bc426e        nginx:latest        "nginx -g 'daemon off"   4 minutes ago       Up 4 minutes        80/tcp, 443/tcp     nginx.4.d8okdip767972p083tix4dk7d
</span><span class='line'>1eda6f7d3029        nginx:latest        "nginx -g 'daemon off"   5 minutes ago       Up 5 minutes        80/tcp, 443/tcp     nginx.1.394by1b72i44a44jms2xwk6ud</span></code></pre></td></tr></table></div></figure>


<h2>容器异常停止时的处理</h2>

<p>如果一个服务中的一个任务突然终止了，Docker会怎么处理？这里我们就来模拟某一容器异常终止的情况。</p>

<p>在操作之前，我们在另一个窗口，准备好使用 <code>tail -f /var/log/docker.log</code> 命令来查看Docker守护进程的日志。</p>

<p>我们通过 <code>docker rm -f</code> 来删除一个容器（<code>4b</code> 表示的是我们第一个启动的 <code>4bbc02bc426e</code> 容器）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker rm -f 4b
</span><span class='line'>4b
</span></code></pre></td></tr></table></div></figure>


<p>回到Docker守护进程的日志查看窗口，我们会看到类似这样的日志（有删减），从日志中，我们可以看到旧容器（id为 <code>4bbc02bc426e</code> ，task id为 <code>d8okdip767972p083tix4dk7d</code>）的删除和新容器（task id为 <code>cumjdktbadaxca66rt4hi63na</code>）的调度过程（删除了日志中的时间戳和日志级别等非重要信息，但保留了日志的时间顺序）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 调用删除容器的API
</span><span class='line'>msg="Calling DELETE /v1.24/containers/4b?force=1" 
</span><span class='line'>
</span><span class='line'># d8的任务从RUNNING变为了FAILED状态
</span><span class='line'>msg="state changed" module=taskmanager state.desired=RUNNING state.transition="RUNNING-&gt;FAILED" task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>
</span><span class='line'># 将旧任务停止
</span><span class='line'>msg=assigned module=agent task.desiredstate=SHUTDOWN task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>
</span><span class='line'># 分配到新的节点，创建新的任务id： cumj
</span><span class='line'>msg="Assigning to node e0khh79c6owm0e14mli602q0a" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 旧任务状态更新为FAILED
</span><span class='line'>msg="(*Agent).UpdateTaskStatus" module=agent task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="FAILED-&gt;FAILED" task.id=d8okdip767972p083tix4dk7d 
</span><span class='line'>
</span><span class='line'># 新任务从ASSIGNED变为接受状态
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="ASSIGNED-&gt;ACCEPTED" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 准备运行新任务
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="ACCEPTED-&gt;PREPARING" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 运行新任务
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="PREPARING-&gt;STARTING" task.id=cumjdktbadaxca66rt4hi63na 
</span><span class='line'>
</span><span class='line'># 新任务启动完成
</span><span class='line'>msg="task status updated" method="(*Dispatcher).processTaskUpdates" module=dispatcher state.transition="STARTING-&gt;RUNNING" task.id=cumjdktbadaxca66rt4hi63na 
</span></code></pre></td></tr></table></div></figure>


<p>从上面的日志我们不难看出，一个任务的生命周期的前半生，大概就是 <code>ASSIGNED</code> -> <code>ACCEPTED</code> -> <code>PREPARING</code> -> <code>STARTING</code> -> <code>RUNNING</code> 。</p>

<p>在 <code>manager1</code>主机上，我们看到这个容器已经删除了， <code>ps</code> 只能看到一个容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
</span><span class='line'>1eda6f7d3029        nginx:latest        "nginx -g 'daemon off"   6 minutes ago       Up 6 minutes        80/tcp, 443/tcp     nginx.1.394by1b72i44a44jms2xwk6ud</span></code></pre></td></tr></table></div></figure>


<p>再来查看一下 <code>nginx</code> 服务的任务列表，可以看到新创建的任务 <code>cumjdktbadaxca66rt4hi63na</code> 被调度到了 <code>worker2</code> 上运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE          DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running 8 minutes   Running        manager1
</span><span class='line'>co0re9u7infoo9qiegm6yiqcn  nginx.2  nginx    nginx  Running 5 minutes   Running        worker1
</span><span class='line'>19dvayah8fjz3vykrl2oi12uu  nginx.3  nginx    nginx  Running 5 minutes   Running        worker1
</span><span class='line'>cumjdktbadaxca66rt4hi63na  nginx.4  nginx    nginx  Running 32 seconds  Running        worker2
</span><span class='line'>9rq59mf6bq5m411y6gdzb5pq6  nginx.5  nginx    nginx  Running 5 minutes   Running        worker2</span></code></pre></td></tr></table></div></figure>


<h2>删除一个节点？</h2>

<p>不难想象，如果一个节点都宕机了，则Docker应该会将在该节点运行的容器，调度到其他节点，以满足指定数量的副本保持运行状态。</p>

<p>下面我们就来模拟一下这种场景。</p>

<p>首先，我们删除一个节点 <code>worker2</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker-machine rm worker2
</span><span class='line'>About to remove worker2
</span><span class='line'>Are you sure? (y/n): y
</span><span class='line'>Successfully removed worker2</span></code></pre></td></tr></table></div></figure>


<p>删除之后，Docker就会开始重新调度，最终调度结束（&lt; 1分钟）后，再查看该服务的任务状态，应该如下面这样，有5个 <code>nginx</code> 容器在剩下的两台机器上运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service tasks nginx
</span><span class='line'>ID                         NAME     SERVICE  IMAGE  LAST STATE          DESIRED STATE  NODE
</span><span class='line'>394by1b72i44a44jms2xwk6ud  nginx.1  nginx    nginx  Running 22 minutes  Running        manager1
</span><span class='line'>co0re9u7infoo9qiegm6yiqcn  nginx.2  nginx    nginx  Running 19 minutes  Running        worker1
</span><span class='line'>19dvayah8fjz3vykrl2oi12uu  nginx.3  nginx    nginx  Running 19 minutes  Running        worker1
</span><span class='line'>991v97eg9q1hnnzxda6c9mmv7  nginx.4  nginx    nginx  Running 20 seconds  Running        manager1
</span><span class='line'>e9yztfmy5luaxnadz80e5j8nl  nginx.5  nginx    nginx  Running 20 seconds  Running        manager1</span></code></pre></td></tr></table></div></figure>


<p>除了上面用到的一些命令， <code>docker service</code> 还有以下一些子命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service --help
</span><span class='line'>
</span><span class='line'>Usage:    docker service COMMAND
</span><span class='line'>
</span><span class='line'>Manage Docker services
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>      --help   Print usage
</span><span class='line'>
</span><span class='line'>Commands:
</span><span class='line'>  create      Create a new service
</span><span class='line'>  inspect     Inspect a service
</span><span class='line'>  tasks       List the tasks of a service
</span><span class='line'>  ls          List services
</span><span class='line'>  rm          Remove a service
</span><span class='line'>  scale       Scale one or multiple services
</span><span class='line'>  update      Update a service
</span><span class='line'>
</span><span class='line'>Run 'docker service COMMAND --help' for more information on a command.</span></code></pre></td></tr></table></div></figure>


<p>比如我们可以用 <code>docker service inspect</code> 来获得 <code>nginx</code> 服务的详情信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service inspect nginx
</span><span class='line'>[
</span><span class='line'>    {
</span><span class='line'>        "ID": "78cmmh8ef4qcwmjjzgn3k45ch",
</span><span class='line'>        "Version": {
</span><span class='line'>            "Index": 32
</span><span class='line'>        },
</span><span class='line'>        "CreatedAt": "2016-06-21T08:31:21.427244594Z",
</span><span class='line'>        "UpdatedAt": "2016-06-21T08:33:50.75625288Z",
</span><span class='line'>        "Spec": {
</span><span class='line'>            "Name": "nginx",
</span><span class='line'>            "TaskTemplate": {
</span><span class='line'>                "ContainerSpec": {
</span><span class='line'>                    "Image": "nginx"
</span><span class='line'>                },
</span><span class='line'>                "Resources": {
</span><span class='line'>                    "Limits": {},
</span><span class='line'>                    "Reservations": {}
</span><span class='line'>                },
</span><span class='line'>                "RestartPolicy": {
</span><span class='line'>                    "Condition": "any",
</span><span class='line'>                    "MaxAttempts": 0
</span><span class='line'>                },
</span><span class='line'>                "Placement": {}
</span><span class='line'>            },
</span><span class='line'>            "Mode": {
</span><span class='line'>                "Replicated": {
</span><span class='line'>                    "Replicas": 5
</span><span class='line'>                }
</span><span class='line'>            },
</span><span class='line'>            "UpdateConfig": {},
</span><span class='line'>            "Networks": [
</span><span class='line'>                {
</span><span class='line'>                    "Target": "8kiv8muduf60f66rs99ufo25f"
</span><span class='line'>                }
</span><span class='line'>            ],
</span><span class='line'>            "EndpointSpec": {
</span><span class='line'>                "Mode": "vip",
</span><span class='line'>                "Ports": [
</span><span class='line'>                    {
</span><span class='line'>                        "Protocol": "tcp",
</span><span class='line'>                        "TargetPort": 80,
</span><span class='line'>                        "PublishedPort": 80
</span><span class='line'>                    }
</span><span class='line'>                ]
</span><span class='line'>            }
</span><span class='line'>        },
</span><span class='line'>        "Endpoint": {
</span><span class='line'>            "Spec": {},
</span><span class='line'>            "Ports": [
</span><span class='line'>                {
</span><span class='line'>                    "Protocol": "tcp",
</span><span class='line'>                    "TargetPort": 80,
</span><span class='line'>                    "PublishedPort": 80
</span><span class='line'>                }
</span><span class='line'>            ],
</span><span class='line'>            "VirtualIPs": [
</span><span class='line'>                {
</span><span class='line'>                    "NetworkID": "e9et32s47olva4e0uisamdqao",
</span><span class='line'>                    "Addr": "10.255.0.6/16"
</span><span class='line'>                },
</span><span class='line'>                {
</span><span class='line'>                    "NetworkID": "8kiv8muduf60f66rs99ufo25f",
</span><span class='line'>                    "Addr": "10.0.0.2/24"
</span><span class='line'>                }
</span><span class='line'>            ]
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<p>也可以通过 <code>docker service rm nginx</code> 命令，删除 <code>nginx</code> 服务（现在的版本删除服务前没有警告提示，请小心操作）。</p>

<h2>总结</h2>

<p>上手很简单，Docker swarm可以非常方便的创建类似k8s那样带有副本的服务，确保一定数量的容器运行，保证服务的高可用。</p>

<p>然而，光从官方文档来说，功能似乎又有些简单，从生产环境来说，下面这些方面都还有所欠缺（其实从Swarm v1就有这个问题）：</p>

<ul>
<li>没有配置文件，不好进行版本化管理，不方便部署</li>
<li>持久存储的缺失。Docker已经支持Volume Driver，k8s等也有存储卷插件在机制，真正的生产环境没有Volume支持估计是很难想象的。</li>
<li>是否能确保本身的高可用</li>
<li>调度策略还处于初级阶段</li>
</ul>


<p>不过，正如Docker让容器技术变得平民化一样，Docker Machine和Swarm，也将在各种基础设施上运行Docker和Docker集群变得更加简单，从这一点上来说，其意义也是很大的。</p>

<p>不过在开源社区和商业竞争的角度来看，Docker Swarm将会走向何方呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年5月读书记录]]></title>
    <link href="http://liubin.github.io/blog/2016/06/18/05-reading/"/>
    <updated>2016-06-18T19:07:29+08:00</updated>
    <id>http://liubin.github.io/blog/2016/06/18/05-reading</id>
    <content type="html"><![CDATA[<p>5月读完的，大概只有一本。</p>

<h2>《途客圈创业记：不疯魔，不成活》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28482679.jpg" alt="途客圈创业记：不疯魔，不成活" /></p>

<p>推荐指数：★★★★★</p>

<p>和作者陈天有过一面之缘，还是在几年前国内第一次Docker Meetup，有幸和陈天同台分享了一下Docker方面的内容，我的偏向于原理介绍，他的更偏实战，很像他的风格。</p>

<p>这本书讲述了陈天自己从兴趣开始，如何自己写原型，参加demo day类似的活动，找合伙人、组建团队，找投资，做产品，涉及到了一个创意从想出点子，到实现、上线的过程。</p>

<p>如果你是初出道的创业者，刚只是有一些点子和想法而已，那么这本书绝对值得参考，前人的经验，能帮你避免犯一些没有必要的错误。</p>

<p>我个人有一些感触，这里列出几点简单介绍一下。</p>

<h3>管理团队</h3>

<p>管理团队很重要，以至于很多投资人的理念其实是投人、投团队，也就是人靠谱，给你钱干什么都行。</p>

<p>这方面主要问题是管理团队的构成、分工以及定位。在能力上最好是互补的，比如市场、销售、技术活产品等。</p>

<p>而定位很重要，本书作者的一大经验就是陈天作为创始人、大股东、产品负责人是事实上的核心，而CEO则有些被边缘化。所以说，每个人的定位要明确，一个萝卜一个坑，有什么事都能找到唯一一个、明确的负责人，员工有事了，知道什么事该找什么人。</p>

<p>一个公司如果对高层的分工都不明确，可以说是CEO没有从大局上来让公司员工能有一个统一的认识，没有明确的的定义出管理团队的架构。</p>

<p>项目也是，最烦一件事不知道找谁，每个人都想支一嘴。</p>

<h3>控制产品</h3>

<p>如果说99%的创业都会失败，我觉得其中90%的原因都是其产品并非“刚需”。你的刚需不一定是别人的刚需，产品还需要吃场和运营的验证。</p>

<p>这时候，又有一个词叫Pivot，愿意有“关键转折”或者“战略调整”的意思，在精益创业中一般指根据公司、产品的运营现状（尤其是运行出现问题或者出现重大机会，多指前者）时，改变公司的产品形式和方向、营销策略、公司战略等。</p>

<p>最简单的方法就是产品出来之后，根据用户和媒体的反响，以及各种运营数据来判断是否能达到预期，如果持续数据不太乐观，就必须要考虑产品的问题了。</p>

<p>第一版就抓到用户刚需，成为装机必备的软件，几率太低，多出产品都是通过不停的发布、反馈和调整来不断进行优化的。</p>

<p>在对产品进行调整时，即依赖于团队的能力、经验，坏的情况下，可能还会导致团队分歧、影响战斗力。</p>

<h3>控制节奏</h3>

<p>节奏包括产品的节奏，公司发展的规模等。不能太慢，互联网不是讲唯快不破么；也不能过快，繁华背后都会有隐忧，过快的发展可能会使危机不断地积蓄和发酵，大规模爆发时说不定会超出处理能力。</p>

<p>要有张有弛，控制节奏。就像跑马拉松，首先要上路，不能上来就找不到方向；其次要坚持，创业不是短跑，用尽全力会倒在强弩之末。</p>

<p>不过遗憾的是，途客圈没有完成下一轮融资，不得不被合并了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker 1.12.0将要发布的新功能]]></title>
    <link href="http://liubin.github.io/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0/"/>
    <updated>2016-06-17T18:27:03+08:00</updated>
    <id>http://liubin.github.io/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0</id>
    <content type="html"><![CDATA[<p>按计划，6/14 是1.12.0版本的 <a href="https://github.com/docker/docker/wiki">feature冻结</a> 的日子，再有两个星期Docker 1.12.0也该发布了。这里列出来的新功能，都是已经合并到主分支的功能，不出意外，下一个版本的Docker应该是能体验到了。</p>

<p>下周2016 DockerCon也该开始了，好像也有一场专门来讲Docker新特性的，不过在这之前，我们就可以抢先一步，浏览一下这些新功能、新特性。尤其是前两个，都是比较吸引人的功能。</p>

<h2>Swarmkit集成</h2>

<p>前几天Docker刚刚发布了 <a href="https://github.com/docker/swarmkit">Swarmkit</a> ，也就是Swarm V2。</p>

<p>同时，在这个版本的Docker中，Swarm/Swarmkit 相关命令也被整合到了Docker子命令中。这可能算得上是1.12.0版本中最大的变更点了。</p>

<p><a href="https://github.com/docker/docker/pull/23361">这个PR（Add dependency to docker/swarmkit）</a> 有600个文件变动。
除了传统的image和container对象，这个PR增加了task和service等资源类型。</p>

<p>相关几个子PR包括 <a href="https://github.com/docker/docker/pull/23362">23362</a> 、<a href="https://github.com/docker/docker/pull/23363">23363</a> 、 <a href="https://github.com/docker/docker/pull/23364">23364</a>。</p>

<p>使用新的Docker命令，可以这样直接创建Swarm集群：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker swarm init --listen-addr 192.168.99.100:2377
</span><span class='line'>Swarm initialized: current node (09fm6su6c24qn) is now a manager.</span></code></pre></td></tr></table></div></figure>


<p>查看节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker node ls
</span><span class='line'>ID              NAME      MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS  LEADER
</span><span class='line'>09fm6su6c24q *  manager1  Accepted    Ready   Active        Reachable       Yes</span></code></pre></td></tr></table></div></figure>


<p>然后这样来部署一个新的service：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service create --scale 1 --name helloworld alpine ping docker.com
</span><span class='line'>2zs4helqu64f3k3iuwywbk49w
</span><span class='line'>
</span><span class='line'>$ docker service ls
</span><span class='line'>ID            NAME        SCALE  IMAGE   COMMAND
</span><span class='line'>2zs4helqu64f  helloworld  1      alpine  ping docker.com</span></code></pre></td></tr></table></div></figure>


<p>需要scale了？没关系，也可以在Docker中直接完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service update --scale 5 helloworld
</span><span class='line'>helloworld
</span><span class='line'>
</span><span class='line'>$ docker service tasks helloworld
</span><span class='line'>ID                         NAME          SERVICE     IMAGE   DESIRED STATE  LAST STATE          NODE
</span><span class='line'>1n6wif51j0w840udalgw6hphg  helloworld.1  helloworld  alpine  RUNNING        RUNNING 2 minutes   manager1
</span><span class='line'>dfhsosk00wxfb7j0cazp3fmhy  helloworld.2  helloworld  alpine  RUNNING        RUNNING 15 seconds  worker2
</span><span class='line'>6cbedbeywo076zn54fnwc667a  helloworld.3  helloworld  alpine  RUNNING        RUNNING 15 seconds  worker1
</span><span class='line'>7w80cafrry7asls96lm2tmwkz  helloworld.4  helloworld  alpine  RUNNING        RUNNING 10 seconds  worker1
</span><span class='line'>bn67kh76crn6du22ve2enqg5j  helloworld.5  helloworld  alpine  RUNNING        RUNNING 10 seconds  manager1</span></code></pre></td></tr></table></div></figure>


<p>在一台机器上使用 <code>docker ps</code> :</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps
</span><span class='line'>
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span class='line'>910669d5e188        alpine:latest       "ping docker.com"   10 seconds ago      Up 10 seconds                           helloworld.5.bn67kh76crn6du22ve2enqg5j
</span><span class='line'>a0b6c02868ca        alpine:latest       "ping docker.com"   2 minutes  ago      Up 2 minutes                            helloworld.1.1n6wif51j0w840udalgw6hphg
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以这样使用 <code>dcoekr service</code> 子命令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker service create --scale 3 --name redis --update-delay 10s --update-parallelism 1 redis:3.0.6
</span><span class='line'>
</span><span class='line'>69uh57k8o03jtqj9uvmteodbb
</span><span class='line'>$ docker service tasks redis
</span><span class='line'>ID                         NAME     SERVICE  IMAGE        LAST STATE          DESIRED STATE  NODE
</span><span class='line'>3wfqsgxecktpwoyj2zjcrcn4r  redis.1  redis    redis:3.0.6  RUNNING 13 minutes  RUNNING        worker2
</span><span class='line'>8lcm041z3v80w0gdkczbot0gg  redis.2  redis    redis:3.0.6  RUNNING 13 minutes  RUNNING        worker1
</span><span class='line'>d48skceeph9lkz4nbttig1z4a  redis.3  redis    redis:3.0.6  RUNNING 12 minutes  RUNNING        manager1</span></code></pre></td></tr></table></div></figure>


<p>总之，新的Docker和Swarm结合在一起，管理集群和服务将会更方便。</p>

<h2>插件管理（Plugin repository，experimental版）</h2>

<p>PR地址： <a href="https://github.com/docker/docker/pull/23446">https://github.com/docker/docker/pull/23446</a></p>

<p>插件管理功能可能算是第二大变更点了。很多软件都支持插件机制，大家比较熟悉的从Wordpress到ElasticSearch等，都支持在软件内部通过plugin功能安装、管理插件。</p>

<p>Docker最近也增加了一些网络和卷管理的插件功能，这次还在体验版中增加了插件（基于容器）管理功能，可以通过 <code>docker plugin</code> 命令来管理插件。除了提供了一个统一的插件管理入口，还可以对插件的生命周期进行更好的管理，Docker君，我的插件写的比较不专业，请罩着我点。</p>

<p>这是一个大概的使用示意，通过 <code>docker plugin install</code> 可以安装插件， <code>docker plugin ls</code> 可以列出当前安装的插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker plugin install aragunathan/no-remove
</span><span class='line'>Plugin "aragunathan/no-remove:latest" requested the following privileges:
</span><span class='line'> - Networking: host
</span><span class='line'> - Mounting host path: /data
</span><span class='line'>Do you grant the above permissions? [y/N] y</span></code></pre></td></tr></table></div></figure>


<p>查看插件列表：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker plugin ls
</span><span class='line'>NAME                    VERSION             ACTIVE
</span><span class='line'>aragunathan/no-remove   latest              true</span></code></pre></td></tr></table></div></figure>


<p>目前 <code>docker plugin</code> 支持如下子命令：</p>

<ul>
<li>plugin ls</li>
<li>plugin enable</li>
<li>plugin inspect</li>
<li>plugin install</li>
<li>plugin rm</li>
</ul>


<h2>增加 <code>overlay2</code> 存储驱动（PR#22126 Overlay multiple lower directory support）</h2>

<p><a href="https://github.com/docker/docker/pull/22126">这个PR</a> 增加一个新的名为 <code>overlay2</code> 的驱动，以解决Docker在存储优化方面的不足，充分利用4.0内核的 <code>lower directories</code> 新特性，解决inode耗尽等问题。</p>

<p>这个PR中的描述也提到了新旧overlay驱动的性能对比数据，有兴趣的可以参考一下。</p>

<h2>Live restore</h2>

<p><a href="https://github.com/docker/docker/pull/23213">这个PR</a> 最大的好处就是提供了对daemonless容器的支持，即使daemon宕了，容器也不会受影响。</p>

<p>使用方法就是在启动 <code>dockerd</code> 的时候，增加 <code>--live-restore</code> 标志。</p>

<p>你是不是特别喜欢这个功能？</p>

<h2>Healthcheck</h2>

<p><code>docker run</code> 和 <code>Dockerfile</code> 新增加的 <a href="https://github.com/docker/docker/pull/23218">健康检查功能</a>。</p>

<p>比如在 <code>docker run</code> 中，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker run --name=test -d \
</span><span class='line'>    --health-cmd='stat /etc/passwd || exit 1' \
</span><span class='line'>    --health-interval=2s \
</span><span class='line'>    busybox sleep 1d</span></code></pre></td></tr></table></div></figure>


<p>查看健康状态，返回 <code>healthy</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sleep 2; docker inspect --format='' test
</span><span class='line'>healthy</span></code></pre></td></tr></table></div></figure>


<p>故意删除 <code>/etc/passwd</code> 文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker exec test rm /etc/passwd</span></code></pre></td></tr></table></div></figure>


<p>再次查看节点健康状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sleep 2; docker inspect --format='' test
</span><span class='line'>{
</span><span class='line'>  "Status": "unhealthy",
</span><span class='line'>  "FailingStreak": 3,
</span><span class='line'>  "Log": [
</span><span class='line'>    {
</span><span class='line'>      "Start": "2016-05-25T17:22:04.635478668Z",
</span><span class='line'>      "End": "2016-05-25T17:22:04.7272552Z",
</span><span class='line'>      "ExitCode": 0,
</span><span class='line'>      "Output": "  File: /etc/passwd\n  Size: 334       \tBlocks: 8          IO Block: 4096   regular file\nDevice: 32h/50d\tInode: 12          Links: 1\nAccess: (0664/-rw-rw-r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2015-12-05 22:05:32.000000000\nModify: 2015..."
</span><span class='line'>    },
</span><span class='line'>    {
</span><span class='line'>      "Start": "2016-05-25T17:22:06.732900633Z",
</span><span class='line'>      "End": "2016-05-25T17:22:06.822168935Z",
</span><span class='line'>      "ExitCode": 0,
</span><span class='line'>      "Output": "  File: /etc/passwd\n  Size: 334       \tBlocks: 8          IO Block: 4096   regular file\nDevice: 32h/50d\tInode: 12          Links: 1\nAccess: (0664/-rw-rw-r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2015-12-05 22:05:32.000000000\nModify: 2015..."
</span><span class='line'>    },
</span><span class='line'>    {
</span><span class='line'>      "Start": "2016-05-25T17:22:08.823956535Z",
</span><span class='line'>      "End": "2016-05-25T17:22:08.897359124Z",
</span><span class='line'>      "ExitCode": 1,
</span><span class='line'>      "Output": "stat: can't stat '/etc/passwd': No such file or directory\n"
</span><span class='line'>    }
</span><span class='line'>  ]
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h2>其他改进</h2>

<p>除了上述能单独拿出来的，要么比较重量级，要么非常实用的功能，Docker还有很多其他方面的改进。这里我们简单看看其中的一些。</p>

<h3><code>dockerd</code> 和 <code>docker</code> 二进制文件分离</h3>

<p><code>docker daemon</code> 改为了 <code>dockerd</code> ，这样以后就需要使用两个可执行程序了。</p>

<p>PR： <a href="https://github.com/docker/docker/pull/22386">https://github.com/docker/docker/pull/22386</a></p>

<h3>为 <code>btrfs</code> 存储驱动增加容器 <code>rootfs</code> 的限额功能</h3>

<p>类似这样，可以在Docker守护进程或者容器级别设置根文件系统的大小：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker daemon --storage-opt btrfs.min_space=xx
</span><span class='line'>$ docker run --storage-opt size=xx</span></code></pre></td></tr></table></div></figure>


<p>PR1：<a href="https://github.com/docker/docker/pull/19651">https://github.com/docker/docker/pull/19651</a>
PR2：<a href="https://github.com/docker/docker/pull/19367">https://github.com/docker/docker/pull/19367</a></p>

<h3><code>docker search</code> 增加 <code>--limit</code> 和 <code>filter</code> 参数</h3>

<ul>
<li><code>--limit</code> 参数</li>
</ul>


<p><code>docker search</code> 命令增加了一个 <code>--limit</code> 参数，可以设置查找镜像的返回结果个数。这个参数的默认值为25，可以接受的范围是0-100（实际上好像服务端最多只能返回100条记录）。</p>

<p>PR：<a href="https://github.com/docker/docker/pull/23107">https://github.com/docker/docker/pull/23107</a></p>

<ul>
<li><code>--filter</code> 参数</li>
</ul>


<p>比如可以指定只返回官方镜像，或者返回一定数量star的镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker search --filter is-official=true ubuntu
</span><span class='line'>
</span><span class='line'>$ docker search --filter stars=30 ubuntu
</span></code></pre></td></tr></table></div></figure>


<p>PR：<a href="https://github.com/docker/docker/pull/22369">https://github.com/docker/docker/pull/22369</a></p>

<h3><code>docker ps</code> 命令增加 <code>--filter network=xxx</code>参数</h3>

<p>只列出指定网络模式的容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker run -d --net=bridge --name=onbridgenetwork busybox top
</span><span class='line'>$ docker run -d --net=none --name=onnonenetwork busybox top
</span><span class='line'>
</span><span class='line'>$ docker ps --filter network=bridge </span></code></pre></td></tr></table></div></figure>


<p>PR： <a href="https://github.com/docker/docker/pull/23300">https://github.com/docker/docker/pull/23300</a></p>

<h3><code>pid</code> 支持指定其他容器的pid</h3>

<p>在之前的版本中，<code>pid</code> 参数只支持 <code>host</code> 模式，现在也可以和其他容器共享PID命名空间了。这也可能是一个比较实用的功能。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker run --name my-redis -d redis
</span><span class='line'>
</span><span class='line'>$ # 在其他容器中使用strace进行调试
</span><span class='line'>
</span><span class='line'>$ docker run --it --pid=container:my-redis bash
</span><span class='line'>$ strace -p 1</span></code></pre></td></tr></table></div></figure>


<p>PR： <a href="https://github.com/docker/docker/pull/22481">https://github.com/docker/docker/pull/22481</a></p>

<h3><code>docker network ls</code> 新增了两种过滤类型</h3>

<p><code>docker network ls</code> 也增加了两种类型的过滤</p>

<ul>
<li>按驱动类型过滤</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker network ls --filter driver=bridge
</span><span class='line'>NETWORK ID          NAME                DRIVER
</span><span class='line'>db9db329f835        test1               bridge
</span><span class='line'>f6e212da9dfd        test2               bridge</span></code></pre></td></tr></table></div></figure>


<p>PR： <a href="https://github.com/docker/docker/pull/22319">https://github.com/docker/docker/pull/22319</a></p>

<ul>
<li>按label过滤</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker network ls -f "label=usage"
</span><span class='line'>NETWORK ID          NAME                DRIVER
</span><span class='line'>db9db329f835        test1               bridge              
</span><span class='line'>f6e212da9dfd        test2               bridge</span></code></pre></td></tr></table></div></figure>


<p>PR: <a href="https://github.com/docker/docker/pull/21495">https://github.com/docker/docker/pull/21495</a></p>

<h3>CLI子命令重构</h3>

<p>很多Docker 子命令都采用 <a href="https://github.com/spf13/cobra">cobra</a> 对CLI进行了重构，应该不算是什么大的改动。</p>

<h2>总结</h2>

<p>当然，还有类似小的一些改进，这里并没有都列出来，到时候大家看一下参考手册就能见到了，也许很多功能大家根本就不会用到：-）</p>

<p>到这里我们简单的就浏览了一下新版本的Docker中将会搭载的新功能，如果你觉得哪些是你想要的，就等着Docker 1.12.0的发布吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年4月读书记录]]></title>
    <link href="http://liubin.github.io/blog/2016/05/26/04-reading/"/>
    <updated>2016-05-26T23:13:27+08:00</updated>
    <id>http://liubin.github.io/blog/2016/05/26/04-reading</id>
    <content type="html"><![CDATA[<p>这两个月效率非常低，也没什么兴致。4月读的书不多，总结也拖到了5月底，最近私事较多，希望6越以后能好转，至少可以不用为别的事分心。</p>

<p>4月读了3本书，2本电子书，1本纸版。</p>

<p>其中一本《HBase in action》的中文版，这是人邮异步社区送的电子版，在Kindle阅读器上读的，效果不是特别理想，这种书，还是得买纸版，或者在电脑的Kindle软件上才好吧。</p>

<p>另外有两本非技术书，一本是《互联网运营之道》，一本是《共享经济：互联网时代如何实现股东、员工与顾客的共赢》</p>

<h2>《HBase实战》</h2>

<p><img src="https://img3.doubanio.com/lpic/s27020560.jpg" alt="HBase实战" /></p>

<p>推荐指数：★★★★</p>

<p>这个是计算机书籍，讲的HBase的方方面面，从原理入门到线上运维和实际环境的配置等都有涉及，非常适合入门HBase。</p>

<p>从英文名字也可以看出，In Action系列一般来说都是非常值得信赖的。</p>

<h2>《共享经济：互联网时代如何实现股东、员工与顾客的共赢》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28024129.jpg" alt="互联网运营之道" /></p>

<p>推荐指数：★★★★★</p>

<p>媒介：Kindle</p>

<p>这本书是误打误撞读到的。本来是想看看和共享经济相关的书，但被本书的标题迷惑了，实际副标题更体现了本书的主要思想，那就是如何通过信任来实现股东、员工与顾客的共赢。</p>

<p>本书的核心，就是围绕着信任两字来讲的。</p>

<p>随着社会和科技的进步，透明度也会提高，加强了人和人之间的互动，真正的实现了“坏事传千里”。随着人们之间的交往越来越高效，信任也正在逐渐成为人类文化的一个根本属性，如果按照传统的思维，企业提供高质量的产品，完善的售后，不一定就能在竞争中利于不败之地，而是需要一种全新的方式，体现自己的“值得信赖”。</p>

<p>书中举了很多例子来说明，如何让客户觉得企业可信，是站在自己的这一边的。</p>

<blockquote><p>我的一个朋友托马斯在网上订购了一套三件组合的桌子，其中两件顺利到货，但是第三件一星期之后还没送到。于是，托马斯打电话到公司询问，结果发现第三件被快递公司送错了地方，发到了另外一个配送中心，商品被送到了其他城市。在线零售客服很快解决了这个问题：“先生，发生这样的状况我们很抱歉。我们马上为您更换货物，用连夜快递为您配送剩下的一件，这样您明天就能收到货物。”我的朋友本来打算大发牢骚，但是客服及时地解决了问题，一下子让我的朋友心情缓和下来。当客服说“由于我们给您带来的不便，我们将会向您的信用卡返还25美元”时，我的朋友说这不是零售商的错，而是物流公司的错。客服说：“请您别担心，我们只是想确保您明天能够在您的新办公桌前办公。”这样的服务算是好的客户服务吗？这说明这家公司有良好的意图，还是有能力？谁在意呢？反正这样的公司就是人们能依靠的公司。这样的公司是完全值得人们依赖的公司。</p>

<p>无数研究表明，医疗事故投诉的最大导火索不是医生的技术，而是他们对病人的态度。不管医生的技术如何，病人们是不会控告那些被他们当作朋友的、具有同理心的医务人员的。但是，一旦医生（或公司）没能与病人建立友好的关系，或者没能表现出同理心，和他们相处时没有展示出“人性的面孔”，那么他们很可能就会遭到更多的投诉。</p>

<p>我们的房地产经纪人卡伦·凯利（Karen Kelly）是柯克兰集团（Corcoran Group）的，她带我们用几天时间看了40套公寓。最后当我们把选择的范围缩小到3套公寓时，我们突然接到一个朋友的电话，说他正在帮业主卖一套传统的合作公寓20。于是我们打电话给卡伦，问她该怎么做。她建议我们先去看看那套公寓，我们去后发现那套公寓非常不错。尽管卡伦从中得不到半分佣金，但她却带着很多有用的资料——包括建筑的历史、维修记录以及纳税信息，赶到我们这边。后来我们坚持要把这套公寓当作是她负责的，付给她买方应付的费用。因为即便她从这笔交易当中赚不到钱，她还是希望我们能够买到合适的公寓。从那以后，我们介绍了好几个人给她，包括买主和卖主。能帮我们的朋友在曼哈顿找到一个真正可以信任的房地产经纪人，我们会觉得自己为朋友帮上了忙。同时，我们当然也很希望看到卡伦获得成功！</p>

<p>一个值得依赖的汽车品牌会在保修期到期30天前给你发邮件或者打电话，这样一来，如果你有任何需要维修的地方，都能趁着保修期内及时地得到维修。</p></blockquote>

<p>还有几个例子，也很有趣，我忘了作者是要说明什么问题来着：</p>

<blockquote><p>在统计推理存在问题的案例当中，最臭名昭著的案例之一要数辛普森杀妻案。诉讼方认为，由于辛普森在过去经常对妻子妮可·辛普森实施暴力，所以他非常有可能谋杀了妻子。辩护律师轻易地推翻了这个论点，告诉陪审团说，上一年遭受丈夫家庭暴力的女性有400万，但是每2500人当中只有1人真正遭到谋杀。这一论点在当时显得非常具有说服力，无法驳倒，反映了诉讼方完全缺乏统计方面的知识（新闻媒体、法律评论员以及其他人在案件的展开过程中，评估案件时都反映出了同样的问题）。不论你对最后的裁决持什么样的观点，要是诉讼方当时指出另一项相关性更大的统计数据，案件的结果可能就不一样了。这项统计就是：上一年所有被丈夫殴打后又被谋杀的女性当中，90%都是被实施家暴的丈夫杀害的。</p>

<p>20世纪70年代，西班牙一名男子特意挑选了一张尾数为48的彩票，结果中奖了。他得意洋洋地告诉别人自己的“策略”，说：“我连续7天都梦到7这个数字，7乘以7就是48。”</p></blockquote>

<p>作者也认为企业应该抛弃“控制”，因为复杂系统没有自然科学那样的规律性和可预测性，尤其是不可预测的反馈系统：“跟推陀螺一样，如果你试图控制某个系统的行为，就很有可能失败，因为系统的反馈回路会产生意想不到的效果”。放弃控制，说到底就是要信任他人，并帮助他们相信你。如果希望你的员工对工作真正投入，你就必须准备好放弃一部分控制，相信他们能够把事情做好。</p>

<p>当然，本书也不是完全和共享无关。作者认为，随着社会的进步，人们更愿意和别人分享自己的知识和经验，更愿意与人交流，形成所谓的“社交经济”：不以经济目标为主，而是为了获得尊重、个人价值、社会地位和满足感等等非经济“利益”。这就是一种共享的文化，共享知识和数据，并享受这个过程。</p>

<p>企业必须积极关注顾客利益，甚至比顾客还关注顾客利益，才能真正的“俘获人心”，获得顾客的深度信任。企业也应该做到透明，而技术的进步也让社会更透明，“纸里包不住火”，该暴露的丑闻早晚大白于天下，如果<strong>顾客都不相信你，撒谎将没有任何意义</strong>。</p>

<p>企业也应该真诚的暴露自己的问题和缺点，没有完美的公司，如果你可以隐藏缺点，只是一味的吹嘘自己的有点，顾客就会认为企业一定在刻意隐瞒什么。有时候，为了赢得别人的信任，学会暴露自己的缺点很重要。</p>

<p>总之，真本书还是非常推荐读一下的，如果你真的是把客户当“上帝”的话。</p>

<h2>《互联网运营之道》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28363838.jpg" alt="互联网运营之道" /></p>

<p>推荐指数：★★★☆☆</p>

<p>媒介：纸版</p>

<p>看书的介绍作者背景很不错，作者来自新浪，目前就职于创新工场。众所周知新浪微博的成功和他们的运营分不开，从一定程度上来说也可以认为是微博也是运营驱动的产品。</p>

<p>但拿到此书之后觉得有点亏，满打满算才190页，定价49，有点小贵，让我觉得有点哗众取宠想趁着风口多骗一些╭︿︿︿╮ {/ o  o /}   ( (oo) )     ︶︶︶。</p>

<p>其次是内容也不太实用。确实，运营这个事，如果看案例非常有意思，但是如果拿出一个让人信服，外行看了点头赞叹“原来如此”的系统化、理论化的原则原理或者方案，还是比较难的。每个公司都有不同的组织形式，工作流程和分工协作，别人的方式当然不能拿来直接用。</p>

<p>当然本书也不是一无是处，比如作者提到“目标用户是贯穿整个工作流程的主线”、“与其研究流式的的用户，不如研究活跃的用户”，通过本书，我才知道原来运营可以细分为内容运营、活动运营和用户运营（题外话：也有人建议将技术系的运维改为“技术运营”，仔细想想也有一定道理）。</p>

<p>通过本书，我的一个感想就是想清楚你的用户是谁，他们要干什么，然后围绕这两点，进行全方位的运营。</p>

<h2>这届初夏不行</h2>

<p>今年春末夏初，出了几件大事，不同类型、地区，基本都涉及到了人的安全问题，而且出现时机衔接如此紧密，这也是导致我分心的原因，所以整个4、5月都是在浑浑噩噩中度过。</p>

<p>想想4月的阅读情况，再想想现在已经是5月底，不知道如何清除初夏带来的心魔。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用 git diff 来对比Office文档？]]></title>
    <link href="http://liubin.github.io/blog/2016/04/26/how-to-use-git-to-diff-office-documents/"/>
    <updated>2016-04-26T12:51:35+08:00</updated>
    <id>http://liubin.github.io/blog/2016/04/26/how-to-use-git-to-diff-office-documents</id>
    <content type="html"><![CDATA[<p>我们知道用 <code>git diff</code> 命令比较文本文件还是比较容易的，Office文档的修改能比较么？</p>

<p>答案是可以的。下面我们就来看一下如何对Office文档进行比较。例子为在OS X上使用tika来将Office文本化之后再进行比较。</p>

<ul>
<li>安装tika</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install tika</span></code></pre></td></tr></table></div></figure>


<p>​
这可能需要一些时间，如果你的网速不快的话。</p>

<ul>
<li>创建脚本</li>
</ul>


<p>然后编辑一条用于比较Office文档的命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 文件名 ~/bin/diffoffice
</span><span class='line'>
</span><span class='line'>#!/bin/sh
</span><span class='line'>tika -t "$1"</span></code></pre></td></tr></table></div></figure>


<p>并将文件设置为可执行权限</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chmod +x ~/bin/diffoffice</span></code></pre></td></tr></table></div></figure>


<ul>
<li>编辑 git 配置文件</li>
</ul>


<p>编辑 <code>~/.gitconfig</code> 文件</p>

<p>添加如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[diff "office"]
</span><span class='line'>  binary = true
</span><span class='line'>  textconv = ~/bin/diffoffice</span></code></pre></td></tr></table></div></figure>


<ul>
<li>编辑代码仓库的属性文件</li>
</ul>


<p>在代码仓库的根目录下，创建 <code>.gitattributes</code> 文件，其内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*.pptx diff=office
</span><span class='line'>*.docx diff=office
</span><span class='line'>*.xlsx diff=office</span></code></pre></td></tr></table></div></figure>


<p>上面操作完成之后，就可以对Office的“二进制文件”进行对比了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff keynote.pptx
</span><span class='line'>
</span><span class='line'>... ...
</span><span class='line'>
</span><span class='line'>index 68a6a9a..bf108f9 100644
</span><span class='line'>--- a/20160423-docker-monitoring/keynote.pptx
</span><span class='line'>+++ b/20160423-docker-monitoring/keynote.pptx
</span><span class='line'>@@ -175,7 +175,7 @@ SaaS
</span><span class='line'> 采集
</span><span class='line'> 存储
</span><span class='line'> 展示
</span><span class='line'>-报警（动作）
</span><span class='line'>+报警（事件处理）
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何选择Docker监控方案]]></title>
    <link href="http://liubin.github.io/blog/2016/04/24/how-to-choose-a-docker-monitor-solution/"/>
    <updated>2016-04-24T11:48:38+08:00</updated>
    <id>http://liubin.github.io/blog/2016/04/24/how-to-choose-a-docker-monitor-solution</id>
    <content type="html"><![CDATA[<p><em>这是2016/4/23关于Docker性能监控的一次Meetup的内容节选，完整内容请参见文末<a href="https://github.com/liubin/presentations/tree/master/20160423-docker-monitoring">链接</a></em></p>

<p>大家好，非常高兴来上海跟大家分享一下我们在Docker监控方面的一点点经验。</p>

<p>今天我要跟大家享主题是《如何选择Docker监控方案》。</p>

<p>这里我将主要对Docker监控的原理和常用工具以及主流的解决方案进行简单介绍，如果大家正准备对Docker进行监控，希望这次分享能为大家带来一些帮助，如果你们已经进行了对Docker的监控，我也希望能的大家交流一下经验，跟大家互相学习一下。</p>

<p>同时，最后我也会安利一下SaaS这种商业模式，甚至是一种消费观念。可以说，我这次代表的不是某具体厂商，而是代表我们同样做类似服务的SaaS行业。</p>

<h2>什么是监控</h2>

<p>为什么监控，监控什么内容？</p>

<p>我们要对自己系统的运行状态了如指掌，有问题及时发现，而不让让用户先发现我们系统不能使用，打电话过来到客服，客服再反映到开发，这个过程很长，而且对工程师来说，是一件比较没面子的事情。</p>

<p>我们也不能一问三不知，比如领导问我们这个月的MySQL并发到了什么情况？slowsql处于什么水平，平均响应时间超过200ms的占比有百分之多少？</p>

<p>回答不出来这个问题很尴尬，尽管你工作很辛苦，但是却没有拿得出来的成果。不要以为没出问题就没事了，你要换位想想，站在领导的角度，领导什么都不干，你提案，他签字，出了问题领导责任也很大啊。</p>

<h2>监控目的</h2>

<ul>
<li>减少宕机时间</li>
<li>扩展和性能管理</li>
<li>资源计划</li>
<li>识别异常事件</li>
<li>故障排除、分析</li>
</ul>


<p>我们为什么需要监控我们的服务？其中有一些显而易见的原因，比如需要监控工具来提醒我服务出现了故障，比如通过监控服务的负载来决定扩容或缩容。如果机器普遍负载不高，则可以考虑是否缩减一下机器规模，如果数据库连接经常维持在一个高位水平，则可以考虑一下是否可以进行拆库处理，优化一下架构。</p>

<p>此外，监控还可以帮助进行内部统制，尤其是对安全比较敏感的行业，比如证券银行等。比如服务器受到攻击时，我们需要分析事件，找到根本原因，识别类似攻击，发现没有发现的被攻击的系统，甚至完成取证等工作。</p>

<h2>Docker监控的挑战</h2>

<ul>
<li>Docker特点

<ul>
<li>像host但不是host</li>
<li>量大</li>
<li>生命周期短</li>
</ul>
</li>
<li>监控盲点（断层）</li>
<li>微服务</li>
<li>集群</li>
<li>全方位

<ul>
<li>Host（VM） + Services + Containers + Apps</li>
</ul>
</li>
</ul>


<p>容器为我们的开发和运维带来了更多的方向和可能性，我们也需要一种现代的监控方案来应对这种变化。</p>

<p>随着不可变基础设施概念的普及，云原生应用的兴起，云计算组件已经越来越像搭建玩具的积木块。很多基础设施生命周期变短，不光容器，云主机、VM也是。</p>

<p>在云计算出现之前，一台机器可能使用3、5年甚至更长都不会重装，主机名也不会变，而现在，我们可能升级一个版本，就重建一个云主机或者重新启动一个容器。监控对象动态变化，而且非常频繁。即使全部实现自动化，也会在负载和复杂度方面带来不利影响。</p>

<p>集群的出现，应用的拓扑结构也变得复杂，不同的应用的指标和日志格式也不统一，再加上如何应对多租户，也给监控带来了新挑战。</p>

<p>传统的监控内包括主机、网络和应用，但是Docker出现了，容器这一层容易被忽略，成为三不管地区，监控的盲点。</p>

<p>有人说，容器不就是个普通的OS么？装个Zabbix的探针不就行了么？</p>

<p>Docker host和Docker 容器都要装Zabbix探针。。。其实问题很多。</p>

<p>除了容器内部看到的cpu内存情况不准之外，而且容器生命周期短，重启之后host名，ip地址都会变，所以最好在Docker host上安装Zabbix agent。</p>

<p>如果每个容器都像OS那样监控，则metric数量将会非常巨大，而且这些数据很可能几分钟之后就无效率了（容器已经停止）。容器生命周期短暂，一旦容器结束运行，之前收集的数据将不再有任何意义。</p>

<p>主要的解决方式就是对以App或者Service为单位进行监控（通过Tag等方式）。</p>

<h2>Docker监控技术基础</h2>

<ul>
<li><code>docker stats</code></li>
<li>Remote API</li>
<li>伪文件系统</li>
</ul>


<p>我们可以通过 <code>docker stats</code> 命令或者Remote API以及Linux的伪文件系统来获取容器的性能指标。</p>

<p>使用API的话需要注意一下，那就是不要给Docker daemon带来性能负担。如果你一台主机有200个容器，如果非常频繁的采集系统性能可能会大量占据CPU时间。</p>

<p>最好的方式应该就是使用伪文件系统。如果你只是想通过shell来采集性能数据，则 <code>docker stats</code> 可能是最简单的方式了。</p>

<h2>docker stats命令</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker stats redis1 redis2
</span><span class='line'>CONTAINER           CPU %               MEM USAGE/LIMIT     MEM %               NET I/O
</span><span class='line'>redis1              0.07%               <span class="m">796</span> KB/64 MB        1.21%               <span class="m">788</span> B/648 B
</span><span class='line'>redis2              0.07%               2.746 MB/64 MB      4.29%               1.266 KB/648 B
</span></code></pre></td></tr></table></div></figure>


<p>该命令默认以流式方式输出，如果想打印出最新的数据并立即退出，可以使用 <code>no-stream=true</code> 参数。</p>

<h2>伪文件系统</h2>

<ul>
<li>CPU、内存、磁盘</li>
<li>网络</li>
</ul>


<p>文件位置大概在（跟系统有关，这是Systemd的例子）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>/sys/fs/cgroup/<span class="o">{</span>memory,cpuacct,blkio<span class="o">}</span>/system.slice/<span class="k">${</span><span class="nv">docker</span><span class="p"> ps --no-trunc</span><span class="k">}</span>.scope
</span></code></pre></td></tr></table></div></figure>


<p>Docker各个版本对这三种方式的支持程度不同，取得metric的方式和详细程度也不同，其中网络metric是在1.6.1之后才能从伪文件系统得到。</p>

<h2>Memory</h2>

<p>内存的很多性能指标都来自于 <code>memory.stat</code> 文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>... ...
</span><span class='line'>cache 11492564992
</span><span class='line'>rss 1930993664
</span><span class='line'>swap 0
</span><span class='line'>pgfault 728281223
</span><span class='line'>... ...
</span><span class='line'>total_cache 11492564992
</span><span class='line'>total_rss 1930993664
</span><span class='line'>total_pgpgin 406632648
</span><span class='line'>total_pgpgout 403355412
</span><span class='line'>total_swap 0
</span><span class='line'>total_pgfault 728281223
</span><span class='line'>... ...
</span></code></pre></td></tr></table></div></figure>


<p>前面的不带total的指标，表示的是该cgroup中的process所使用的、不包括子cgroup在内的内存量，而total开头的指标则包含了这些进程使用的包括子cgroup数据。这里我们看到的数据都是一样的，由于这里并没有子cgroup。</p>

<p>两个比较重要的指标：</p>

<ul>
<li>RSS： resident set size</li>
</ul>


<p>进程的所有数据堆、栈和memory map等。rss可以进一步分类为active和inactive（active_anon and inactive_anon）。在内存不够需要swap一部分到磁盘的时候，会选择inactive 的rss进行swap 。</p>

<ul>
<li>cache memory</li>
</ul>


<p>缓存到内存中的硬盘文件的大小。比如你读写文件的时候，或者使用mapped file的时候，这个内存都会增加。这类内存也可以再细分为active和inactive的cache，即active_file和inactive_file。如果系统需要更多内存，则inactive的cache会被优先重用。</p>

<h2>CPU</h2>

<ul>
<li><code>cpuacct.stat</code>文件</li>
<li>docker.cpu.system</li>
<li>docker.cpu.user</li>
</ul>


<p>但是比较遗憾，Docker 不会报告nice，idle和iowait等事件。</p>

<p>System也叫kernel时间，主要是系统调用所耗费的部分，而user则指自己程序的耗费CPU，如果User时间高，则需要好好检查下自己的程序是否有问题，可能需要进行优化。</p>

<h2>Blkio</h2>

<p>优先从CFQ（Completely Fair Queuing 完全公平的排队）拿数据，拿不到从这两个文件拿：</p>

<p><code>blkio.throttle.io_service_bytes</code>，读写字节数
<code>blkio.throttle.io_serviced</code>，读写次数</p>

<p>Throttle这个单纯可能有误导，实际这些都不是限制值，而是实际值。</p>

<p>每个文件的第一个字段是 <code>major:minor</code> 这样格式的device ID。</p>

<h2>网络数据</h2>

<ul>
<li>iptables</li>
<li>伪文件系统</li>
<li><p>网络设备接口</p></li>
<li><p>Virtual Ethernet</p></li>
</ul>


<p>针网络的监控要精确到接口级别，即网卡级别。每个容器在host上都有一个对应的virtual Ethernet，我们可以从这个设备获得tx和rx信息。</p>

<p>不过找到容器在主机上对应的虚拟网卡比较麻烦。这时候可以在宿主机上通过 <code>ip netns</code> 命令从容器内部取得网络数据。</p>

<p>为了在容器所在网络命名空间中执行 <code>ip netns</code> 命令，我们首先需要找到这个容器进程的PID。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ CONTAINER_PID</span><span class="o">=</span><span class="sb">`</span>docker inspect -f <span class="s1">&#39;&#39;</span> <span class="nv">$CONTAINER_ID</span><span class="sb">`</span>
</span><span class='line'><span class="nv">$ </span>mkdir -p /var/run/netns
</span><span class='line'><span class="nv">$ </span>ln -sf /proc/<span class="nv">$CONTAINER_PID</span>/ns/net /var/run/netns/<span class="nv">$CONTAINER_ID</span>
</span><span class='line'><span class="nv">$ </span>ip netns <span class="nb">exec</span> <span class="nv">$CONTAINER_ID</span> netstat -i
</span></code></pre></td></tr></table></div></figure>


<p>或者：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ CONTAINER_PID</span><span class="o">=</span><span class="sb">`</span>docker inspect -f <span class="s1">&#39;&#39;</span> nginx <span class="sb">`</span>
</span><span class='line'><span class="nv">$ </span>cat /proc/<span class="nv">$CONTAINER_PID</span>/net/dev
</span></code></pre></td></tr></table></div></figure>


<p>实际上Docker的实现也是从伪文件系统中读取网络metric的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">pwd</span>
</span><span class='line'>/sys/class/net/veth559b656/statistics
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>collisions     rx_crc_errors   rx_frame_errors   rx_packets         tx_compressed   tx_heartbeat_errors
</span><span class='line'>multicast      rx_dropped      rx_length_errors  tx_aborted_errors  tx_dropped      tx_packets
</span><span class='line'>rx_bytes       rx_errors       rx_missed_errors  tx_bytes           tx_errors       tx_window_errors
</span><span class='line'>rx_compressed  rx_fifo_errors  rx_over_errors    tx_carrier_errors  tx_fifo_errors
</span></code></pre></td></tr></table></div></figure>


<h2>Docker监控方案实现</h2>

<ul>
<li>自己动手 + 开源软件</li>
<li>SaaS</li>
</ul>


<h2>评价标准</h2>

<ul>
<li>功能

<ul>
<li>满足</li>
<li>信息详细程度</li>
<li>查询的灵活程度</li>
<li>报警 + API</li>
</ul>
</li>
<li>灵活性

<ul>
<li>定制</li>
</ul>
</li>
<li>成本

<ul>
<li>学习、开发</li>
<li>维护</li>
</ul>
</li>
<li>运维

<ul>
<li>部署复杂程度</li>
</ul>
</li>
<li>高可用</li>
</ul>


<p>需要考虑的基本要素如上所示，不多述。</p>

<h2>自己动手</h2>

<ul>
<li>灵活性强</li>
<li>成本高</li>
</ul>


<p>这里的成本包括开发成本，开发成本可能包括招人和培训，开发时间和填坑时间。开发完了还需要维护成本，而且随着Docker的升级，可能还需要对metric的采集实现进行升级，以及各种bugfix。</p>

<h2>自己动手打造监控方案</h2>

<ul>
<li>采集</li>
<li>存储</li>
<li>展示</li>
<li>报警（动作）</li>
</ul>


<p>StatsD 是 Flickr 公司首先提出来的，后来由 Esty 公司发扬光大的一个轻量级的指标采集模块。</p>

<p>简单来讲，StatsD 就是一个简单的网络守护进程，基于 Node.js 平台（Esty实现，其实也有其他语言版本），通过 UDP 或者 TCP 方式侦听各种统计信息，包括计数器和定时器，可以用来采集操作系统、不同数据库、中间件的数据指标，进行缓存、聚合，并发送到Graphite 等存储和可视化系统中。</p>

<p>StatsD 具有以下优点：</p>

<ul>
<li>简单</li>
</ul>


<p>首先安装部署简单，且StatsD 协议是基于文本的，可以直接写入和读取，方便实现各种客户端和SDK。</p>

<p>Cloud Insight的探针也是采用这些方式，我们有些SDK也是基于StatsD的，目前有Ruby、Python和Java的，在<a href="https://github.com/cloudinsight">GitHub</a>上可以看到。</p>

<ul>
<li>低耦合性</li>
</ul>


<p>StatsD 守护进程采取 UDP 这种无状态的协议，收集指标和应用程序本身之间没有依赖，不会阻塞应用，不管StatsD的状态是运行中，还是没在运行，都不会影响应用程序，应用程序也不关心StatsD是否收到数据。</p>

<ul>
<li>易集成</li>
</ul>


<p>StatsD非常容易整合其他组件，可以自己编写采集业务逻辑，发送到StatsD守护进程即可。也就是说用户的工作很简单，只需要按定义好的规则采集数据发送到Stats，然后用Graphite存储、展示，通过使用Riemann进行报警。</p>

<h2>Tcollector</h2>

<ul>
<li>来源于OpenTSDB</li>
</ul>


<p>Tcollector 是一个采集指标数据并保存到OpenTSDB的框架，你可以使用该框架自己编写采集的业务逻辑。类似StatsD，运行在客户端，收集本地的metric信息，推送到OpenTSDB。</p>

<h2>Collectd</h2>

<ul>
<li>System statistics collection daemon</li>
<li>存储到RRD</li>
<li>插件机制（input/output）</li>
<li>简单报警功能</li>
</ul>


<p>Collectd即是一个守护进程，也是一个框架，类似StatsD，它性能非常好，采用C语言编写。Collectd不直接支持从Docker中取数据，但是我们可以自己编写插件来采集性能指标数据。</p>

<p>Collectd有强大的插件机制，已经实现了包括amqp、rrdtool、graphite、http、kafka、redis、mongodb、OpenTSDB以及CSV文件等在内的各种插件。</p>

<p>在4.3版本之后还支持简单的基于阈值检查的报警机制。</p>

<h2>cAdvisor（Container Advisor）</h2>

<p><img src="http://liubin.github.io/images/2016/04/docker-monitor/cadvisor.png" alt="" /></p>

<p>cAdvisor是一个用于收集、聚合处理和输出容器运行指标的守护进程。而且cAdvisor基本算是一个获取Docker性能数据的标配了吧。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo docker run <span class="se">\</span>
</span><span class='line'>  --volume<span class="o">=</span>/:/rootfs:ro <span class="se">\</span>
</span><span class='line'>  --volume<span class="o">=</span>/var/run:/var/run:rw <span class="se">\</span>
</span><span class='line'>  --volume<span class="o">=</span>/sys:/sys:ro <span class="se">\</span>
</span><span class='line'>  --volume<span class="o">=</span>/var/lib/docker/:/var/lib/docker:ro <span class="se">\</span>
</span><span class='line'>  --publish<span class="o">=</span>8080:8080 <span class="se">\</span>
</span><span class='line'>  --detach<span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
</span><span class='line'>  --name<span class="o">=</span>cadvisor <span class="se">\</span>
</span><span class='line'>  google/cadvisor
</span></code></pre></td></tr></table></div></figure>


<p>一句命令就可以启动cAdvisor容器，访问8080端口即可看到性能指标数据。cAdvisor可以通过storage_driver参数将数据存到influxdb，同时也可以将metric输出为Prometheus的格式，所以很多自定义Docker监控系统都会采取cAdvisor + Prometheus 的组合。</p>

<h2>存储TSDB</h2>

<ul>
<li>OpenTSDB</li>
<li>Influxdb</li>
<li>RRDTool</li>
<li>Graphite</li>
</ul>


<p>关于时序列数据库，可以看附录中相关的介绍文章。推荐使用OpenTSDB或者Influxdb，简单对比一下各自特点如下：</p>

<ul>
<li>OpenTSDB

<ul>
<li>Java &amp; HBase</li>
<li>易扩展（集群功能强大）</li>
<li>机器多，运维稍显麻烦</li>
</ul>
</li>
<li>Influxdb

<ul>
<li>Golang</li>
<li>集群功能不太成熟</li>
<li>有类SQL的查询语句</li>
<li>单台即可工作</li>
</ul>
</li>
</ul>


<p>这两者都支持自由模式和多维度，非常适合用于采用tag机制的数据模式建模。</p>

<h2>开源可视化工具</h2>

<ul>
<li>Graphite</li>
<li>Influxdb + Grafana</li>
<li>Prometheus</li>
</ul>


<p>光有数据是不够的，raw data没有任何意义，我们需要良好的可视化组件来展示数据和数据的内在意义，发挥数据的作用。</p>

<p>我们也可以将数据存储和展示交给其他开源软件。</p>

<p>如果你的数据采集和存储都是自己来完成的，只想使用一个外部的图形化界面的话，选Grafana应该没错，Grafana展现形式非常丰富，配置也很灵活。</p>

<p><img src="http://liubin.github.io/images/2016/04/docker-monitor/grafana.png" alt="" /></p>

<h2>开源方案</h2>

<ul>
<li>cAdvisor（经典）+ InfluxDB + Grafana</li>
<li>Zabbix/Nagios/Hawkular</li>
<li>Fluentd</li>
<li>Prometheus</li>
<li>Riemann</li>
<li>ATSD（Axibase Time Series Database）</li>
</ul>


<p>Hawkular 是一个来自于RedHat开源的监控解决方案，也包括报警等系统，可以说功能非常强大。</p>

<p>Hawkular基于Cassandra存储，它认为这虽然增加了运维的复杂程度，但是扩展变得容易（参考前面关于OpenTSDB和Influxdb的对比）。</p>

<h2>Zabbix</h2>

<ul>
<li>最经典（SaaS软件的最大敌人）</li>
<li>架构简单、清晰</li>
<li>文档丰富</li>
<li>包括采集、触发、告警</li>
<li>Agent支持用户自定义监控项</li>
<li>通过SNMP、ssh、telnet、IPMI、JMX监控</li>
<li>一套HTTP + JSON的接口</li>
</ul>


<p>现在Zabbix已经实现了探针的自动注册，也支持了基于角色的监控对象自动发现，但是你还是需要管理这些自动配置的项目。而且监控的服务多了，Zabbix探针在监控对象上运行的脚本也会变多，需要更多的进程，可能会对正常业务产生影响。</p>

<p>在Zabbix中支持Docker，可以使用 Zabbix Docker Monitoring ，首先需要下载两个xml的模板文件，导入到管理界面，然后在docker host，也就是zabbix的agent的机器上，安装zabbix模块（.so），然后还得在Docker主机上启动cadvisor容器。</p>

<h2>Graphite</h2>

<p>主要功能：</p>

<ul>
<li>存储数值型时序列数据</li>
<li>根据请求对数据进行可视化（画图）</li>
</ul>


<p>Graphite是一个经典的时序列数据存储，容易扩展，提供了功能强大的画图Web API以及大量的函数和输出方式。Graphite有自己的可视化实现，也可以支持Grafana。</p>

<p>Graphite本身不带数据采集功能，你需要选择其他第三方插件，比如Collectd等。</p>

<p><img src="http://liubin.github.io/images/2016/04/docker-monitor/graphite.png" alt="" /></p>

<p>Graphite架构自下而上分为3个模块：</p>

<ul>
<li>whisper：创建、更新RRD文件</li>
<li>carbon：以守护进程的形式运行，接收数据写入请求

<ul>
<li>carbon-cache：数据存储</li>
<li>carbon-relay：分区和复制，位于carbon-cache之前，类似carbon-cache的负载均衡</li>
<li>carbon-aggregator：数据集计，用于减轻carbon-cache的负载</li>
</ul>
</li>
<li>graphite-web：用于读取、展示数据的Web应用</li>
</ul>


<p>Whisper使用了类似RRDtool的RRD文件格式，不像C/S结构的软件，whisper没有服务进程，只是作为library来使用，直接对文件进行create/update/fetch等操作。</p>

<h2>Prometheus</h2>

<ul>
<li>一体化、仪表盘和告警</li>
<li>多维度</li>
<li>灵活查询语言</li>
<li>非分布式、单机自治</li>
<li>基于HTTP的pull模式（push需要中间网关）</li>
<li>LevelDB</li>
</ul>


<p><img src="http://liubin.github.io/images/2016/04/docker-monitor/prometheus-arch.png" alt="" /></p>

<p>Prometheus是一个全套监控和预测方案，包括数据采集、存储、查询和可视化，以及报警功能。由社交音乐平台SoundCloud在2012年开发，最近也非常火。</p>

<p>在集群流行的时候，很少有软件专为单机、本地存储而设计。Prometheus就是这样一个软件，它采用了基于LevelDB的本地存储，并没有使用成熟的面向列的数据库。不过Prometheus 也在实验将数据存储到OpenTSDB。</p>

<p>Prometheus 采用了pull模式，即服务器通过探针端的exporter来主动拉取数据，而不是探针主导上报。</p>

<p>Prometheus部署和运维起来可能比较麻烦，需要很多组件单独安装，比如dashboard（PromDash），虽然这虽然显得更加开放和包容。不过使用Docker的话将会简单很多，通过一个Docker Compose配置文件就能建立全功能的Prometheus监控环境，网上有很多这样的例子。</p>

<h2>Heapster</h2>

<ul>
<li>经典组合：heapster + Influxdb + grafana</li>
<li>Sink：Kafka、stdout、gcm（Google Cloud Monitoring）、hawkular、monasca、riemann、opentsdb</li>
</ul>


<p>Heapster是k8s的一个子项目，用于获取集群的性能数据。现在Heapster原生支持k8s和CoreOS，也可以很容易扩展来支持其他集群管理软件。</p>

<p>Heapster除了支持，基本的metric之外，还支持事件类型的数据，比如容器生命周期事件。</p>

<h2>Riemann</h2>

<ul>
<li>事件处理</li>
<li>Clojure实现</li>
</ul>


<p>Riemann 是一个分布式监控（数据处理）系统，但它做的事情其实非常简单，就是接收事件->按定义规则处理->转发或存储到外部系统。</p>

<p>我们可以将Riemann 与时间序列数据库，或者基于 StastD 的方案集成使用，来弥补其他方案在报警、事件流处理这方面上的不足。</p>

<p>Riemann采用Clojure语言编写，这是一门Lisp方言，函数式编程语言，对于大多数习惯于过程式或者面向对象的现代人来说，理解起来有一定难度，有一定的学习曲线。</p>

<h2>开源软件的问题点</h2>

<ul>
<li>灵活性受限于upstream</li>
<li>维护成本高</li>
<li>定制难度大</li>
<li>技术栈</li>
</ul>


<p>要选择自己熟悉或者能投入精力去熟悉的技术栈产品，否则有问题没人调查，监控产品将沦为摆设。</p>

<h2>SaaS</h2>

<ul>
<li>turnkey解决方案</li>
<li>维护成本 ~ Zero</li>
<li>适合中小企业</li>
</ul>


<p>对于中小型企业尤其创业公司来说，自主开发或者直接利用现有的开源工具进行监控都有一些问题，主要是成本和风险的问题。对于中小企业，应该先把精力集中在发展核心业务，能外包的就先不自己做。而且很多中小公司大家都是全栈，没有专门的运维人员，都是临时抱佛脚，随时都会变成救火队员。</p>

<p>SaaS最大的优点是什么？那就是免运维，开箱即用，修改的代码少甚至不需要修改代码，或者只需要简单的安装一个agent就可以工作了。很多SaaS软件的开场白都是运行一条 <code>yum install</code> ，然后倒上一杯咖啡等几分钟，就能看到数据了。</p>

<p>你的初期投入非常少，上手非常快，而且成本比较低（如果你的公司已经有数百上千服务器了，则这部分成本可能会变高，就跟是自建机房还是用云主机的对比一样）。</p>

<h2>SaaS</h2>

<ul>
<li>传统APM

<ul>
<li>New Relic</li>
<li>AppDynamics</li>
<li>Dynatrace（Ruxit）</li>
</ul>
</li>
<li>基础设施监控

<ul>
<li>Datadog</li>
<li>SysDig</li>
<li>Cloud Insight</li>
<li>clusterup</li>
<li>Scout</li>
</ul>
</li>
</ul>


<p>RancherLab公司有人写了篇文章，本讲稿的最后有链接，大家可以参考下。这篇文章名为《Comparing Seven Monitoring Options for Docker》，即对比了七种不同的监控Docker的方案，包括使用 <code>docker stats</code> 命令, cAdvisor, Prometheus ，Sensu，以及saas服务 Scout, Sysdig Cloud and DataDog等方案，作为结论作者觉得Datadog是这其中最优秀的方案。</p>

<blockquote><p><em>RancherLab有一个产品叫RancheOS，是一个专门为了运行Docker准备的微型Linux版本，它的口号是“The perfect place to run Docker”。跟CoreOS类似，但是貌似功能不如CoreOS多，也没有CoreOS有名，也没有CoreOS中fleet、flannel和etcd这样的组件，尤其是etcd，可以说是CoreOS的副产品，但是几乎成了Docker业界标准的kv store和服务发现组件了。</em></p></blockquote>

<h2>Datadog</h2>

<ul>
<li>国外最好</li>
<li>功能很强大</li>
<li>安装很简单</li>
</ul>


<p>国外最流行的SaaS解决方案是Datadog，国内可能比较成熟、规模较大的应该算是Cloud Insight了。</p>

<p>这类服务用户只需要注册一个账号，按照安装过程通过一条命令来安装探针即可在web展示端看到数据。</p>

<p>要说到Datadog的不足，那就是在国外，网络延迟需要考虑，万一哪天不科学了也需要有所准备。</p>

<p>价格方面Datadog也比较贵。免费plan支持5台机器，而且只保留一天的数据，而且没有报警功能。收费版15美元一台主机，支持报警功能，数据存储13个月。</p>

<p>说道SaaS，不得不提客服，直接面对非母语客服人员交流起来肯定会有诸多不顺吧。</p>

<h2>Cloud Insight</h2>

<ul>
<li>实时数据</li>
<li>历史数据</li>
<li>仪表盘</li>
<li>混合监控</li>
<li>报警功能</li>
</ul>


<p>当然，最便宜的还是Cloud Insight，有多便宜呢，官方定价的话3个探针以下是免费的，支持超过3台主机的话，平均每天1快钱。</p>

<p>这只是官方定价，实际上还会便宜，貌似联系客服就可以知道有多便宜了。</p>

<p>Cloud Insight还支持ChatOps集成，包括国内的 BearyChat 和简聊。随着devops文化的普及，相信这些工具的重要性也会与日俱增。</p>

<p>Cloud Insight的图表功能也很丰富，能对任何指标以图表的方式展示，还能在图表上叠加事件，比如报警通知、服务启动停止等，能在观察到metric变动趋势的同时，看到相应的时间，了解metric发生变动的原因。比如CPU load超过一定值时，可能触发报警，这时你能在图表上看到相应的事件，同样，如果CPU load一直不是很低，但是从某一时间点开始变低了，你可能也能从一次新的代码部署中了解原因。</p>

<h2>Sysdig</h2>

<ul>
<li>免费工具</li>
<li>SaaS服务 Sysdig Cloud</li>
<li>拓扑可视化</li>
</ul>


<p>可以认为sysdig是strace + tcpdump + htop + iftop + lsof + 众多linux常用的系统监控命令的合体。</p>

<p>如果你熟悉tcpdump，那么你知道它能还原整个网络流量，而sysdig则是操作系统级别的监控工具，能捕捉到所有OS事件和数据。</p>

<p>而且sysdig原生支持Linux container，包括Docker和LXC，提供了基本的指标监控信息。除了性能指标，sysdig还能采集trace等日志信息，用于以后的问题分析和解决。</p>

<p>Sysdig Cloud是sisdig的SaaS版，除了基本的单机sysdig功能之外，还提供了跨平台跨基础设施的组件间依赖关系的可视化。</p>

<h2>Librato</h2>

<ul>
<li>数据聚合平台</li>
<li>简单探针</li>
<li>图表和报警</li>
<li>价格不贵</li>
</ul>


<p>Librato是一个数据聚合平台，而不是严格意义的监控系统。</p>

<p>Librato很容易从AWS CloudWatch和Heroku获得数据，如果是自己监控主机或者Docker，需要使用Collectd框架。它也有很多插件，可以从StatsD、Riemann等数据源采集数据。</p>

<p>Librato的探针虽然功能不是强大，但是他提供了丰富的实时在线数据处理功能，用户可以使用DSL对任意时间序列数据组合进行数学运算，比如加减乘除、比率导数等。还支持和时间窗口滑动功能，即跟过去某一段时间进行比较。</p>

<p>Librato也支持报警，基于metric和条件，设置报警信息。</p>

<p>Librato是按照metric的个数和时间分辨率来收费的，在官网的主页上有一个大概的估算，如果你有20个metric，并且时间间隔为60秒，则一台服务器的价格只有2美元1个月，这比datadog要便宜。</p>

<h2>Axibase（ATSD）</h2>

<ul>
<li>非开源TSDB</li>
<li>支持报警</li>
<li>预测功能</li>
</ul>


<p><img src="http://liubin.github.io/images/2016/04/docker-monitor/atsd.png" alt="" /></p>

<p>作为TSDB，ATSD支持长时间存储高精度的metric数据。ATSD支持多种数据采集工具和协议，比如tcollector, Collectd，当然ATSD也支持从多台Docker主机手机指标数据，并长期保存，进行可视化和分析。</p>

<p>除了传统的时间序列数据，ATSD还支持属性（Properties）和消息这两种类型的数据。属性一般用于保存meta data，这有点类似标签。</p>

<p>和OpenTSDB一样，ATSD也支持tag，我们可以使用这些tag进行过滤和聚合。</p>

<p>ATSD内置了自动回归推断算法（holt-winters，arima），可以提早预测故障。预测功能的准确性取决于数据的采集频率，保存时间（也就是数据量大小）和算法。</p>

<p>最大的遗憾，就是ATSD不是开源，也不是免费的软件，不过他们提供了一个社区版可以免费使用，但是你只能在一个节点上安装ATSD，而且不能用于盈利性服务，也不能对软件进行修改以及再发布。</p>

<p>如果我们只是评估一下，或者想自己构建监控方案，它的产品设计还是非常值得我们来借鉴一下。</p>

<h2>SaaS的挑战</h2>

<ul>
<li>数据敏感性</li>
</ul>


<p>采用SaaS，意味着你的数据都将会保存到公网，可能会带来心理不安全感。实际上SaaS反而会更安全些，尤其是对中小公司没有专门的安全运维团队的情况下。</p>

<ul>
<li>成本（迁移和使用成本）</li>
</ul>


<p>一般来说这是一个一次性投入成本。</p>

<ul>
<li>内部抵抗（观念、个人爱好）</li>
</ul>


<p>来自技术人员自身的抵抗，不是每个人都喜欢自己变得轻松，使用SaaS可能会给一些人带来工作上的不充实感。</p>

<h2>趋势</h2>

<ul>
<li>标签机制</li>
</ul>


<p>一种观点：监控服务状态胜过监控个别容器，通过tag机制对服务整体的性能指标进行聚合。</p>

<p>Tag可以是任何维度，比如BU，地区，服务，甚至个别容器。</p>

<p>Docker和Kubernetes等都支持label机制，即tag机制。</p>

<ul>
<li>docker daemon &ndash;label com.example.group=&ldquo;webserver&rdquo;</li>
<li>docker run &ndash;label com.example.group=&ldquo;webserver&rdquo;</li>
<li><p>Dockerfile: LABEL com.example.group=&ldquo;webserver&rdquo;</p></li>
<li><p>通过API打通</p></li>
</ul>


<p>通过API化实现共赢。开源软件比如fluentd、Collectd等，都支持插件功能。包括Docker本身，也在1.11版本中，采用了runC作为容器运行时，在上面通过containerD来统一控制，来支持符合OCI标准的容器。</p>

<ul>
<li>Total解决方案</li>
</ul>


<p>包括从探针到展示、告警，就是现在类似Datadog和Cloud Insight这样的产品，以及支持中间件的详细程度，就像一个大市场，什么都能买到，不管你用什么软件，平台都能提供监控。</p>

<p>这就像是去了酒吧突然想吃碗拉面，然后竟然酒吧能给你做出来的那种感觉。</p>

<p>另一个层面就是从RUEM（实时用户体验管理）到基础设施层的 <strong>打通</strong> 。比如你看到某URL的用户HTTP响应较慢，如果不能跟后端的APM打通，你尽管能识别出问题，但是你不知道如何解决。如果和后端的APM以及基础设施监控打通，你就能定位到HTTP响应慢时，相应的后端代码的位置，并根据后端代码的位置从而进一步找到MySQL的监控数据以及系统异常事件，立刻知道问题的根本原因所在并解决问题，可以说效率应该能提高几个数量级。</p>

<p>系统监控工具如果能够做到 All in One，真的对解决人力和时间成本上有非常大的帮助。</p>

<ul>
<li>拓扑可视化</li>
</ul>


<p>跨组件、跨基础设施和应用，自动识别组件以及组件之间的依赖关系，以帮助更好的发现问题和解决问题。</p>

<ul>
<li>Weave Scope</li>
<li>Ruxit</li>
<li>Sysdig</li>
</ul>


<p>参考：</p>

<ul>
<li><a href="https://github.com/liubin/presentations/tree/master/20160423-docker-monitoring">本次分享全部资料</a></li>
<li><a href="http://rancher.com/comparing-monitoring-options-for-docker-deployments/">Comparing Seven Monitoring Options for Docker</a></li>
<li><a href="https://www.datadoghq.com/blog/how-to-collect-docker-metrics/">How to collect Docker metrics</a></li>
<li><a href="http://liubin.org/blog/2016/02/18/tsdb-intro/">时序列数据库武斗大会</a></li>
<li><a href="https://github.com/kiyoto/fluent-plugin-docker-metrics">Fluentd Docker Metrics Input Plugin</a></li>
<li><a href="https://docs.docker.com/v1.8/articles/runmetrics/">Docker Runtime metrics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年3月读书记录]]></title>
    <link href="http://liubin.github.io/blog/2016/04/05/03-reading/"/>
    <updated>2016-04-05T23:39:45+08:00</updated>
    <id>http://liubin.github.io/blog/2016/04/05/03-reading</id>
    <content type="html"><![CDATA[<p>本以为3月很忙，应该看不了几本，不过实际结果还是有点小惊喜的。这也说明，时间挤挤还是能挤出来一点的，不要再抱怨时间不够了。</p>

<p>三月读完6本书，主要是下面三种媒介：</p>

<ul>
<li><p>纸版书：</p>

<ul>
<li>《有鹿来：京都的日常》</li>
<li>《京都古书店风景》</li>
<li>《门外汉的京都》</li>
</ul>
</li>
<li><p>Kindle</p>

<ul>
<li>《互联网+战略版：传统企业，互联网在踢门》</li>
<li>《免费:商业的未来》</li>
</ul>
</li>
<li><p>微信读书App</p>

<ul>
<li>《超预期 小米的产品设计及营销方法》</li>
</ul>
</li>
</ul>


<p>相对于电子版，纸版书的优势还是很明显的：装帧、印刷工艺和质感，都是一本书不可或缺的因素。书不只是一个文字的有序组合。</p>

<p>电子版的书最大的问题在于排版太差，各设备阅读体验不统一。比如上面的《超预期 小米的产品设计及营销方法》，根本分不清标题的级别，每一章一个大标题，整章内字体都是同一个字号，段落间的间距也都不一样，这样读起来很难整体把握一本书的整体大概和脉络。</p>

<h2>《有鹿来：京都的日常》</h2>

<p><img src="https://img3.doubanio.com/lpic/s28362530.jpg" alt="有鹿来：京都的日常" /></p>

<p>推荐指数：★★★★★</p>

<p>忘了是搜什么和日本相关的书，这本也出现在了推荐列表里。第一次才知道了这个作者：苏枕书。不知道是不是笔名，但是一直以为ta是一个中年男性。后来查了一下，原来是一位女作家，而且非常年轻，出生于1986年，在中国读完法律本科，到京都大学继续攻读。</p>

<p>在本书中，作者以居住、旅行和学习为主线，介绍了京都的方方面面，有美食、生活习俗、古刹和名山。即使你没去过京都，也都能从其温柔秀美的文字中体会到京都的静、京都的美，以及京都的古香古色。</p>

<p>作者会带你散步哲学之路，感受到近代文豪的气息；你也可以跟随作者攀爬吉田山，在半山腰的朋友书店挑选几本中意的书；在游完真如堂后，再到金戒光明寺的法然院墓地，瞻仰一下谷崎润一郎的寂字碑；当然，作者也没忘记介绍著名的大文字山和五山送火。</p>

<p>作者对古代艺术也很熟悉和喜爱，因此本书也讲到了有邻馆、泉屋博物馆等博物馆和美术馆。如果你喜欢日本文化，也可以跟着作者了解一下日本的澡堂（钱汤），如何学习花道，岁末年初，日本仍在延续的祭祀和庆典活动。</p>

<p>相比作者在历史、地理和文学方面的深厚功底，其在建筑、佛教和植物方面的知识也让人赞叹。别说日本的花草了，就算是中国北方常见的花木，我也说不上三五种，而作者罗列起来，经常是五六个起，多则十几种，这么多花都能叫上名字，也需要花些时间来记忆了。</p>

<p>至于书名的“有鹿来”，大概由于这段记述吧：</p>

<blockquote><p>去年初夏，下学回来的夜里，漫天星辰，凉风可喜。遂往屋后山坡散步。四围静寂，人家灯火已暗。忽闻群犬争吠，又闻一阵急促的脚步声。完全猝不及防地，眼前转角处竟刹那现身一头大鹿，鹿角巍巍，前蹄腾起，健壮貌美。似乎有一瞬对视，我惊呆，鹿也惊呆，飞快回身，消失在黑暗山影中，复一片犬吠。待我回过神，追去两步，早已行迹杳然。</p></blockquote>

<p>书中有彩色插图，建议买纸版阅读。</p>

<h2>《京都古书店风景》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28265377.jpg" alt="京都古书店风景" /></p>

<p>推荐指数：★★★★☆</p>

<p>此书作者和上面的《有鹿来：京都的日常》同为苏枕书，作为法律专业学生、作家，作者自然对买书别有一番感悟。本书就是作者在京都求学期间，对京都比较有名的古书店的介绍。</p>

<p>100多年前，很多中国人赴日求学，很多人都到过京都，京都的古书店也有很多和中国有关的书籍和友情。作者除了经常去这些书店买书，还以书为纽带和很多书店的老板成为了朋友，时常往来、互相惦记，遇到经营不善或者后继无人而不得不闭店的时候，作者也不尽扼腕。</p>

<p>实体书店不好做，日本中国都类似。而日本的旧书还有回收行业，只要有价值，总会再次被发现；而国内很多好书估计在第一代主人用过之后，可能都被当做废品回收了，也不尽让人惋惜。</p>

<p>如果你有悠长的假期，想去京都体验一下浓厚的文化氛围和历史积淀，那么本书可能会对你有所参考，所以4星推荐。</p>

<p>和上一本一样，书中有彩色插图，建议买纸版阅读。</p>

<h2>《门外汉的京都》</h2>

<p><img src="https://img1.doubanio.com/lpic/s10773674.jpg" alt="门外汉的京都" /></p>

<p>推荐指数：★★★★★</p>

<p>如果说《有鹿来：京都的日常》是偏记事的抒情散文，则本书可以认为是偏诗歌性质的抒情散文。两书风格迥异，不过都堪称唯美。《有鹿来：京都的日常》文风清新爽朗，作者自造了很多词汇，而《门外汉的京都》则显得厚重老成，白话文夹杂了一些简单的文言文。</p>

<p>本书叙事风格也有点半游记的形式，毕竟作者最喜爱的城市估计就是京都了。作者游历过的城市颇多，而专门成书者，除了故乡台北，也就唯有京都了。</p>

<p>竹篱茅舍，流水长墙，读着作者笔下的京都，宛如自己也身在其境：</p>

<blockquote><p>“这也是为什么老来要住京都，太多的风流蕴藉之事，灯宵月夕，雪际花时，你皆可扮上一个动作，披上一片布幔，挥动一件道具，而数百年来中国早已失落的雅观风致，或在你的履践中，不自禁地消受了。”</p></blockquote>

<p>书中有插图，虽是黑白，仍建议买纸版阅读。</p>

<h2>《免费:商业的未来》</h2>

<p><img src="https://img1.doubanio.com/lpic/s3970994.jpg" alt="" /></p>

<p>推荐指数：★★★★★</p>

<p>对作者而言，该书始于《长尾理论》一书没有讨论完的话题。在《长尾理论》一书中，主要探讨了在商品种类应有尽有，我们的选择空间除了热门商品之外还有无限大的可能性时，出现的新型消费者需求。而互联网上无穷大的货架空间使得长尾式多样化的产品销售成为可能。而那些不收费的商家是如何赚得盆满钵满？这到底是怎么出现的，又会如何发展？本书主要围绕着免费经济和免费经济体制进行了论述。</p>

<p>受免费策略影响最大的产业莫过于媒体、软件、游戏、音乐和电影届了。本书则列举了相关行业的大量实例，说明了如何在受到互联网技术的威胁、影响下，如何适应潮流，改变销售和盈利的策略，如何应对盗版问题，如何开创新市场，发展新业务领域。其实我们国家已经有了很好地例子了，比如唱片行业，靠卖CD已经很难盈利，所以他们改变了传统的出专辑的方式，将单曲放到网上供人免费下载、播放，而歌手和乐队则由此提高知名度，公司则可以通过巡演、广告、参加各种商业活动来获得利润。</p>

<p>如作者所述，在20世纪免费是一种强有力的推销手段，而在21世纪它已经成为一种全新的经济模式。</p>

<p>在本书中作者还总结了免费的4种模式，如果你是创业者，在收费问题上有所疑虑的话，可以参考本书中的一些结论和实例。</p>

<p>免费的4种模式：</p>

<ul>
<li>1.直接交叉补贴</li>
</ul>


<p>典型代表为吉列剃须刀，刀架虽然免费，吉列却可以从刀片上赚到钱。</p>

<ul>
<li>2.三方市场</li>
</ul>


<p>经济学家称这种模式为“双边市场”，在这种市场系统中，第三方付费来参与前两方之间的商品交换。用户可以获得免费报纸，而广告商则向发行商付费。</p>

<ul>
<li>3.免费加收费</li>
</ul>


<p>免费加收费模式（Freemium）这个说法是由风险资本家弗雷德·威尔逊创造的，也是在网络生存空间中最常见的商业模式之一。比如网盘你可能得到5G的免费空间，如果你的文件太多，则需要付费购买高级的套餐来获得更多的存储空间。</p>

<ul>
<li>4.基于利他主义的免费服务</li>
</ul>


<p>包括礼品经济和劳动交换等，以维基百科等为代表。</p>

<p>“非货币经济：货币不起作用的地方，什么管用？”这一章比较有意思，主要讲了和货币经济相对应的注意力经济和声誉经济，以及礼物经济，去了解一下人们为什么热衷于投入到没有经济报酬的活动中去：社团、相互扶持、个人发展及自我实现。</p>

<h2>《互联网+战略版：传统企业，互联网在踢门》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28108417.jpg" alt="互联网+战略版：传统企业，互联网在踢门" /></p>

<p>推荐指数：★★★★★</p>

<p>说个可能不太合适的例子，老家农村有很多暴发户，其中多数受教育不高，其对子女的期望就是上大学。其实这些人不知道如何去教育、辅导子女，只是知道上大学才有文化、更有前途。</p>

<p>传统企业也有点类似，面对蓬勃发展的互联网，越来越多的线上线下、新兴和传统的结合，大家都感到有一种莫名的危机感和恐惧，惊呼狼来了。然而，这些传统企业却不知道如何防守才能守得住。不，确切的说，他们应该以攻为守。传统企业和互联网企业就像围城，里面的要出去，外面的要进来。</p>

<p>“印刷术、电信技术（电报和电话）、互联网，历史上，新型通信技术与新型能源系统的结合预示着重大经济转型时代的来临”。这个观点很好，值得创业者关注，我觉得还可以加上一条，就是人和人之间的沟通方式。</p>

<p>而互联网的出现，尤其是移动互联网的迅速普及，给传统商业带来巨大的冲击。管理学大师彼得·德鲁克说：互联网消除了距离，这是它最大的影响。而互联网商业的目的之一，就是要消灭一切基于信息不对称的商业模式。</p>

<p>传统企业要想在互联网大潮中得以幸存，首先就是要转型，先革自己的命，认清趋势，放弃原来基于信息不对称的既得利益，利用专业知识，结合新的互联网技术，寻找新的价值点和增长点。</p>

<p>书中，作者还给出了一个有意思的建议：</p>

<blockquote><p>我曾经总结过一个简单的互联网创业的行业方向：（1）找一个利润高到你恨的行业；（2）这个行业赚的是基于信息不对称的钱；（3）不涉及国家垄断的战略资源。</p></blockquote>

<p>我在想，为什么现在配个眼镜怎么还得去潘家园呢？</p>

<h2>《超预期 小米的产品设计及营销方法》</h2>

<p><img src="https://img1.doubanio.com/lpic/s28014459.jpg" alt="超预期 小米的产品设计及营销方法" /></p>

<p>推荐指数：★★★★★</p>

<p>本书从小米的创建开始，以其发展历程为主线，分析了小米的成功要素，其结论之一就是开发超预期的产品。</p>

<p>我虽然也觉得小米的饥饿营销不太让人舒服，但是雷军和小米的战略思想还是其成功地关键要素，那就是如书名所示，“超预期”，超过用户的预期，“口碑的真谛是超预期，之后超预期的产品才会产生口碑”。</p>

<p>雷军的五大军规：</p>

<blockquote><p>第一条：懂得顺势而为，绝不要做逆天而动的事情；第二条：颠覆创新，用真正的互联网精神重新思考；第三条：人欲即天理；第四条：广结善缘；第五条：专注，少就是多。</p></blockquote>

<p>黎万强总结的“参与感三三法则”：</p>

<blockquote><p>“三个战略：做爆品，做粉丝，做自媒体；三个战术：开放参与节点，设计互动方式，扩散口碑事件。”</p></blockquote>

<p>雷军说：“我觉得整个互联网公司把用户体验、用户口碑一步一步推到极致，这才是互联网给传统产业带来的最重要的思想。”在互联网时代，一切行业都是服务业，所有公司都是服务公司。书中举了海底捞的例子，由于海底捞提供了超出用户预期的服务，所以将普通消费者转化成了品牌粉丝。有人说在海底捞吃饭的客人想打包没吃完的西瓜，服务员会给你包好整个西瓜让你带回家，正是这些细节打动了用户的心。</p>

<p>“所以，我觉得要想做出成功的产品，除了产品本身要好之外，还需要做好服务，做好品牌。不过这些只是做出一个好产品、好公司的必要条件，而不是说满足这三点，公司就一定能成功。”</p>

<p>最后分享一个雷军提出的“四步请客法”：</p>

<blockquote><p>要把一个客人请到一定要花4次的时间：第一步，你要提前一周至两周跟客人打电话说明情况；第二步，要提前一周给客人寄请柬或发传真；第三步，要提前一天跟客人做确认；第四步，离请客时间还有半小时，要再给客人打电话确认。这样，一般客人都会到，如果他不到的话，那他就欠了你天大的人情，下次你打一次电话他就一定会来。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么你的简历投出之后渺无音讯？]]></title>
    <link href="http://liubin.github.io/blog/2016/03/29/engineers-resume/"/>
    <updated>2016-03-29T22:02:59+08:00</updated>
    <id>http://liubin.github.io/blog/2016/03/29/engineers-resume</id>
    <content type="html"><![CDATA[<p>很多人在向心仪的公司投了简历之后，渺无音讯，犹如石沉大海一般，不禁感叹有些公司只会看学历、看背景，以“貌”取人。</p>

<p>殊不知，如果你仔细反省一下，可能确实是个人达不到用人单位的要求，与目标职位不匹配；而另一种情况就是你自己的能力并未从简历中体现出来。简历筛选者也许收到了数以百计的简历，花在单一简历上的时间自然不多，如果你的简历中没有什么让人眼前一亮的东西，又怎么会得到面试机会？如果是因为简历写的不好而失去面试机会，有多可惜？</p>

<p>所以，这里大叔想简单介绍一下大叔认为的软件工程师简历中应该注意的一些事。</p>

<h2>简历风格</h2>

<p>首先，你需要知道写简历的目的，你需要在你的简历中透露出你想传递给阅读者的消息是：一、我的经验和能力适合这个职位，满足这个职位的要求，二、我非常希望得到此职位。这是简历的中心思想，所有的内容都要围绕这2点来展开。</p>

<p>我们先来看看一份简历的基本结构和要点。</p>

<h3>结构清晰</h3>

<p>简历一般由个人基本情况（姓名、联系方式等）、教育情况、工作经历、专业技能、个人PR等部分组成。</p>

<p>从排版上讲，段落要清晰、错落有致。可以通过不同的段落、字体大小、左右对齐、空行甚至图表等进行分割，让人一眼就能看出各部分的不同、各部分的主旨。通篇同样大小的字体，挤在一块容易让人抓不住重点，且容易疲劳。</p>

<p>在篇幅上，最好不要超过2-3页（根据工作经验多少可能会不一样）。一定要在写简历的时候换位思考：如果我是面试官，我会一字不差、认认真真读完这几页简历么？面试官会对我们的这个经验感兴趣么？要是问起我的这个项目中我干了什么、如何解决的这个问题，我该如何回答？</p>

<h3>语句通顺、言简意赅</h3>

<p>简历行文应该条理清楚、语句通顺。相信各位一定有过这样的经历，在看完某简历之后，暗暗感叹这人语文应该是体育老师教的吧？</p>

<p>其次，就是言简意赅、一字千金，各种口语、助词、甚至形容词，能省则省，千万别出现什么“委以重任”、“不负众望”甚至“力挽狂澜”的词汇，简历不是演讲，不需要煽情，这不是TV show，像什么“我劝天公重抖擞”类似的用语，千万不要出现在简历中。</p>

<p>简历有点类似英语考试的作文题，有时候适用减分法则，就是你写多了，反而会带来负面影响，降低简历筛选通过的几率。</p>

<p>另外老生常谈，就是尽量避免使用“精通”等词汇。</p>

<h3>无错别字、术语正确</h3>

<p>无错别字、标点符号运用得当也是简历的最基本要求。然而很多简历都存在这个问题。这应该是大家不重视语文或写作，以及计算机、智能机普及所带来的负面影响。这个也没什么好的办法，只能自己认认真真多检查几遍。</p>

<p>除了汉字，还有各种英文的专业术语大小写问题也需要额外注意，比如Java、MySQL这样的词汇，你能写对么？甚至更较真来说，WiFi和Wi-Fi哪个才是正确的写法？</p>

<h2>简历基本内容</h2>

<p>看完了简历整体要求，再来看看简历的主要内容。</p>

<h3>Cover letter（应聘动机）</h3>

<p>Cover letter可能算是舶来品，有最好。Cover letter主要可以表述为什么我非要投简历给你们、我是如何希望得到这份工作。比如我喜欢你们公司的开发方式、公司环境，或者你们的工作内容是我非常感兴趣、是我想深入研究的领域等等。</p>

<p>总之，要给简历审查者一种亲近、热爱该职位的感觉。Cover Letter贵在真诚。</p>

<h3>工作经历和项目经历</h3>

<p>这是简历中非常重要的两部分内容。</p>

<p>工作经历可以看出一个人曾经在什么地方工作过，每个公司呆了多少年，进而初步（大多数人都会这样）判断出这个人的水平和稳定性。一个人如果6个月跳槽一次，那么也大致可以判断出此人要么是水平太差，要么是工作态度有问题。</p>

<p>这一部分最好按时间倒叙来写，而且要有主有次，不要千篇一律，不分重点，以提高简历阅读者的效率，加深对应聘者的印象。</p>

<p>介绍项目经历的时候，要时刻提醒自己：我的经历和技能表现的是否和目标职位十分匹配？</p>

<p>如果你过去的工作经验和目标职位非常相像，那么可以重点来写一下这部分，扬长避短。否则的话可以重点写一下最近公司的状况。</p>

<p>项目经历应该包括的信息如下：参与时间、所处角色、主要工作内容和相关技术细节。相对枯燥的描述，一些数字和实例可能更容易让人理解。比如如果你是开发经理，你可以介绍一下团队成员有几人，如果你是运维，你可以介绍一下有多少台服务器，多少台数据库服务器，负载均衡用的什么、消息队列用的什么等。</p>

<h3>自我PR（自我评价）</h3>

<p>所谓PR，即公共关系，即自我包装、自我营销。</p>

<p>在国内，很少有人把PR和个人简历联系起来，有些国家自我PR算是简历的一个组成部分，甚至面试过程中面试官都准备一个环节专门让应聘者进行自我PR。</p>

<p>这一部分是1%和99%的区别，即大部分都流于形式、千篇一律，几乎每个人都会写上“有责任心”、“认真负责”、“良好的团队协作意识”等，在面试官看来，会条件反射式的惯性忽略。</p>

<p>而优秀的另外1%，则会立即抓住面试官的眼球，相比更多概括性的描述，举出实例更好。比如你说你认真负责，有哪些表现？你说你热爱技术，在哪些领域下足了苦工？</p>

<h2>简历中的补充信息</h2>

<p>此外，作为软件工程师来说，简历中添加一些额外的专业信息，都会成为加分项，增加面试的机会。</p>

<h3>技术博客</h3>

<p>技术博客除了能看出应试者的涉猎范围、对技术的痴迷程度以及技术水平之外，也能看出一个人持之以恒的个性、独自钻研的能力和写作能力。写文章不是工程师的天职，如今却也算得上是工程师的竞争优势。</p>

<h3>GitHub</h3>

<p>我们以在世界最大的同性交友网站为骄傲。不过以我的经验来看，如果一个人在GitHub上的粉丝很多，项目获得的star也很多，基本找工作都是不需要投简历的；相反，大多数人的GitHub数据都很一般，有一些人的提交还以更新blog为主。</p>

<p>甚至也不乏造假者，即将别人的仓库拿下来，删除提交信息，自己重新提交。总之，挖掘GitHub信息需要耐心。</p>

<h3>社区活动</h3>

<p>如果一个人经常参加各种技术社区活动，可以说明这个人：</p>

<ul>
<li>比较喜欢钻研技术</li>
<li>可能会擅长交流</li>
<li>分享精神</li>
</ul>


<p>因此可以从这方面对候选人进行技术和个人性格上进行考察。</p>

<p>也有很多人找工作根本不必事前准备简历，而是完全通过社区的关系来决定工作，简历只不过是作为公司手续上的备案资料而已。</p>

<h3>社交账号</h3>

<p>社交账号比如豆瓣、Twitter等。微博也可以，不过Twitter还能顺便考察一下科学上网的能力，能科学上网的软件工程师一般来说效率都会高很多。</p>

<h3>业余项目</h3>

<p>如果你有一些在工作之余开发的项目，也不妨列出来，即使用户不多、知名度不大。业余项目至少说明了你的动手能力和技术基础，对重视此因素的面试官来说非常容易加分。</p>

<h3>为企业定制</h3>

<p>如果可能，最好针对不同的应聘公司和职位，对简历进行一些定制，以着重强调自己和应聘职位在能力和经验（比如电商行业、对Redis特别熟等）上的匹配程度，也能增加面试的机会。</p>

<h2>关于发送简历</h2>

<p>最后，说完了简历中的核心内容，再说一下和内容无关的一些注意点。</p>

<h3>文件名</h3>

<p>千万别将简历命名为“个人简历.pdf”或者"新建Microsoft Word文档.docx"这样的名字。建议将文件名命名的更有意义，比如“张三-6年经验-Java开发”，这样在招聘方保存了多份简历的时候，也能快速的查找、定位简历。</p>

<p>此条建议也同样适用于邮件标题。</p>

<h3>文件格式</h3>

<p>因为你不知道简历阅读者使用的是什么操作系统，用的哪种办公软件，所以简历格式最好使用PDF格式保存，你知道PDF的P代表什么意思么？</p>

<p>随着越来越多的开发者开始使用OS X和Linux，如果你是从62job、神州英才这样的网站下载的简历，可能就不太走运了。因为很可能打开后格式错乱，有些人可能熟悉如何解决这类问题，而有些人则很可能因此而错过你的简历。</p>

<p>所以文件格式尽量用PDF的，或者使用在线简历。</p>

<h3>发送邮箱地址</h3>

<p>正式发送简历之前，最好先给自己发送一封，看看你的发件人是不是显示的真名，尤其是使用类似QQ邮箱这样的免费邮箱的时候，有可能你的邮箱发送者是你的昵称，这样也很容易被面试官忽略，甚至如果你使用的昵称比较另类，反而会引起人的反感，这样你的简历还没看，就先被减了一半的分数。</p>

<p>发送之前再确认两点：附件是否已经上传、标题是否已经填写。</p>

<h3>简历发给谁最重要？</h3>

<p>简历发给谁也很重要，有时候你会从多个渠道看到同一个职位的招聘信息，比如传统招聘网站、技术社区或者朋友圈，这时候，发给所应聘职位的直接领导，远比发给hr@xx.com和jobs@yy.com这样的邮箱好得多。</p>

<p>一般来说熟人推荐要比海投获得面试的机率高很多。</p>

<h2>结束语</h2>

<p>简历贵在简和精，你所看到的本文，原来有现在的两倍长，能删则删，删到不能删。</p>

<p>最后，祝你好运。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cookpad近期微服务经验总结]]></title>
    <link href="http://liubin.github.io/blog/2016/03/16/microservice-at-cookpad/"/>
    <updated>2016-03-16T23:54:31+08:00</updated>
    <id>http://liubin.github.io/blog/2016/03/16/microservice-at-cookpad</id>
    <content type="html"><![CDATA[<p>译者注：</p>

<h2>关于版权</h2>

<p>本文首发于Cookpad公司技术博客<a href="http://techlife.cookpad.com/entry/2016/03/16/100043">《クックパッドにおける最近のMicroservices事例》</a>，本译文已获得原作者基于<strong>禁止商业用途</strong>的许可，有转载需求请自行联系原作者，责任自负，因转载出现的任何问题皆与本站和本人无关。</p>

<h2>关于Cookpad介绍</h2>

<p>Cookpad是日本最大的在线菜谱分享公司，上市企业；这都不算啥，说到Rails，日本人没有不知道Cookpad的，可以说Cookpad将Rails用到了极致，相信他们在微服务方面的经验也能为我们带来帮助。</p>

<p><em>以下是正文</em></p>

<hr>


<p>大家好，我是Cookpad技术部的吉川。</p>

<p>最近微服务这个概念很流行，其技术也逐渐变得系统化、结构化。另一方面就是关于微服务概念上或者抽象的内容比较多，很难让人对微服务有一个具体的印象。</p>

<p>Cookpad公司的技术博客在1年半之前已经对 <a href="http://techlife.cookpad.com/entry/2014/09/08/093000">Cookpad和微服务</a> 进行了介绍。我们也将当时公司内部使用的工具Garage进行了 <a href="https://github.com/cookpad/garage">开源</a> ，现在Cookpad的系统已经比当时有了更大的发展。</p>

<p>所以，在前几天的 <a href="http://connpass.com/event/26178/">Microservices Casual Talks</a> 上，我们也对Cookpad最近关于微服务的使用经验进行了分享。</p>

<p>这是当时的 <a href="https://speakerdeck.com/adorechic/how-microservices-are-linked-at-cookpad">演示幻灯片（日文）</a>。<em>打不开的话自备工具</em></p>

<script async class="speakerdeck-embed" data-id="cd8a946838714932932c892aa3609241" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>


<p>本文并不打算对微服务一些抽象难懂的概念进行解说，而是更专注于具体实例。本文应该会对那些理解一些微服务的基本概念，而实际中又不知道如何应用的人有很大帮助，因此我们决定通过本博客再来进行一下介绍。</p>

<h2>服务粒度</h2>

<p>大家常说微服务就是职责单一的服务，但是单一职责又需要具体到什么地步才算单一呢？Cookpad的服务主要分为3种类型。</p>

<h3>用户服务</h3>

<p>根据产品关注点的分类。一个根本原则是微服务需要根据业务领域来划分。Cookpad提供了包括美味料理、料理教室、料理视频、Cookpad博客、大家的咖啡等在内的众多服务。</p>

<p><img src="http://liubin.github.io/images/2016/03/cookpad-micro-services/p1.png" alt="" /></p>

<p>尽管大多数服务都采用了Rails进行开发（也有一部分服务只有手机客户端），但是每个团队的特点都不一样。比如ES6的话既使用了React.js，也使用了CoffeeScript；有的团队使用了Rubocop，有的则没有使用。</p>

<p>由于产品的不同，目标用户也不太一样，因此我们可以很灵活地选择所使用的技术。如果能够很方便地使用其他Domain的model，则很容易产生协同效应。换句话说，即使最终用户看起来服务千变万化，但是从公司内部的其他服务来看，使用的是一个统一的Model。</p>

<h3>View服务</h3>

<p>Domain model相同但是展现形式不一样。</p>

<p><img src="http://liubin.github.io/images/2016/03/cookpad-micro-services/p2.png" alt="" /></p>

<p>从形式上很像 <a href="https://www.thoughtworks.com/radar/techniques/bff-backend-for-frontends">BFF(Backend for frontends)</a> 模式，但是由于Cookpad需要兼容各种各样的设备，因此同一个domain model需要以不同版本（<em>这里的版本不是指alpha、beta这样的版本号，而是类似个人版、商业版这样的概念 &ndash; 译者注</em>）的形式来提供。OEM版就是一个例子，提供的东西是一样的，但是却以不同版本的UI或者用户系统来提供服务。</p>

<h3>共通基础服务</h3>

<p>指的是为各种服务提供功能的服务。比如下面这些都是共通服务：</p>

<ul>
<li>OAuth provider</li>
<li>结算</li>
<li>Push通知、邮件服务</li>
<li>活动</li>
<li>各种日志</li>
<li>敏感（个人）信息存储</li>
<li>视频</li>
</ul>


<h2>服务之间的集成</h2>

<h3>RESTful Hypermedia API</h3>

<p>微服务之间如何通信一直以来都是一个值得讨论的话题。虽然我们认为一般都会通过HTTP使用REST API，但是应该也有人会选择Protocol Buffers或者Thrift这样基于RPC的方式。</p>

<p>Cookpad微服务之间的通信采用了 <a href="http://techlife.cookpad.com/entry/2014/09/08/093000">基于Garage的RESTful Hypermedia API</a> 方案。在之前的博客中我们已经介绍过Garage了，这里就略过了。在这篇博客中，我们会对一些Garage解决不了的问题进行介绍。</p>

<h3>并行处理和容错</h3>

<p>服务之间的集成越来越多，带来了两个问题。第一个问题是性能开销。一体化应用的话只需要连接到数据库把数据取回来就可以了，但是如果只是将这个功能采用REST API来实现的话，性能开销会变大。为了提高吞吐量，需要做很多努力，就微服务架构来说，调用方在发出请求之后，将会进入单纯的IO等待状态，非常适合采用并行处理的方式。因此对服务进行合适粒度的拆分，各服务的责任更独立，更容易采取并行处理的方式。</p>

<p>第二个问题是容错。如果某一服务阻塞了，等待该服务超时的客户端也会被阻塞，进而导致阻塞的连锁反应。好不容易将服务拆分了，当然不想轻易地出现这样的故障影响正常运行。</p>

<p>或者将请求并行来处理，或者进行重试，在超过一定数量的错误发生后停止对该服务的请求。我们采用 <a href="https://github.com/cookpad/expeditor">Expeditor</a> 实现了该需求。熟悉这些需求的人可能已经想到了，这就是 <a href="https://github.com/Netflix/Hystrix">Netflix/Hystrix</a> 的Ruby版。当然现在还没有Hystrix那么多功能，但是一些基本功能，比如有依赖关系的Asynchronous Execution和Fallback、Retry、Circuit Breaker都已经实现了。</p>

<h3>服务间的测试</h3>

<p>REST API集成的问题之一就是API的兼容性。</p>

<p>通常在CI能够发挥作用的测试级别的测试中，发给其他服务的请求都是stub的形式，不能确认是否有不兼容该服务接口的变动混入。使用Protocol Buffers这样方式的话，由于需要共享proto文件，可能不会出什么问题。而使用REST API的方式进行集成的话，也有一种使用JSON Schema的方法。不过由于是Ruby + HTTP风格的文化，相比使用类型系统进行管理的开发风格，我们的工程师们更习惯于进行动态测试这种风格。这也是 <a href="http://techlife.cookpad.com/entry/2015/10/09/125108">Rack::VCR</a> 产生的背景。但是使用各服务自己的CI来保证兼容性的话，如果服务之间的构建频率不一致，在Cookpad这样发布非常频繁的公司，很可能会出现在发布之后才能发现API不兼容的问题（<em>即发布之后API提供方的API才检测到调用方的调用有问题 &ndash; 译者注</em>）。因此我们决定转向 <a href="http://techlife.cookpad.com/entry/2016/01/04/094705">Consumer-Driven Contract testing</a> ，现在已经迁移到 <a href="https://github.com/realestate-com-au/pact">Pact</a> 了。</p>

<p><img src="http://liubin.github.io/images/2016/03/cookpad-micro-services/p3.png" alt="" /></p>

<p>这样，如果客户端破坏了API的兼容性，会被提供方（provider）的CI会检测到，从而防止不兼容的修改被发布。</p>

<h3>服务间日志的事务关联</h3>

<p>服务分开之后，日志追踪会变得很困难。特别是错误日志，当一个服务发生错误时，在调用方发现了错误的话，如果在被调用方不能追查到发生了什么错误的话，就很难找到问题的根本原因。一般的解决方式是为请求设置一个ID，以此来对各服务中的调用进行分析。特别是Rails默认就支持X-Request-Id HTTP头，没有ID的话也会自动设置一个。而且我们的各服务通过使用 <a href="https://github.com/cookpad/garage_client">GarageClient</a> 进行集成，GarageClient会在发起请求时设置X-Request-Id并将这个ID传递下去。</p>

<p>Cookpad错误日志管理采用了 <a href="https://github.com/getsentry/sentry">Sentry</a> ，错误日志通过将请求ID作为标签来进行管理。</p>

<h2>服务的运行环境、配置关联</h2>

<p>随着服务的增多，给基础设施也带来了很大的压力。Cookpad本来使用的配置管理工具是Puppet，随着模块的增多，操作也变得复杂，同样的应用程序，有时还得区分是作为在线应用服务使用还是作为批处理作业使用来分开管理，总之会出现各种复杂的场景。</p>

<p>现在除了一部分巨型Rails应用程序以外，包括测试环境和生产环境在内，Cookpad几乎所有的应用都跑在Docker中。</p>

<h3>构建pipeline</h3>

<p>各服务的修改合并代码之后，就会启动CI，测试通过后构建新的Docker镜像。这个新的Docker镜像会自动部署到staging环境中。同时生产环境使用的也是这个镜像，而且没有为批处理作业和在线服务准备不同的环境，只需要拉取最新的镜像运行即可。当然这个镜像也可以在开发者本地运行。在Scale out或者进行渗透测试需要创建独立的运行环境的时候，采用Docker可以快速部署。</p>

<h3>部署</h3>

<p>Cookpad的Docker运行环境是ECS，实际部署的时候会将容器和ELB结合起来一起配置、注入环境变量等操作。<a href="https://github.com/eagletmt/hako">Hako</a> 就是一个这样能将部署过程中各种步骤连接起来的一个工具。有了Hako，在第一次部署的时候可以自动创建ELB，使用Route53设置域名指向，而以前这些工作都需要基础设施工程师单独一个个的去设置。利用这种机制，在生产环境下，<strong>一个应用程序对应一个ELB</strong>，在测试环境下，一个ELB则可以对应多个应用程序，进行非常灵活的设置。</p>

<h3>配置管理</h3>

<p>即使是同一个镜像，DB连接信息、API key等也不同，都依赖于具体的环境。Hako支持环境变量注入功能，这在一定程度上可以进行环境变量管理工作，但是需要安全处理的信息则使用了 <a href="https://github.com/sorah/etcenv">etcenv</a> 和 <a href="https://github.com/sorah/etcvault">etcvault</a> 来进行管理。后端存储是etcd，不过由于etcd没有ACL管理功能，因此数据都采用了加密后存储的方式。<code>etcenv</code> 有一个UI工具 <a href="https://github.com/sorah/etcweb">etcweb</a> ，可以通过Web进行管理。</p>

<h2>公司级别的支持</h2>

<p>采用了微服务架构，团队也随着服务而独立。不同团队之间的协作方法，全体的决策方式等也逐渐发生着变化。</p>

<h3>技术领域课题共有会</h3>

<p>各团队的独立性越高，对其他不同团队的具体工作内容就越难以把握。各自业务固有的烦恼也会增加。由此会出现很多问题，比如有一些共通难题，如果团队内部认为只有自己才有这个烦恼的话，就不会将这个问题提到公共层面，而实际上隔壁的团队也许早已经解决了这个问题。因此Cookpad各团队的leader和基础设施、共通服务的工程师每个月都会聚到一起通过会议的方式来讨论一些共通话题。</p>

<p>在这个会议上各个团队会提出自己目前遇到的问题，如果一些问题已经有了解决方案，则将解决方案在公司范围内共享，如果没有解决方案，则会选择一个合适的团队专门负责来解决这个问题。此外对全局都可能带来影响的需求变更也会拿到会上讨论。这样就会发现很多问题，比如有些事自己认为不是问题，可是大家都在为此烦恼；或者自己认为大家都在使用的服务实际上并没有人用，自己却还努力在维护。</p>

<h3>共通基础技术工程师</h3>

<blockquote><p><em>译者注：即公司内部开发公共服务的工程师</em></p></blockquote>

<p>随着团队变得多样化，有的团队有擅长共通基础的成员，有的则没有；有的团队新产品较多，所以对公司内部最新的共通基础技术都很了解，而有的团队则对公司的共通基础技术认识不足，甚至还有重复制造轮子的现象。也有一些团队根本没有精力去对共通基础技术进行改善。</p>

<p>所以Cookpad将共通基础团队的成员分配给各个服务，作为各个团队的共通基础技术工程师。一个人对应多个服务，而不是专属于某一服务团队，所以他们可以称为是团队的外部共通基础技术工程师。共通基础技术工程师使用服务团队的协作（Chat）工具，谈论各种话题，有时候也全身心投入开发环境的准备工作中。</p>

<h2>总结</h2>

<p>本文我们对Cookpad近期在微服务方面的使用心得进行了介绍。Docker带来的可移植性给公司内部的开发风格带来了很大的改变，加速了微服务的落地。同时随着Pact等工具的出现以及公司层面的支持，Cookpad的开发风格在这一年有了显著的进步。</p>

<p>有了微服务各个团队也更能将精力集中在本职工作上。集中精力在产品上，也就是相当于集中精力在用户身上一样。根据产品的不同选择最合适的技术，团队成员对自己的产品负责，可以自己主导产品开发。</p>

<p>这里我们只是对Cookpad中微服务的概要进行了介绍，后面我想可能还会带来对Hako或者Pact等工具的介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[时序列数据库武斗大会之KairosDB篇]]></title>
    <link href="http://liubin.github.io/blog/2016/03/12/tsdb-kairosdb/"/>
    <updated>2016-03-12T23:24:46+08:00</updated>
    <id>http://liubin.github.io/blog/2016/03/12/tsdb-kairosdb</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>按照官方的说明，KairosDB是一个“Fast Time Series Database on Cassandra”，即基于Cassandra的告诉时序列数据库。</p>

<h2>特点</h2>

<h3>数据采集</h3>

<p>数据可以通过多种协议写入KairosDB，比如Telnet的按行写入，HTTP API，Graphite以及批处理导入。此外，还可以使用或者自己编写插件。</p>

<h3>存储</h3>

<p>KairosDB 采用了 Cassandra 作为数据存储方式，Cassandra 也是一个比较流行的NoSQL数据库，很多开源软件基于此数据库。</p>

<h3>Rest API</h3>

<p>KairosDB提供了REST API，已完成对metric名称，tag等的查询，当然，也少不了存储和查询数据点（data points）。</p>

<h3>自定义数据类型（Custom Data）</h3>

<p>KairosDB支持存储和聚合自定义数据类型。默认情况下KairosDB支持long、double和字符串的value，这比OpenTSDB要丰富一些。</p>

<h3>分组和聚合</h3>

<p>作为数据分析系统，分组和聚合则是必不可少的功能。
<a href="http://kairosdb.github.io/docs/build/html/restapi/Aggregators.html">KairosDB的聚合（也就是down samples）</a>功能，支持的标准函数有min、max、sum、count、mean、histogram、gaps等，而且都非常实用。</p>

<p>比如percentile，可以计算一个指标值大概的百分比位置，非常适合存储类似“你打败了xx%的人”这种需求场景。</p>

<h3>支持工具</h3>

<p>KairosDB提供了进行数据导入导出的命令行工具。根据官方文档的说明，在一台分配了2Gig内存的SSD Cassandra上，1秒钟能导入  13万条数据。</p>

<h3>插件机制</h3>

<p>KairosDB也提供多种基于Guice的插件机制来进行扩展（data point监听器，数据存储，协议处理等。）</p>

<p>KairosDB是从OpenTSDB fork过来的，因此最初它是支持HBase的，不过现在HBase已经不能完全支持KairosDB所需的特性，将来会取消对HBase的支持。</p>

<h1>入门KairosDB</h1>

<h2>安装KairosDB</h2>

<p>这里我们以当前最新的1.1.1版本为例进行说明。</p>

<p>首先，需要确保你的JAVA_HOME已经设置好了，且Java版本高于1.6。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo $JAVA_HOME
</span><span class='line'>/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home</span></code></pre></td></tr></table></div></figure>


<p>然后需要到<a href="https://github.com/kairosdb/kairosdb/releases">GitHub</a>上去下载安装包。我用的是OS X系统，因此我选择了<a href="https://github.com/kairosdb/kairosdb/releases/download/v1.1.1/kairosdb-1.1.1-1.tar.gz">kairosdb-1.1.1-1.tar.gz</a> （注意：点击这个链接即可下载）</p>

<p>解压后可以看看它的配置文件<code>conf/kairosdb.properties</code>，有一些东西适合OpenTSDB一样的，比如4242端口。</p>

<p>KairosDB集成了jetty，你可以通过jetty访问WEB UI，而且还支持添加SSL支持，这样安全性上比OpenTSDB高了一个层级。</p>

<p>配置文件中还能对Cassandra进行设置，比如服务器地址、keyspace等。不过默认的话KairosDB使用H2作为数据存储，这样在开发环境下我们就不必配置Cassandra了。这里我们也以H2为例来初步认识一下KairosDB，这也是KairosDB的默认配置。</p>

<p>所以在这个例子里，我们不必修改配置文件，直接启动KairosDB即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ bin/kairosdb.sh run
</span><span class='line'># 或者
</span><span class='line'>$ bin/kairosdb.sh start</span></code></pre></td></tr></table></div></figure>


<p>其中<code>run</code>参数会以前台运行的方式启动KairosDB，而<code>start</code>则以后台进程的方式启动KairosDB。</p>

<p>停止KairosDB只需要运行<code>bin/kairosdb.sh stop</code>就可以了。</p>

<h2>写入数据</h2>

<p>和OpenTSDB一样，KairosDB也支持基于telnet和HTTP API的方式写入数据。</p>

<h3>Telnet</h3>

<p>Telnet的方式数据格式很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>put &lt;metric_name&gt; &lt;time-stamp&gt; &lt;value&gt; &lt;tag&gt; &lt;tag&gt;... \n</span></code></pre></td></tr></table></div></figure>


<p>这里我们就不做演示了。</p>

<h3>HTTP API</h3>

<p>只需要发送JSON数据到<code>http://localhost:8080/api/v1/datapoints</code>就可以了。</p>

<p>这是我们写入测试数据的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ curl -v -H "Content-type: application/json" -X POST  http://localhost:8080/api/v1/datapoints -d '
</span><span class='line'>[{
</span><span class='line'>    "name": "cpu.load.1",
</span><span class='line'>    "timestamp": 1453109876000,
</span><span class='line'>    "type": "double",
</span><span class='line'>    "value": 0.32,
</span><span class='line'>    "tags":{"host":"test-1"}
</span><span class='line'>},
</span><span class='line'>{
</span><span class='line'>    "name": "cpu.load.1",
</span><span class='line'>    "timestamp": 1453109876000,
</span><span class='line'>    "type": "double",
</span><span class='line'>    "value": 0.21,
</span><span class='line'>    "tags":{"host":"test-2"}
</span><span class='line'>}]
</span><span class='line'>'
</span><span class='line'>* Connected to localhost (::1) port 8080 (#0)
</span><span class='line'>&gt; POST /api/v1/datapoints HTTP/1.1
</span><span class='line'>&gt; Host: localhost:8080
</span><span class='line'>&gt; User-Agent: curl/7.43.0
</span><span class='line'>&gt; Accept: */*
</span><span class='line'>&gt; Content-type: application/json
</span><span class='line'>&gt; Content-Length: 262
</span><span class='line'>&gt; 
</span><span class='line'>* upload completely sent off: 262 out of 262 bytes
</span><span class='line'>&lt; HTTP/1.1 204 No Content
</span><span class='line'>&lt; Access-Control-Allow-Origin: *
</span><span class='line'>&lt; Pragma: no-cache
</span><span class='line'>&lt; Cache-Control: no-cache
</span><span class='line'>&lt; Expires: 0
</span><span class='line'>&lt; Content-Type: application/json; charset=UTF-8
</span><span class='line'>&lt; Server: Jetty(8.1.16.v20140903)
</span><span class='line'>&lt; 
</span><span class='line'>* Connection #0 to host localhost left intact
</span></code></pre></td></tr></table></div></figure>


<p>从服务器返回结果我们可以看到，HTTP 204状态码，也是KairosDB成功写入数据的结果。</p>

<h2>查询数据</h2>

<p>同样KairosDB提供了查询用API：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ curl -H "Content-type: application/json" -X POST  http://localhost:8080/api/v1/datapoints/query -d '
</span><span class='line'>{
</span><span class='line'>  "metrics": [
</span><span class='line'>    {
</span><span class='line'>      "tags": {},
</span><span class='line'>      "name": "cpu.load.1",
</span><span class='line'>      "group_by": [
</span><span class='line'>        {
</span><span class='line'>          "name": JSON"tag",
</span><span class='line'>          "tags": [
</span><span class='line'>            "host"
</span><span class='line'>          ]
</span><span class='line'>        }
</span><span class='line'>      ],
</span><span class='line'>      "aggregators": [
</span><span class='line'>        {
</span><span class='line'>          "name": "sum",
</span><span class='line'>          "align_sampling": true,
</span><span class='line'>          "sampling": {
</span><span class='line'>            "value": "1",
</span><span class='line'>            "unit": "minutes"
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>      ]
</span><span class='line'>    }
</span><span class='line'>  ],
</span><span class='line'>  "cache_time": 0,
</span><span class='line'>  "start_absolute": 1453046400000,
</span><span class='line'>  "end_absolute": 1453132800000,
</span><span class='line'>  "time_zone": "Asia/Chongqing"
</span><span class='line'>}' | jq .</span></code></pre></td></tr></table></div></figure>


<p>注意上面命令最后的jq，这是用来对JSON数据进行格式化的工具。</p>

<p>最终结果可能像下面一样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "queries": [
</span><span class='line'>    {
</span><span class='line'>      "sample_size": 2,
</span><span class='line'>      "results": [
</span><span class='line'>        {
</span><span class='line'>          "name": "cpu.load.1",
</span><span class='line'>          "group_by": [
</span><span class='line'>            {
</span><span class='line'>              "name": "tag",
</span><span class='line'>              "tags": [
</span><span class='line'>                "host"
</span><span class='line'>              ],
</span><span class='line'>              "group": {
</span><span class='line'>                "host": "test-1"
</span><span class='line'>              }
</span><span class='line'>            },
</span><span class='line'>            {
</span><span class='line'>              "name": "type",
</span><span class='line'>              "type": "number"
</span><span class='line'>            }
</span><span class='line'>          ],
</span><span class='line'>          "tags": {
</span><span class='line'>            "host": [
</span><span class='line'>              "test-1"
</span><span class='line'>            ]
</span><span class='line'>          },
</span><span class='line'>          "values": [
</span><span class='line'>            [
</span><span class='line'>              1453109876000,
</span><span class='line'>              0.32
</span><span class='line'>            ]
</span><span class='line'>          ]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>          "name": "cpu.load.1",
</span><span class='line'>          "group_by": [
</span><span class='line'>            {
</span><span class='line'>              "name": "tag",
</span><span class='line'>              "tags": [
</span><span class='line'>                "host"
</span><span class='line'>              ],
</span><span class='line'>              "group": {
</span><span class='line'>                "host": "test-2"
</span><span class='line'>              }
</span><span class='line'>            },
</span><span class='line'>            {
</span><span class='line'>              "name": "type",
</span><span class='line'>              "type": "number"
</span><span class='line'>            }
</span><span class='line'>          ],
</span><span class='line'>          "tags": {
</span><span class='line'>            "host": [
</span><span class='line'>              "test-2"
</span><span class='line'>            ]
</span><span class='line'>          },
</span><span class='line'>          "values": [
</span><span class='line'>            [
</span><span class='line'>              1453109876000,
</span><span class='line'>              0.21
</span><span class='line'>            ]
</span><span class='line'>          ]
</span><span class='line'>        }
</span><span class='line'>      ]
</span><span class='line'>    }
</span><span class='line'>  ]
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h2>WEB UI</h2>

<p>KairosDB自带了一个Web界面，你可以通过 <a href="http://localhost:8080">http://localhost:8080</a> 访问。不过这个UI主要是以开发为目的的，可以看到查询的JSON文本，方便调试，比较直观。默认的UI使用了Flot来画图，如果你愿意，也可以使用Highcharts替换。</p>

<h2>Library</h2>

<p>KairosDB目前有一个单独的<a href="https://github.com/kairosdb/kairosdb-client">Java Client</a>，在官网还有一些其他语言的客户端，比如Python、PHP等。</p>

<p>由于是Java客户端，所以还是很容易上手的。比如写入数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MetricBuilder builder = MetricBuilder.getInstance();
</span><span class='line'>builder.addMetric("metric1")
</span><span class='line'>        .addTag("host", "server1")
</span><span class='line'>        .addTag("customer", "Acme")
</span><span class='line'>        .addDataPoint(System.currentTimeMillis(), 10)
</span><span class='line'>        .addDataPoint(System.currentTimeMillis(), 30L);
</span><span class='line'>HttpClient client = new HttpClient("http://localhost:8080");
</span><span class='line'>Response response = client.pushMetrics(builder);
</span><span class='line'>client.shutdown();</span></code></pre></td></tr></table></div></figure>


<p>读取数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>QueryBuilder builder = QueryBuilder.getInstance();
</span><span class='line'>builder.setStart(2, TimeUnit.MONTHS)
</span><span class='line'>       .setEnd(1, TimeUnit.MONTHS)
</span><span class='line'>       .addMetric("metric1")
</span><span class='line'>       .addAggregator(AggregatorFactory.createAverageAggregator(5, TimeUnit.MINUTES));
</span><span class='line'>HttpClient client = new HttpClient("http://localhost:8080");
</span><span class='line'>QueryResponse response = client.query(builder);
</span><span class='line'>client.shutdown();
</span></code></pre></td></tr></table></div></figure>


<p>这应该会非常方便，开发起来比OpenTSDB要快不少了。</p>

<h2>其他API</h2>

<p>KairosDB竟然支持metric删除功能，这个功能会有多少人需要呢？</p>

<p>列出metric名、tag列表、列出tag值，说不定有人会喜欢，比如在输入框自动提示灯功能，可能需要这些元数据。</p>

<h3>列出指标名</h3>

<p>这里除了<code>cpu.load.1</code>是我们自己写入的metric，其余的都是KairosDB自己的指标数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ curl http://localhost:8080/api/v1/metricnames | jq .
</span><span class='line'>
</span><span class='line'>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
</span><span class='line'>                                 Dload  Upload   Total   Spent    Left  Speed
</span><span class='line'>100   501    0   501    0     0  45058      0 --:--:-- --:--:-- --:--:-- 50100
</span><span class='line'>{
</span><span class='line'>  "results": [
</span><span class='line'>    "kairosdb.datastore.query_time",
</span><span class='line'>    "kairosdb.protocol.telnet_request_count",
</span><span class='line'>    "kairosdb.http.ingest_count",
</span><span class='line'>    "kairosdb.datastore.query_row_count",
</span><span class='line'>    "cpu.load.1",
</span><span class='line'>    "kairosdb.protocol.http_request_count",
</span><span class='line'>    "kairosdb.http.ingest_time",
</span><span class='line'>    "kairosdb.jvm.thread_count",
</span><span class='line'>    "kairosdb.jvm.total_memory",
</span><span class='line'>    "kairosdb.jvm.max_memory",
</span><span class='line'>    "kairosdb.metric_counters",
</span><span class='line'>    "kairosdb.jvm.free_memory",
</span><span class='line'>    "kairosdb.datastore.query_sample_size",
</span><span class='line'>    "kairosdb.datastore.query_collisions",
</span><span class='line'>    "kairosdb.http.query_time",
</span><span class='line'>    "kairosdb.http.request_time"
</span><span class='line'>  ]
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>列出tag key</h3>

<p>这个API能列出系统中所有的tag key。不过遗憾的是它不支持只列出某一给定指标的所有tag key。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ curl http://localhost:8080/api/v1/tagnames | jq .
</span><span class='line'>
</span><span class='line'>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
</span><span class='line'>                                 Dload  Upload   Total   Spent    Left  Speed
</span><span class='line'>100    67    0    67    0     0   4188      0 --:--:-- --:--:-- --:--:--  4466
</span><span class='line'>{
</span><span class='line'>  "results": [
</span><span class='line'>    "method",
</span><span class='line'>    "metric_name",
</span><span class='line'>    "query_index",
</span><span class='line'>    "request",
</span><span class='line'>    "host"
</span><span class='line'>  ]
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>列出tag value</h3>

<p>这个API能列出系统中所有的tag value。同样遗憾的是它也不支持只列出某一给定指标的所有tag value。</p>

<p>所以这两个API几乎可以说是然并卵、无鸟用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ curl http://localhost:8080/api/v1/tagvalues | jq .
</span><span class='line'>
</span><span class='line'>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
</span><span class='line'>                                 Dload  Upload   Total   Spent    Left  Speed
</span><span class='line'>100   163    0   163    0     0   5011      0 --:--:-- --:--:-- --:--:--  5093
</span><span class='line'>{
</span><span class='line'>  "results": [
</span><span class='line'>    "1",
</span><span class='line'>    "lius-MacBook-Pro.local",
</span><span class='line'>    "tagnames",
</span><span class='line'>    "/datapoints/query",
</span><span class='line'>    "test-1",
</span><span class='line'>    "test-2",
</span><span class='line'>    "metricnames",
</span><span class='line'>    "query",
</span><span class='line'>    "tags",
</span><span class='line'>    "version",
</span><span class='line'>    "datapoints",
</span><span class='line'>    "putm",
</span><span class='line'>    "cpu.load.1"
</span><span class='line'>  ]
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>KairosDB毕竟是OpenTSDB的一个fork，因此根本上的功能都差不多，而且随着OpenTSDB对Cassandra的支持，感觉KairosDB也该相比OpenTSDB没有什么太大的优势。</p>

<h2>相关阅读</h2>

<p>这是本系列文章的其他部分：</p>

<ul>
<li><a href="http://liubin.github.io/blog/2016/02/18/tsdb-intro/">时序列数据库武斗大会之什么是TSDB</a></li>
<li><a href="http://liubin.github.io/blog/2016/02/25/tsdb-list-part-1/">时序列数据库武斗大会之TSDB名录 Part 1</a></li>
<li><a href="http://liubin.github.io/blog/2016/03/01/tsdb-list-part-2/">时序列数据库武斗大会之TSDB名录 Part 2</a></li>
<li><a href="http://liubin.github.io/blog/2016/03/05/tsdb-opentsdb/">时序列数据库武斗大会之OpenTSDB篇</a></li>
<li>时序列数据库武斗大会之KairosDB篇</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[时序列数据库武斗大会之OpenTSDB篇]]></title>
    <link href="http://liubin.github.io/blog/2016/03/05/tsdb-opentsdb/"/>
    <updated>2016-03-05T00:25:30+08:00</updated>
    <id>http://liubin.github.io/blog/2016/03/05/tsdb-opentsdb</id>
    <content type="html"><![CDATA[<h2>什么是 OpenTSDB</h2>

<p>OpenTSDB ，可以认为是一个时系列数据（库），它基于HBase存储数据，充分发挥了HBase的分布式列存储特性，支持数百万每秒的读写，它的特点就是容易扩展，灵活的tag机制。</p>

<h2>架构简介</h2>

<p>这里我们简单看一下它的架构，如下图所示：</p>

<p><img src="http://77gaj2.com1.z0.glb.clouddn.com/2015/07/09/opentsdb/opentsdb_dataflow.jpg/zoom1" alt="" /></p>

<p>其最主要的部件就是TSD了，这是接收数据并存储到HBase处理的核心所在。而带有C（collector）标志的Server，则是数据采集源，将数据发给 TSD服务。</p>

<h2>安装 OpenTSDB</h2>

<p>为了安装 OpenTSDB ，都需要以下条件和软件：</p>

<ul>
<li>Linux操作系统</li>
<li>JRE 1.6 or later</li>
<li>HBase 0.92 or later</li>
</ul>


<h3>安装GnuPlot</h3>

<p>如果你还想使用自带的界面，则需要安装GnuPlot 4.2及以后版本，以及gd和gd-devel等。这里我们选择了GnuPlot 5.0.1的版本。</p>

<p>根据情况执行（没有就装），安装所需软件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo yum install -y gd gd-devel libpng libpng-devel</span></code></pre></td></tr></table></div></figure>


<p>之后安装GnuPlot：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tar zxvf gnuplot-5.0.1.tar.gz
</span><span class='line'>$ cd gnuplot-5.0.1
</span><span class='line'>$ ./configure
</span><span class='line'>$ make
</span><span class='line'>$ sudo make install</span></code></pre></td></tr></table></div></figure>


<h3>安装HBase</h3>

<p>首先，确保设置了JAVA_HOME：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo $JAVA_HOME
</span><span class='line'>/usr</span></code></pre></td></tr></table></div></figure>


<p>这个不多说了，非常简单，只需要按照 <a href="https://hbase.apache.org/book.html#quickstart">https://hbase.apache.org/book.html#quickstart</a> 这里所说，下载、解压、修改配置文件、启动即可。</p>

<p>这时候，再设置HBASE_HOME：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo $HBASE_HOME
</span><span class='line'>/opt/hbase-1.0.1.1</span></code></pre></td></tr></table></div></figure>


<p>之后便可启动hbase：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /opt/hbase-1.0.1.1/bin/start-hbase.sh
</span><span class='line'>starting master, logging to /opt/hbase-1.0.1.1/logs/hbase-vagrant-master-localhost.localdomain.out</span></code></pre></td></tr></table></div></figure>


<h3>安装 OpenTSDB</h3>

<p>这个也很简单，如果build失败，那肯定是缺少Make或者Autotools等东西，用包管理器安装即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone git://github.com/OpenTSDB/opentsdb.git
</span><span class='line'>$ cd opentsdb
</span><span class='line'>$ ./build.sh</span></code></pre></td></tr></table></div></figure>


<p>创建表OpenTSDB所需要的表结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ env COMPRESSION=NONE ./src/create_table.sh
</span><span class='line'>2016-01-08 06:17:58,045 WARN [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable
</span><span class='line'>HBase Shell; enter ‘help‘ for list of supported commands.
</span><span class='line'>Type “exit” to leave the HBase Shell
</span><span class='line'>Version 1.0.1.1, re1dbf4df30d214fca14908df71d038081577ea46, Sun May 17 12:34:26 PDT 2015
</span><span class='line'>
</span><span class='line'>create ‘tsdb-uid’,
</span><span class='line'>{NAME =&gt; ‘id’, COMPRESSION =&gt; ‘NONE’, BLOOMFILTER =&gt; ‘ROW’},
</span><span class='line'>{NAME =&gt; ‘name’, COMPRESSION =&gt; ‘NONE’, BLOOMFILTER =&gt; ‘ROW’}
</span><span class='line'>0 row(s) in 1.3180 seconds
</span><span class='line'>
</span><span class='line'>Hbase::Table – tsdb-uid
</span><span class='line'>
</span><span class='line'>create ‘tsdb’,
</span><span class='line'>{NAME =&gt; ‘t’, VERSIONS =&gt; 1, COMPRESSION =&gt; ‘NONE’, BLOOMFILTER =&gt; ‘ROW’}
</span><span class='line'>0 row(s) in 0.2400 seconds
</span><span class='line'>
</span><span class='line'>Hbase::Table – tsdb
</span><span class='line'>
</span><span class='line'>create ‘tsdb-tree’,
</span><span class='line'>{NAME =&gt; ‘t’, VERSIONS =&gt; 1, COMPRESSION =&gt; ‘NONE’, BLOOMFILTER =&gt; ‘ROW’}
</span><span class='line'>0 row(s) in 0.2160 seconds
</span><span class='line'>
</span><span class='line'>Hbase::Table – tsdb-tree
</span><span class='line'>
</span><span class='line'>create ‘tsdb-meta’,
</span><span class='line'>{NAME =&gt; ‘name’, COMPRESSION =&gt; ‘NONE’, BLOOMFILTER =&gt; ‘ROW’}
</span><span class='line'>0 row(s) in 0.4480 seconds
</span><span class='line'>
</span><span class='line'>Hbase::Table – tsdb-meta</span></code></pre></td></tr></table></div></figure>


<p>在habse shell里，可以看到表已经创建成功。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; list
</span><span class='line'>TABLE
</span><span class='line'>tsdb
</span><span class='line'>tsdb-meta
</span><span class='line'>tsdb-tree
</span><span class='line'>tsdb-uid
</span><span class='line'>4 row(s) in 0.0160 seconds</span></code></pre></td></tr></table></div></figure>


<p>表创建之后，即可启动tsd服务，只需要运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ build/tsdb tsd</span></code></pre></td></tr></table></div></figure>


<p>如果看到输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2016-01-09 05:51:10,875 INFO [main] TSDMain: Ready to serve on /0.0.0.0:4242</span></code></pre></td></tr></table></div></figure>


<p>即可认为启动成功。</p>

<h2>保存数据到OpenTSDB</h2>

<p>在安装并启动所有服务之后，我们就来尝试发送1条数据吧。</p>

<p>最简单的保存数据方式就是使用telnet。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ telnet localhost 4242
</span><span class='line'>
</span><span class='line'>put sys.cpu.user 1436333416 23 host=web01 user=10001</span></code></pre></td></tr></table></div></figure>


<p>这时，从 OpenTSDB 自带界面都可以看到这些数据。
由于sys.cpu.sys的数据只有一条，所以 OpenTSDB 只能看到一个点。</p>

<p>下图为 OpenTSDB 自带的查询界面，访问 <a href="http://localhost:4242">http://localhost:4242</a> 即可。</p>

<p><img src="http://77gaj2.com1.z0.glb.clouddn.com/2015/07/09/opentsdb/opentsdb-ui.png/zoom1" alt="" /></p>

<h3>OpenTSDB中的数据存储结构</h3>

<p>我们来看看 OpenTSDB 的重要概念uid，先从HBase中存储的数据开始吧，我们来看一下它都有哪些表，以及这些表都是干什么的。</p>

<h4>tsdb：存储数据点</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hbase(main):003:0&gt; scan 'tsdb'
</span><span class='line'>ROW                           COLUMN+CELL                                                                         
</span><span class='line'> \x00\x00\x01U\x9C\xAEP\x00\x column=t:q\x80, timestamp=1436350142588, value=\x17                                 
</span><span class='line'> 00\x01\x00\x00\x01\x00\x00\x                                                                                     
</span><span class='line'> 02\x00\x00\x02                                                                                                   
</span><span class='line'>1 row(s) in 0.2800 seconds
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，该表只有一条数据，我们先不管rowid，只来看看列，只有一列，值为0x17，即十进制23，即该metric的值。</p>

<p>左面的row key则是 OpenTSDB 的特点之一，其规则为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>metric + timestamp + tagk1 + tagv1… + tagkN + tagvN</span></code></pre></td></tr></table></div></figure>


<p>以上属性值均为对应名称的uid。</p>

<p>我们上面添加的metric为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sys.cpu.user 1436333416 23 host=web01 user=10001</span></code></pre></td></tr></table></div></figure>


<p>一共涉及到5个uid，即名为sys.cpu.user的metric，以及host和user两个tagk及其值web01和10001。</p>

<p>上面数据的row key为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\x00\x00\x01U\x9C\xAEP\x00\x00\x01\x00\x00\x01\x00\x00\x02\x00\x00\x02</span></code></pre></td></tr></table></div></figure>


<p>具体这个row key是怎么算出来的，我们来看看tsdb-uid表。</p>

<h4>tsdb-uid：存储name和uid的映射关系</h4>

<p>下面tsdb-uid表的数据，各行之间人为加了空行，为方便显示。</p>

<p>tsdb-uid用来保存名字和UID（metric，tagk，tagv）之间互相映射的关系，都是成组出现的，即给定一个name和uid，会保存（name,uid）和（uid,name）两条记录。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hbase(main):004:0&gt; scan 'tsdb-uid'
</span><span class='line'>ROW                           COLUMN+CELL                                                                         
</span><span class='line'> \x00                         column=id:metrics, timestamp=1436350140242, value=\x00\x00\x00\x00\x00\x00\x00\x01  
</span><span class='line'> \x00                         column=id:tagk, timestamp=1436350141423, value=\x00\x00\x00\x00\x00\x00\x00\x02     
</span><span class='line'> \x00                         column=id:tagv, timestamp=1436350141475, value=\x00\x00\x00\x00\x00\x00\x00\x02     
</span><span class='line'>
</span><span class='line'> \x00\x00\x01                 column=name:metric_meta, timestamp=1436350142592, value={"type":"METRIC","displayNam
</span><span class='line'>                              e":"","description":"","notes":"","created":1436350140,"custom":null}               
</span><span class='line'> \x00\x00\x01                 column=name:metrics, timestamp=1436350140348, value=sys.cpu.user                    
</span><span class='line'> \x00\x00\x01                 column=name:tagk, timestamp=1436350141357, value=host                               
</span><span class='line'> \x00\x00\x01                 column=name:tagk_meta, timestamp=1436350142592, value={"type":"TAGK","displayName":"
</span><span class='line'>                              ","description":"","notes":"","created":1436350141,"custom":null}                   
</span><span class='line'> \x00\x00\x01                 column=name:tagv, timestamp=1436350141385, value=web01                              
</span><span class='line'> \x00\x00\x01                 column=name:tagv_meta, timestamp=1436350142592, value={"type":"TAGV","displayName":"
</span><span class='line'>                              ","description":"","notes":"","created":1436350141,"custom":null}                   
</span><span class='line'>
</span><span class='line'> \x00\x00\x02                 column=name:tagk, timestamp=1436350141462, value=user                               
</span><span class='line'> \x00\x00\x02                 column=name:tagk_meta, timestamp=1436350142592, value={"type":"TAGK","displayName":"
</span><span class='line'>                              ","description":"","notes":"","created":1436350141,"custom":null}                   
</span><span class='line'> \x00\x00\x02                 column=name:tagv, timestamp=1436350141480, value=10001                              
</span><span class='line'> \x00\x00\x02                 column=name:tagv_meta, timestamp=1436350142592, value={"type":"TAGV","displayName":"
</span><span class='line'>                              ","description":"","notes":"","created":1436350141,"custom":null}                   
</span><span class='line'>
</span><span class='line'> 10001                        column=id:tagv, timestamp=1436350141495, value=\x00\x00\x02                         
</span><span class='line'>
</span><span class='line'> host                         column=id:tagk, timestamp=1436350141363, value=\x00\x00\x01                         
</span><span class='line'>
</span><span class='line'> sys.cpu.user                 column=id:metrics, timestamp=1436350140408, value=\x00\x00\x01                      
</span><span class='line'>
</span><span class='line'> user                         column=id:tagk, timestamp=1436350141466, value=\x00\x00\x02                         
</span><span class='line'>
</span><span class='line'> web01                        column=id:tagv, timestamp=1436350141396, value=\x00\x00\x01                         
</span><span class='line'>
</span><span class='line'>8 row(s) in 0.7280 seconds</span></code></pre></td></tr></table></div></figure>


<p>我们一共看到了8行数据。</p>

<p>前面我们在tsdb表中已经看到，metric数据的row key为\x00\x00\x01U\x9C\xAEP\x00\x00\x01\x00\x00\x01\x00\x00\x02\x00\x00\x02
，我们将其分解下，用+号连起来（从name到uid的映射为最后5行）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> \x00\x00\x01 + U + \x9C\xAE + P + \x00\x00\x01 + \x00\x00\x01 + \x00\x00\x02  + \x00\x00\x02
</span><span class='line'>sys.cpu.user       1436333416           host    =      web01          user     =    10001
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，这和我们前面说到的row key的构成方式是吻合的。</p>

<p>需要着重说明的是时间戳的存储方式。</p>

<p>虽然我们指定的时间是以秒为单位的，但是，row key中用到的却是以一小时为单位的，即：1436333416 – 1436333416 % 3600 = 1436331600 。</p>

<p>1436331600转换为16进制，即0x55 0x9c 0xae 0x50，而0x55即大写字母U，0x50为大写字母P，这就是4个字节的时间戳存储方式。相信下面这张图能帮助各位更好理解这个意思，即一小时只有一个row key，每秒钟的数据都会存为一列，大大提高查询的速度。</p>

<p><img src="http://77gaj2.com1.z0.glb.clouddn.com/2015/07/09/opentsdb/row-key-storage.png/zoom1" alt="" /></p>

<p>反过来，从uid到name也一样，比如找uid为\x00\x00\x02的tagk，我们从上面结果可以看到，该row key（\x00\x00\x02）有4列，而column=name:tagk的value就是user，非常简单直观。</p>

<p>重要：我们看到，上面的metric也好，tagk或者tagv也好，uid只有3个字节，这是 OpenTSDB 的默认配置，三个字节，应该能表示1600多万的不同数据，这对metric名或者tagk来说足够长了，对tagv来说就不一定了，比如tagv是ip地址的话，或者电话号码，那么这个字段就不够长了，这时可以通过修改源代码来重新编译 OpenTSDB 就可以了，同时要注意的是，重编以后，老数据就不能直接使用了，需要导出后重新导入。</p>

<h4>tsdb-meta：元数据表</h4>

<p>我们再看下第三个表tsdb-meta，这是用来存储时间序列索引和元数据的表。这也是一个可选特性，默认是不开启的，可以通过配置文件来启用该特性，这里不做特殊介绍了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hbase(main):005:0&gt; scan 'tsdb-meta'
</span><span class='line'>ROW                           COLUMN+CELL                                                                         
</span><span class='line'> \x00\x00\x01\x00\x00\x01\x00 column=name:ts_ctr, timestamp=1436350141578, value=\x00\x00\x00\x00\x00\x00\x00\x01 
</span><span class='line'> \x00\x01\x00\x00\x02\x00\x00                                                                                     
</span><span class='line'> \x02                                                                                                             
</span><span class='line'> \x00\x00\x01\x00\x00\x01\x00 column=name:ts_meta, timestamp=1436350142589, value={"tsuid":"0000010000010000010000
</span><span class='line'> \x00\x01\x00\x00\x02\x00\x00 02000002","displayName":"","description":"","notes":"","created":1436350141,"custom"
</span><span class='line'> \x02                         :null,"units":"","dataType":"","retention":0,"max":"NaN","min":"NaN"}               
</span><span class='line'>1 row(s) in 0.1320 seconds</span></code></pre></td></tr></table></div></figure>


<h4>tsdb-tree：树形表</h4>

<p>第4个表是tsdb-tree，用来以树状层次关系来表示metric的结构，只有在配置文件开启该特性后，才会使用此表，这里我们不介绍了，可以自己尝试。</p>

<h3>通过HTTP接口保存数据</h3>

<p>保存数据除了我们前面用到的telnet方式，也可以选择HTTP API或者批量导入工具import（ <a href="http://opentsdb.net/docs/build/html/user_guide/cli/import.html">http://opentsdb.net/docs/build/html/user_guide/cli/import.html</a> ），这里我们再对HTTP API进行简单示例说明。</p>

<p>假设我们有如下数据，保存为文件mysql.json：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">[</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;metric&quot;</span><span class="p">:</span> <span class="s2">&quot;mysql.innodb.row_lock_time&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;timestamp&quot;</span><span class="p">:</span> <span class="mi">1435716527</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="mi">1234</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;tags&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>           <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;web01&quot;</span><span class="p">,</span>
</span><span class='line'>           <span class="nt">&quot;dc&quot;</span><span class="p">:</span> <span class="s2">&quot;beijing&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;metric&quot;</span><span class="p">:</span> <span class="s2">&quot;mysql.innodb.row_lock_time&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;timestamp&quot;</span><span class="p">:</span> <span class="mi">1435716529</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="mi">2345</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;tags&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>           <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;web01&quot;</span><span class="p">,</span>
</span><span class='line'>           <span class="nt">&quot;dc&quot;</span><span class="p">:</span> <span class="s2">&quot;beijing&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;metric&quot;</span><span class="p">:</span> <span class="s2">&quot;mysql.innodb.row_lock_time&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;timestamp&quot;</span><span class="p">:</span> <span class="mi">1435716627</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="mi">3456</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;tags&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>           <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;web02&quot;</span><span class="p">,</span>
</span><span class='line'>           <span class="nt">&quot;dc&quot;</span><span class="p">:</span> <span class="s2">&quot;beijing&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;metric&quot;</span><span class="p">:</span> <span class="s2">&quot;mysql.innodb.row_lock_time&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;timestamp&quot;</span><span class="p">:</span> <span class="mi">1435716727</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="mi">6789</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;tags&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>           <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;web01&quot;</span><span class="p">,</span>
</span><span class='line'>           <span class="nt">&quot;dc&quot;</span><span class="p">:</span> <span class="s2">&quot;tianjin&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后执行如下命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">$</span> <span class="err">curl</span> <span class="err">-X</span> <span class="err">POST</span> <span class="err">-H</span> <span class="err">“Content-Type:</span> <span class="err">application/json”</span> <span class="err">http://localhost:</span><span class="mi">4242</span><span class="err">/api/put</span> <span class="err">-d</span> <span class="err">@mysql.json</span>
</span></code></pre></td></tr></table></div></figure>


<p>即可将数据保存到 OpenTSDB 了。</p>

<h2>查询数据</h2>

<p>看完了如何保存数据，我们再来看看如何查询数据。</p>

<p>查询数据可以使用query接口，它既可以使用get的query string方式，也可以使用post方式以JSON格式指定查询条件，这里我们以后者为例，对刚才保存的数据进行说明。</p>

<p>首先，保存如下内容为search.json：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;start&quot;</span><span class="p">:</span> <span class="mi">1435716527</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;queries&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="nt">&quot;metric&quot;</span><span class="p">:</span> <span class="s2">&quot;mysql.innodb.row_lock_time&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="nt">&quot;aggregator&quot;</span><span class="p">:</span> <span class="s2">&quot;avg&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="nt">&quot;tags&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>                <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="nt">&quot;dc&quot;</span><span class="p">:</span> <span class="s2">&quot;beijing&quot;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行如下命令进行查询：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">$</span> <span class="err">curl</span> <span class="err">-s</span> <span class="err">-X</span> <span class="err">POST</span> <span class="err">-H</span> <span class="s2">&quot;Content-Type: application/json&quot;</span> <span class="err">http://localhost:</span><span class="mi">4242</span><span class="err">/api/query</span> <span class="err">-d</span> <span class="err">@search.json</span> <span class="err">|</span> <span class="err">jq</span> <span class="err">.</span>
</span><span class='line'><span class="p">[</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;metric&quot;</span><span class="p">:</span> <span class="s2">&quot;mysql.innodb.row_lock_time&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;tags&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;web01&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="nt">&quot;dc&quot;</span><span class="p">:</span> <span class="s2">&quot;beijing&quot;</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="nt">&quot;aggregateTags&quot;</span><span class="p">:</span> <span class="p">[],</span>
</span><span class='line'>    <span class="nt">&quot;dps&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nt">&quot;1435716527&quot;</span><span class="p">:</span> <span class="mi">1234</span><span class="p">,</span>
</span><span class='line'>      <span class="nt">&quot;1435716529&quot;</span><span class="p">:</span> <span class="mi">2345</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;metric&quot;</span><span class="p">:</span> <span class="s2">&quot;mysql.innodb.row_lock_time&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;tags&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;web02&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="nt">&quot;dc&quot;</span><span class="p">:</span> <span class="s2">&quot;beijing&quot;</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="nt">&quot;aggregateTags&quot;</span><span class="p">:</span> <span class="p">[],</span>
</span><span class='line'>    <span class="nt">&quot;dps&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nt">&quot;1435716627&quot;</span><span class="p">:</span> <span class="mi">3456</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，我们保存了<code>dc=tianjin</code>的数据，但是并没有在此查询中返回，这是因为，我们指定了<code>dc=beijing</code>这一条件。</p>

<p>值得注意的是，tags参数在新版本2.2中，将不被推荐，取而代之的是filters参数。</p>

<h2>总结</h2>

<p>可以看出来， OpenTSDB 还是非常容易上手的，尤其是单机版，安装也很简单。有HBase作为后盾，查询起来也非常快，很多大公司，类似雅虎等，也都在用此软件。</p>

<p>但是，大规模用起来，多个TDB以及多存储节点等，应该都需要专业、细心的运维工作了。</p>

<h2>相关阅读</h2>

<p>这是本系列文章的其他部分：</p>

<ul>
<li><a href="http://liubin.github.io/blog/2016/02/18/tsdb-intro/">时序列数据库武斗大会之什么是TSDB</a></li>
<li><a href="http://liubin.github.io/blog/2016/02/25/tsdb-list-part-1/">时序列数据库武斗大会之TSDB名录 Part 1</a></li>
<li><a href="http://liubin.github.io/blog/2016/03/01/tsdb-list-part-2/">时序列数据库武斗大会之TSDB名录 Part 2</a></li>
<li>时序列数据库武斗大会之OpenTSDB篇</li>
<li><a href="http://liubin.github.io/blog/2016/03/12/tsdb-kairosdb/">时序列数据库武斗大会之KairosDB篇</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
